<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>孙文正的Blog</title>
  
  <subtitle>天道酬勤</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://jsxzswz.github.io/"/>
  <updated>2019-01-22T03:10:35.548Z</updated>
  <id>https://jsxzswz.github.io/</id>
  
  <author>
    <name>孙文正</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySQL(解压版)安装教程</title>
    <link href="https://jsxzswz.github.io/2019/01/21/blog20190121/"/>
    <id>https://jsxzswz.github.io/2019/01/21/blog20190121/</id>
    <published>2019-01-21T08:36:36.742Z</published>
    <updated>2019-01-22T03:10:35.548Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>MySQL是一种开放源代码的关系型数据库管理系统（RDBMS），MySQL数据库系统使用最常用的数据库管理语言–结构化查询语言（SQL）进行数据库管理。由于MySQL是开放源代码的，因此任何人都可以在General Public License的许可下下载并根据个性化的需要对其进行修改。MySQL因为其速度、可靠性和适应性而备受关注。大多数人都认为在不需要事务化处理的情况下，MySQL是管理内容最好的选择。</p><a id="more"></a><h2 id="MySQL安装"><a href="#MySQL安装" class="headerlink" title="MySQL安装"></a>MySQL安装</h2><p>MySQL分为安装版和解压版，个人推荐解压版MySQL，详细步骤如下：</p><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>访问地址<a href="https://dev.mysql.com/downloads/mysql/" target="_blank" rel="noopener">MySQL官网下载地址</a>，目前最新版是8.0.13。如果你不想下载最新版，想下载以前的版本，可以点击如下图的链接进行下载：</p><p><img src="/images/mysql1.png" alt="MySQL" title="MySQL 8.0.13"></p><p>根据你的系统（32位或者64位）选择后缀是ZIP Archive的压缩包下载到本地，这里我选择的是5.7.21版本，如图：</p><p><img src="/images/mysql2.png" alt="MySQL" title="MySQL 5.7.21压缩包"></p><p>点击Download进入下载页，这里要求你注册登陆, 不用管直接点击<b>No thanks, just start my download</b>， 按钮进行下载，如下图所示：</p><p><img src="/images/mysql3.png" alt="MySQL" title="MySQL 5.7.21下载"></p><h3 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h3><p>选择一个路径（建议将常用的工具分类放在同一文件夹如D:\MySQL）解压压缩包。</p><h3 id="配置my-ini"><a href="#配置my-ini" class="headerlink" title="配置my.ini"></a>配置my.ini</h3><p>需要新建一个my.ini文件，在my.ini文件中添加如下信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[mysql]</span><br><span class="line">#设置mysql客户端默认字符集</span><br><span class="line">default-character-set=utf8</span><br><span class="line">[mysqld]</span><br><span class="line">#设置3306端口</span><br><span class="line">port=3306</span><br><span class="line"># 设置mysql的安装目录</span><br><span class="line">basedir=D:\MySQL\mysql-5.7.21-winx64</span><br><span class="line"># 设置mysql数据库的数据的存放目录</span><br><span class="line">datadir=D:\MySQL\mysql-5.7.21-winx64\data</span><br><span class="line"># 允许最大连接数</span><br><span class="line">max_connections=200</span><br><span class="line"># 服务端使用的字符集默认为8比特编码的latin1字符集</span><br><span class="line">character-set-server=utf8</span><br><span class="line"># 创建新表时将使用的默认存储引擎</span><br><span class="line">default-storage-engine=INNODB</span><br></pre></td></tr></table></figure><h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><ul><li>右键计算机–属性–高级系统设置–环境变量，新建系统变量<b>MySQL_HOME</b>，添加MySQL解压的目录（我这里是D:\MySQL\mysql-5.7.21-winx64）；</li><li>在系统变量中找到Path编辑，在结尾处追加<b>%MySQL_HOME%\bin;</b>，如果原变量值结尾没有分号，需要先加分号。如下图所示：</li></ul><p><img src="/images/env_var1.png" alt="环境变量" title="MySQL_HOME环境变量"></p><p><img src="/images/env_var2.png" alt="环境变量" title="PATH环境变量"></p><p>配置环境变量后启动MySQL就不必到MySQL的bin目录下启动了，直接在cmd中直接输入<b>net start mysql</b> 启动服务了。</p><h3 id="初始化MySQL"><a href="#初始化MySQL" class="headerlink" title="初始化MySQL"></a>初始化MySQL</h3><p>win7用户使用<b>window+R</b>（更高系统版本需要搜索程序cmd右键以管理员身份运行）以管理员身份运行cmd，依次输入命令<code>d:</code>，<code>cd D:\MySQL\mysql-5.7.21-winx64\bin</code>进入MySQL的bin目录，执行<code>mysqld --initialize</code>进行初始化，此时你的MySQL根目录下会生成一个data文件夹，如下图所示：</p><p><img src="/images/cmd.png" alt="命令窗口" title="cmd窗口"></p><p><img src="/images/fm.png" alt="文件管理器" title="FM文件管理"></p><h3 id="安装启动MySQL服务"><a href="#安装启动MySQL服务" class="headerlink" title="安装启动MySQL服务"></a>安装启动MySQL服务</h3><p>还是在bin路径下输入：<code>mysqld install</code>，此时会提示服务安装成功。至此，MySQL（解压版）安装成功！<br>直接在cmd中输入：<code>net start mysql</code>，提示服务启动成功。</p><h3 id="登录MySQL"><a href="#登录MySQL" class="headerlink" title="登录MySQL"></a>登录MySQL</h3><p>cmd输入：<code>mysql -u root -p</code>,这时会提示你输入密码。打开MySQL根目录下的data文件夹，找到后缀是.err的文件以文本打开找到password临时密码（可以ctrl+f搜索）然后在cmd中输入该临时密码。当cmd出现下图信息则代表登录成功。</p><p><img src="/images/temp_pwd.png" alt="临时密码" title="root临时密码"></p><p><img src="/images/login.png" alt="登陆MySQL" title="登陆MySQL"></p><h3 id="修改root密码"><a href="#修改root密码" class="headerlink" title="修改root密码"></a>修改root密码</h3><p>在上述的mysql&gt;后输入：<code>set password for 用户名@localhost = password(&#39;新密码&#39;);</code>，用户名一般是root，并设置新密码，如图所示：</p><p><img src="/images/update_pwd.png" alt="修改密码" title="password修改"></p><h3 id="停止服务"><a href="#停止服务" class="headerlink" title="停止服务"></a>停止服务</h3><p>cmd输入：<code>net stop mysql</code>，提示服务已成功停止。</p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>好了，到这里MySQL就已经安装完成了，祝大家顺利安装！</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;MySQL是一种开放源代码的关系型数据库管理系统（RDBMS），MySQL数据库系统使用最常用的数据库管理语言–结构化查询语言（SQL）进行数据库管理。由于MySQL是开放源代码的，因此任何人都可以在General Public License的许可下下载并根据个性化的需要对其进行修改。MySQL因为其速度、可靠性和适应性而备受关注。大多数人都认为在不需要事务化处理的情况下，MySQL是管理内容最好的选择。&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="https://jsxzswz.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="mysql" scheme="https://jsxzswz.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>MySQL数据类型</title>
    <link href="https://jsxzswz.github.io/2019/01/14/blog20190114/"/>
    <id>https://jsxzswz.github.io/2019/01/14/blog20190114/</id>
    <published>2019-01-14T02:58:48.712Z</published>
    <updated>2019-01-30T02:12:54.660Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>MySQL中定义数据字段的类型对数据库的优化是非常重要的，MySQL支持多种类型，大致可以分为五类：整数类型、浮点数类型、日期类型、字符串类型和其他数据类型。对于Mysql的一些常用数据类型了解程度仅限于一知半解，仅仅能满足满足于平时一些最简单的操作。而Mysql常用数据类型的定义以及规范理解的并不是特别的透彻，对于这些东西的理解并不深刻，经不起推敲和较真。故有此文，帮助自己总结归纳，并加深理解。</p><a id="more"></a><h2 id="MySQL的数据类型"><a href="#MySQL的数据类型" class="headerlink" title="MySQL的数据类型"></a>MySQL的数据类型</h2><p>主要包括以下五大类：<br>整数类型：BIT、BOOL、TINY INT、SMALL INT、MEDIUM INT、 INT、 BIG INT<br>浮点数类型：FLOAT、DOUBLE、DECIMAL<br>字符串类型：CHAR、VARCHAR、TINY TEXT、TEXT、MEDIUM TEXT、LONGTEXT、TINY BLOB、BLOB、MEDIUM BLOB、LONG BLOB<br>日期类型：Date、DateTime、TimeStamp、Time、Year<br>其他数据类型：BINARY、VARBINARY、ENUM、SET、Geometry、Point、MultiPoint、LineString、MultiLineString、Polygon、GeometryCollection等</p><h3 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h3><table><thead><tr><th style="text-align:center">MySQL数据类型</th><th style="text-align:center">含义（有符号）</th></tr></thead><tbody><tr><td style="text-align:center">tinyint(m)</td><td style="text-align:center">1个字节 范围(-128~127)</td></tr><tr><td style="text-align:center">smallint(m)</td><td style="text-align:center">2个字节 范围(-32768~32767)</td></tr><tr><td style="text-align:center">mediumint(m)</td><td style="text-align:center">3个字节 范围(-8388608~8388607)</td></tr><tr><td style="text-align:center">int(m)</td><td style="text-align:center">4个字节 范围(-2147483648~2147483647)</td></tr><tr><td style="text-align:center">bigint(m)</td><td style="text-align:center">8个字节 范围(+-9.22*10的18次方)</td></tr></tbody></table><p>取值范围如果加了unsigned，则最大值翻倍，如tinyint unsigned的取值范围为(0~256)。<br>int(m)里的m是表示SELECT查询结果集中的显示宽度，并不影响实际的取值范围，没有影响到显示的宽度，不知道这个m有什么用。</p><h3 id="浮点型-float和double"><a href="#浮点型-float和double" class="headerlink" title="浮点型(float和double)"></a>浮点型(float和double)</h3><table><thead><tr><th style="text-align:center">MySQL数据类型</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">float(m,d)</td><td style="text-align:center">单精度浮点型 8位精度(4字节) m总个数，d小数位</td></tr><tr><td style="text-align:center">double(m,d)</td><td style="text-align:center">双精度浮点型 16位精度(8字节) m总个数，d小数位</td></tr></tbody></table><p>设一个字段定义为float(6,3)，如果插入一个数123.45678,实际数据库里存的是123.457，但总个数还以实际为准，即6位。整数部分最大是3位，如果插入数12.123456，存储的是12.1234，如果插入12.12，存储的是12.1200.</p><h3 id="定点数"><a href="#定点数" class="headerlink" title="定点数"></a>定点数</h3><p>浮点型在数据库中存放的是近似值，而定点类型在数据库中存放的是精确值。<br>decimal(m,d) 参数m&lt;65 是总个数，d&lt;30且 小于m是小数位。</p><h3 id="字符串-char-varchar-text"><a href="#字符串-char-varchar-text" class="headerlink" title="字符串(char,varchar,_text)"></a>字符串(char,varchar,_text)</h3><table><thead><tr><th style="text-align:center">MySQL数据类型</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">char(n)</td><td style="text-align:center">固定长度，最多255个字符</td></tr><tr><td style="text-align:center">varchar(n)</td><td style="text-align:center">固定长度，最多65535个字符</td></tr><tr><td style="text-align:center">tinytext</td><td style="text-align:center">可变长度，最多255个字符</td></tr><tr><td style="text-align:center">text</td><td style="text-align:center">可变长度，最多65535个字符</td></tr><tr><td style="text-align:center">mediumtext</td><td style="text-align:center">可变长度，最多2的24次方-1个字符</td></tr><tr><td style="text-align:center">longtext</td><td style="text-align:center">可变长度，最多2的32次方-1个字符</td></tr></tbody></table><h4 id="char和varchar："><a href="#char和varchar：" class="headerlink" title="char和varchar："></a>char和varchar：</h4><ul><li>char(n) 若存入字符数小于n，则以空格补于其后，查询之时再将空格去掉。所以char类型存储的字符串末尾不能有空格，varchar不限于此。</li><li>char(n) 固定长度，char(4)不管是存入几个字符，都将占用4个字节，varchar是存入的实际字符数+1个字节（n&lt;=255）或2个字节(n&gt;255)，所以varchar(4),存入3个字符将占用4个字节。</li><li>char类型的字符串检索速度要比varchar类型的快。</li></ul><h4 id="varchar和text："><a href="#varchar和text：" class="headerlink" title="varchar和text："></a>varchar和text：</h4><ul><li>varchar可指定n，text不能指定，内部存储varchar是存入的实际字符数+1个字节（n&lt;=255）或2个字节(n&gt;255)，text是实际字符数+2个字<br>节。</li><li>text类型不能有默认值。</li><li>varchar可直接创建索引，text创建索引要指定前多少个字符。varchar查询速度快于text,在都创建索引的情况下，text的索引似乎不起作用。</li></ul><h3 id="二进制数据-Blob"><a href="#二进制数据-Blob" class="headerlink" title="二进制数据(_Blob)"></a>二进制数据(_Blob)</h3><ul><li>_BLOB和_text存储方式不同，_TEXT以文本方式存储，英文存储区分大小写，而_Blob是以二进制方式存储，不分大小写。</li><li>_BLOB存储的数据只能整体读出。</li><li>_TEXT可以指定字符集，_BLO不用指定字符集。</li></ul><h3 id="日期时间类型"><a href="#日期时间类型" class="headerlink" title="日期时间类型"></a>日期时间类型</h3><table><thead><tr><th style="text-align:center">MySQL数据类型</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">date</td><td style="text-align:center">日期 ‘2019-01-12’</td></tr><tr><td style="text-align:center">time</td><td style="text-align:center">时间 ‘12:25:36’</td></tr><tr><td style="text-align:center">datetime</td><td style="text-align:center">日期时间 ‘2019-01-12 22:06:44’</td></tr><tr><td style="text-align:center">timestamp</td><td style="text-align:center">自动存储记录修改时间</td></tr></tbody></table><p>若定义一个字段为timestamp，这个字段里的时间数据会随其他字段修改的时候自动刷新，所以这个数据类型的字段可以存放这条记录最后被修改的时间。</p><h3 id="数据类型的属性"><a href="#数据类型的属性" class="headerlink" title="数据类型的属性"></a>数据类型的属性</h3><table><thead><tr><th style="text-align:center">MySQL数据类型</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">NULL</td><td style="text-align:center">数据列可包含NULL值</td></tr><tr><td style="text-align:center">NOT NULL</td><td style="text-align:center">数据列不允许包含NULL值</td></tr><tr><td style="text-align:center">DEFAULT</td><td style="text-align:center">默认值</td></tr><tr><td style="text-align:center">PRIMARY KEY</td><td style="text-align:center">主键</td></tr><tr><td style="text-align:center">AUTO_INCREMENT</td><td style="text-align:center">自动递增，适用于整数类型</td></tr><tr><td style="text-align:center">UNSIGNED</td><td style="text-align:center">无符号</td></tr><tr><td style="text-align:center">CHARACTER SET name</td><td style="text-align:center">指定一个字符集</td></tr></tbody></table><h2 id="MySQL数据类型的长度和范围"><a href="#MySQL数据类型的长度和范围" class="headerlink" title="MySQL数据类型的长度和范围"></a>MySQL数据类型的长度和范围</h2><p>各数据类型及字节长度一览表：</p><table><thead><tr><th style="text-align:center">MySQL数据类型</th><th style="text-align:center">字节长度</th><th style="text-align:center">范围或用法</th></tr></thead><tbody><tr><td style="text-align:center">Bit</td><td style="text-align:center">1</td><td style="text-align:center">无符号[0,255]，有符号[-128,127]，天缘博客备注：BIT和BOOL布尔型都占用1字节</td></tr><tr><td style="text-align:center">TinyInt</td><td style="text-align:center">1</td><td style="text-align:center">整数[0,255]</td></tr><tr><td style="text-align:center">SmallInt</td><td style="text-align:center">2</td><td style="text-align:center">无符号[0,65535]，有符号[-32768,32767]</td></tr><tr><td style="text-align:center">MediumInt</td><td style="text-align:center">3</td><td style="text-align:center">无符号[0,2^24-1]，有符号[-2^23,2^23-1]]</td></tr><tr><td style="text-align:center">Int</td><td style="text-align:center">4</td><td style="text-align:center">无符号[0,2^32-1]，有符号[-2^31,2^31-1]</td></tr><tr><td style="text-align:center">BigInt</td><td style="text-align:center">8</td><td style="text-align:center">无符号[0,2^64-1]，有符号[-2^63 ,2^63 -1]</td></tr><tr><td style="text-align:center">Float(M,D)</td><td style="text-align:center">4</td><td style="text-align:center">单精度浮点数。天缘博客提醒这里的D是精度，如果D&lt;=24则为默认的FLOAT，如果D&gt;24则会自动被转换为DOUBLE型。</td></tr><tr><td style="text-align:center">Double(M,D)</td><td style="text-align:center">8</td><td style="text-align:center">双精度浮点。</td></tr><tr><td style="text-align:center">Decimal(M,D)</td><td style="text-align:center">M+1或M+2</td><td style="text-align:center">未打包的浮点数，用法类似于FLOAT和DOUBLE，天缘博客提醒您如果在ASP中使用到Decimal数据类型，直接从数据库读出来的Decimal可能需要先转换成Float或Double类型后再进行运算。</td></tr><tr><td style="text-align:center">Date</td><td style="text-align:center">3</td><td style="text-align:center">以YYYY-MM-DD的格式显示，比如：2009-07-19</td></tr><tr><td style="text-align:center">Datetime</td><td style="text-align:center">8</td><td style="text-align:center">以YYYY-MM-DD HH:MM:SS的格式显示，比如：2009-07-19 11：22：30</td></tr><tr><td style="text-align:center">TimeStamp</td><td style="text-align:center">4</td><td style="text-align:center">以YYYY-MM-DD的格式显示，比如：2009-07-19</td></tr><tr><td style="text-align:center">Time</td><td style="text-align:center">3</td><td style="text-align:center">以HH:MM:SS的格式显示。比如：11：22：30</td></tr><tr><td style="text-align:center">Year</td><td style="text-align:center">1</td><td style="text-align:center">以YYYY的格式显示。比如：2009</td></tr><tr><td style="text-align:center">Char(M)</td><td style="text-align:center">M</td><td style="text-align:center">定长字符串。</td></tr><tr><td style="text-align:center">VarChar(M)</td><td style="text-align:center">M</td><td style="text-align:center">变长字符串，要求M&lt;=255</td></tr><tr><td style="text-align:center">Binary(M)</td><td style="text-align:center">M</td><td style="text-align:center">类似Char的二进制存储，特点是插入定长不足补0</td></tr><tr><td style="text-align:center">VarBinary(M)</td><td style="text-align:center">M</td><td style="text-align:center">类似VarChar的变长二进制存储，特点是定长不补0</td></tr><tr><td style="text-align:center">Tiny Text</td><td style="text-align:center">Max:255</td><td style="text-align:center">大小写不敏感</td></tr><tr><td style="text-align:center">Text</td><td style="text-align:center">Max:64K</td><td style="text-align:center">大小写不敏感</td></tr><tr><td style="text-align:center">Medium Text</td><td style="text-align:center">Max:16M</td><td style="text-align:center">大小写不敏感</td></tr><tr><td style="text-align:center">Long Tex</td><td style="text-align:center">t    Max:4G</td><td style="text-align:center">大小写不敏感</td></tr><tr><td style="text-align:center">TinyBlob</td><td style="text-align:center">Max:255</td><td style="text-align:center">大小写敏感</td></tr><tr><td style="text-align:center">Blob</td><td style="text-align:center">Max:64K</td><td style="text-align:center">大小写敏感</td></tr><tr><td style="text-align:center">MediumBlob</td><td style="text-align:center">Max:16M</td><td style="text-align:center">大小写敏感</td></tr><tr><td style="text-align:center">LongBlob</td><td style="text-align:center">Max:4G</td><td style="text-align:center">大小写敏感</td></tr><tr><td style="text-align:center">Enum</td><td style="text-align:center">1或2</td><td style="text-align:center">最大可达65535个不同的枚举值</td></tr><tr><td style="text-align:center">Set</td><td style="text-align:center">可达8</td><td style="text-align:center">最大可达64个不同的值</td></tr><tr><td style="text-align:center">Geometry</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">Point</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">LineString</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">Polygon</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">MultiPoint</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">MultiLineString</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">MultiPolygon</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">GeometryCollection</td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table><h2 id="MySQL数据类型使用建议"><a href="#MySQL数据类型使用建议" class="headerlink" title="MySQL数据类型使用建议"></a>MySQL数据类型使用建议</h2><ul><li>在指定数据类型的时候一般是采用从小原则，比如能用TINY INT的最好就不用INT，能用FLOAT类型的就不用DOUBLE类型，这样会对MYSQL在运行效率上提高很大，尤其是大数据量测试条件下。</li><li>不需要把数据表设计的太过复杂，功能模块上区分或许对于后期的维护更为方便，慎重出现大杂烩数据表</li><li>数据表和字段的起名字也是一门学问</li><li>设计数据表结构之前请先想象一下是你的房间，或许结果会更加合理、高效</li><li>数据库的最后设计结果一定是效率和可扩展性的折中，偏向任何一方都是欠妥的</li></ul><h2 id="附录："><a href="#附录：" class="headerlink" title="附录："></a>附录：</h2><h3 id="选择数据类型的基本原则"><a href="#选择数据类型的基本原则" class="headerlink" title="选择数据类型的基本原则"></a>选择数据类型的基本原则</h3><p>前提：使用合适的存储引擎。<br>选择原则：根据选定的存储引擎，确定如何选择合适的数据类型。<br>下面的选择方法按存储引擎分类：</p><ul><li>MyISAM 数据存储引擎和数据列：MyISAM数据表，最好使用固定长度(CHAR)的数据列代替可变长度(VARCHAR)的数据列。</li><li>MEMORY存储引擎和数据列：MEMORY数据表目前都使用固定长度的数据行存储，因此无论使用CHAR或VARCHAR列都没有关系。两者都是作为CHAR类型处理的。</li><li>InnoDB 存储引擎和数据列：建议使用 VARCHAR类型。</li></ul><p>对于InnoDB数据表，内部的行存储格式没有区分固定长度和可变长度列（所有数据行都使用指向数据列值的头指针），因此在本质上，使用固定长度的CHAR列不一定比使用可变长度VARCHAR列简单。因而，主要的性能因素是数据行使用的存储总量。由于CHAR平均占用的空间多于VARCHAR，因 此使用VARCHAR来最小化需要处理的数据行的存储总量和磁盘I/O是比较好的。</p><h3 id="char与varchar"><a href="#char与varchar" class="headerlink" title="char与varchar"></a>char与varchar</h3><p>CHAR和VARCHAR类型类似，但它们保存和检索的方式不同。它们的最大长度和是否尾部空格被保留等方面也不同。在存储或检索过程中不进行大小写转换。<br>下面的表显示了将各种字符串值保存到CHAR(4)和VARCHAR(4)列后的结果，说明了CHAR和VARCHAR之间的差别：</p><table><thead><tr><th style="text-align:center">值</th><th style="text-align:center">CHAR(4)</th><th style="text-align:center">存储需求</th><th style="text-align:center">VARCHAR(4)</th><th style="text-align:center">存储需求</th></tr></thead><tbody><tr><td style="text-align:center">‘’</td><td style="text-align:center">‘    ‘</td><td style="text-align:center">4个字节</td><td style="text-align:center">‘’</td><td style="text-align:center">1个字节</td></tr><tr><td style="text-align:center">‘ab’</td><td style="text-align:center">‘ab  ‘</td><td style="text-align:center">4个字节</td><td style="text-align:center">‘ab ‘</td><td style="text-align:center">3个字节</td></tr><tr><td style="text-align:center">‘abcd’</td><td style="text-align:center">‘abcd’</td><td style="text-align:center">4个字节</td><td style="text-align:center">‘abcd’</td><td style="text-align:center">5个字节</td></tr><tr><td style="text-align:center">‘abcdefgh’</td><td style="text-align:center">‘abcd’</td><td style="text-align:center">4个字节</td><td style="text-align:center">‘abcd’</td><td style="text-align:center">5个字节</td></tr></tbody></table><p>请注意上表中最后一行的值只适用不使用严格模式时；如果MySQL运行在严格模式，超过列长度不的值不保存，并且会出现错误。<br>从CHAR(4)和VARCHAR(4)列检索的值并不总是相同，因为检索时从CHAR列删除了尾部的空格。</p><h3 id="text和blob"><a href="#text和blob" class="headerlink" title="text和blob"></a>text和blob</h3><p>在使用text和blob字段类型时要注意以下几点，以便更好的发挥数据库的性能。</p><ul><li>BLOB和TEXT值也会引起自己的一些问题，特别是执行了大量的删除或更新操作的时候。删除这种值会在数据表中留下很大的”空洞”，以后填入这些”空洞”的记录可能长度不同,为了提高性能,建议定期使用 OPTIMIZE TABLE 功能对这类表进行碎片整理.</li><li>使用合成的（synthetic）索引。合成的索引列在某些时候是有用的。一种办法是根据其它的列的内容建立一个散列值，并把这个值存储在单独的数据列中。接下来你就可以通过检索散列值找到数据行了。但是，我们要注意这种技术只能用于精确匹配的查询（散列值对于类似&lt;或&gt;=等范围搜索操作符 是没有用处的）。我们可以使用MD5()函数生成散列值，也可以使用SHA1()或CRC32()，或者使用自己的应用程序逻辑来计算散列值。请记住数值型散列值可以很高效率地存储。同样，如果散列算法生成的字符串带有尾部空格，就不要把它们存储在CHAR或VARCHAR列中，它们会受到尾部空格去除的影响。<br>合成的散列索引对于那些BLOB或TEXT数据列特别有用。用散列标识符值查找的速度比搜索BLOB列本身的速度快很多。</li><li>在不必要的时候避免检索大型的BLOB或TEXT值。例如，SELECT *查询就不是很好的想法，除非你能够确定作为约束条件的WHERE子句只会找到所需要的数据行。否则，你可能毫无目的地在网络上传输大量的值。这也是 BLOB或TEXT标识符信息存储在合成的索引列中对我们有所帮助的例子。你可以搜索索引列，决定那些需要的数据行，然后从合格的数据行中检索BLOB或 TEXT值。</li><li>把BLOB或TEXT列分离到单独的表中。在某些环境中，如果把这些数据列移动到第二张数据表中，可以让你把原数据表中 的数据列转换为固定长度的数据行格式，那么它就是有意义的。这会减少主表中的碎片，使你得到固定长度数据行的性能优势。它还使你在主数据表上运行 SELECT *查询的时候不会通过网络传输大量的BLOB或TEXT值。</li></ul><h3 id="浮点数与定点数"><a href="#浮点数与定点数" class="headerlink" title="浮点数与定点数"></a>浮点数与定点数</h3><p>为了能够引起大家的重视，在介绍浮点数与定点数以前先让大家看一个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE test (c1 float(10,2),c2 decimal(10,2));</span><br><span class="line">Query OK, 0 rows affected (0.29 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into test values(131072.32,131072.32);</span><br><span class="line">Query OK, 1 row affected (0.07 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from test;</span><br><span class="line">+-----------+-----------+</span><br><span class="line">| c1        | c2        |</span><br><span class="line">+-----------+-----------+</span><br><span class="line">| 131072.31 | 131072.32 |</span><br><span class="line">+-----------+-----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>从上面的例子中我们看到c1列的值由131072.32变成了131072.31，这就是浮点数的不精确性造成的。<br>在mysql中float、double（或real）是浮点数，decimal（或numberic）是定点数。<br>浮点数相对于定点数的优点是在长度一定的情况下，浮点数能够表示更大的数据范围；它的缺点是会引起精度问题。在今后关于浮点数和定点数的应用中，大家要记住以下几点：</p><ul><li>浮点数存在误差问题；</li><li>对货币等对精度敏感的数据，应该用定点数表示或存储；</li><li>编程中，如果用到浮点数，要特别注意误差问题，并尽量避免做浮点数比较；</li><li>要注意浮点数中一些特殊值的处理。</li></ul><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>关于Mysql的数据类型，就总结记录到这里，以后会继续补充，希望能给大家带来帮助！</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;MySQL中定义数据字段的类型对数据库的优化是非常重要的，MySQL支持多种类型，大致可以分为五类：整数类型、浮点数类型、日期类型、字符串类型和其他数据类型。对于Mysql的一些常用数据类型了解程度仅限于一知半解，仅仅能满足满足于平时一些最简单的操作。而Mysql常用数据类型的定义以及规范理解的并不是特别的透彻，对于这些东西的理解并不深刻，经不起推敲和较真。故有此文，帮助自己总结归纳，并加深理解。&lt;/p&gt;
    
    </summary>
    
      <category term="数据库" scheme="https://jsxzswz.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="mysql" scheme="https://jsxzswz.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>MySQL常见的存储引擎</title>
    <link href="https://jsxzswz.github.io/2019/01/04/blog20190104/"/>
    <id>https://jsxzswz.github.io/2019/01/04/blog20190104/</id>
    <published>2019-01-04T09:21:27.003Z</published>
    <updated>2019-01-22T03:10:27.051Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>数据库存储引擎是数据库底层软件组织，数据库管理系统（DBMS）使用数据引擎进行创建、查询、更新和删除数据。不同的存储引擎提供不同的存储机制、索引技巧、锁定水平等功能，使用不同的存储引擎，还可以获得特定的功能。现在许多不同的数据库管理系统都支持多种不同的数据引擎,MySQL的核心就是存储引擎。在MySQL中的存储引擎有很多种，可以通过“SHOW ENGINES”语句来查看。下面重点关注InnoDB、MyISAM、MEMORY这三种。</p><a id="more"></a><h2 id="InnoDB存储引擎"><a href="#InnoDB存储引擎" class="headerlink" title="InnoDB存储引擎"></a>InnoDB存储引擎</h2><ul><li>InnoDB给MySQL的表提供了事务处理、回滚、崩溃修复能力和多版本并发控制的事务安全。在MySQL从3.23.34a开始包含InnnoDB。它是MySQL上第一个提供外键约束的表引擎。而且InnoDB对事务处理的能力，也是其他存储引擎不能比拟的。靠后版本的MySQL的默认存储引擎就是InnoDB。</li><li>InnoDB存储引擎总支持AUTO_INCREMENT。自动增长列的值不能为空，并且值必须唯一。MySQL中规定自增列必须为主键。在插入值的时候，如果自动增长列不输入值，则插入的值为自动增长后的值；如果输入的值为0或空（NULL），则插入的值也是自动增长后的值；如果插入某个确定的值，且该值在前面没有出现过，就可以直接插入。</li><li>InnoDB还支持外键（FOREIGN KEY）。外键所在的表叫做子表，外键所依赖（REFERENCES）的表叫做父表。父表中被字表外键关联的字段必须为主键。当删除、更新父表中的某条信息时，子表也必须有相应的改变，这是数据库的参照完整性规则。</li><li>InnoDB中，创建的表的表结构存储在.frm文件中。数据和索引存储在innodb_data_home_dir和innodb_data_file_path定义的表空间中。</li><li>InnoDB的优势在于提供了良好的事务处理、崩溃修复能力和并发控制。缺点是读写效率较差，占用的数据空间相对较大。</li></ul><h2 id="MyISAM存储引擎"><a href="#MyISAM存储引擎" class="headerlink" title="MyISAM存储引擎"></a>MyISAM存储引擎</h2><ul><li>MyISAM是MySQL中常见的存储引擎，曾经是MySQL的默认存储引擎。MyISAM是基于ISAM引擎发展起来的，增加了许多有用的扩展。</li><li>MyISAM的表存储成3个文件。文件的名字与表名相同。拓展名为frm、MYD、MYI。其实，frm文件存储表的结构；MYD文件存储数据，是MYData的缩写；MYI文件存储索引，是MYIndex的缩写。</li><li>基于MyISAM存储引擎的表支持3种不同的存储格式。包括静态型、动态型和压缩型。其中，静态型是MyISAM的默认存储格式，它的字段是固定长度的；动态型包含变长字段，记录的长度不是固定的；压缩型需要用到myisampack工具，占用的磁盘空间较小。</li><li>MyISAM的优势在于占用空间小，处理速度快。缺点是不支持事务的完整性和并发性。</li></ul><h2 id="MEMORY存储引擎"><a href="#MEMORY存储引擎" class="headerlink" title="MEMORY存储引擎"></a>MEMORY存储引擎</h2><ul><li>MEMORY是MySQL中一类特殊的存储引擎。它使用存储在内存中的内容来创建表，而且数据全部放在内存中。这些特性与前面的两个很不同。</li><li>每个基于MEMORY存储引擎的表实际对应一个磁盘文件。该文件的文件名与表名相同，类型为frm类型。该文件中只存储表的结构。而其数据文件，都是存储在内存中，这样有利于数据的快速处理，提高整个表的效率。值得注意的是，服务器需要有足够的内存来维持MEMORY存储引擎的表的使用。如果不需要了，可以释放内存，甚至删除不需要的表。</li><li>MEMORY默认使用哈希索引。速度比使用B型树索引快。当然如果你想用B型树索引，可以在创建索引时指定。</li><li>注意，MEMORY用到的很少，因为它是把数据存到内存中，如果内存出现异常就会影响数据。如果重启或者关机，所有数据都会消失。因此，基于MEMORY的表的生命周期很短，一般是一次性的。</li></ul><h2 id="存储引擎的选择"><a href="#存储引擎的选择" class="headerlink" title="存储引擎的选择"></a>存储引擎的选择</h2><p>不同的存储引擎都有各自的特点，以适应不同的需求，如下表所示：</p><table><thead><tr><th style="text-align:center">特性</th><th style="text-align:center">InnoDB</th><th style="text-align:center">MyISAM</th><th style="text-align:center">MEMORY</th></tr></thead><tbody><tr><td style="text-align:center">存储限制</td><td style="text-align:center">支持</td><td style="text-align:center">无</td><td style="text-align:center">无</td></tr><tr><td style="text-align:center">事物安全</td><td style="text-align:center">64TB</td><td style="text-align:center">有</td><td style="text-align:center">有</td></tr><tr><td style="text-align:center">空间使用</td><td style="text-align:center">高</td><td style="text-align:center">低</td><td style="text-align:center">低</td></tr><tr><td style="text-align:center">内存使用</td><td style="text-align:center">高</td><td style="text-align:center">低</td><td style="text-align:center">高</td></tr><tr><td style="text-align:center">插入速度</td><td style="text-align:center">低</td><td style="text-align:center">高</td><td style="text-align:center">高</td></tr><tr><td style="text-align:center">外键支持</td><td style="text-align:center">支持</td><td style="text-align:center">无</td><td style="text-align:center">无</td></tr></tbody></table><ul><li>InnoDB：支持事务处理，支持外键，支持崩溃修复能力和并发控制。如果需要对事务的完整性要求比较高（比如银行），要求实现并发控制（比如售票），那选择InnoDB有很大的优势。如果需要频繁的更新、删除操作的数据库，也可以选择InnoDB，因为支持事务的提交（commit）和回滚（rollback）。</li><li>MyISAM：插入数据快，空间和内存使用比较低。如果表主要是用于插入新记录和读出记录，那么选择MyISAM能实现处理高效率。如果应用的完整性、并发性要求比 较低，也可以使用。</li><li>MEMORY：所有的数据都在内存中，数据的处理速度快，但是安全性不高。如果需要很快的读写速度，对数据的安全性要求较低，可以选择MEMOEY。它对表的大小有要求，不能建立太大的表。所以，这类数据库只使用在相对较小的数据库表。</li><li>注意，同一个数据库也可以使用多种存储引擎的表。如果一个表要求比较高的事务处理，可以选择InnoDB。这个数据库中可以将查询要求比较高的表选择MyISAM存储。如果该数据库需要一个用于查询的临时表，可以选择MEMORY存储引擎。</li></ul><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>使用哪一种引擎需要灵活选择，一个数据库中多个表可以使用不同引擎以满足各种性能和实际需求，使用合适的存储引擎，将会提高整个数据库的性能。MySQL常见的存储引擎就介绍到这里了！</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;数据库存储引擎是数据库底层软件组织，数据库管理系统（DBMS）使用数据引擎进行创建、查询、更新和删除数据。不同的存储引擎提供不同的存储机制、索引技巧、锁定水平等功能，使用不同的存储引擎，还可以获得特定的功能。现在许多不同的数据库管理系统都支持多种不同的数据引擎,MySQL的核心就是存储引擎。在MySQL中的存储引擎有很多种，可以通过“SHOW ENGINES”语句来查看。下面重点关注InnoDB、MyISAM、MEMORY这三种。&lt;/p&gt;
    
    </summary>
    
      <category term="数据库" scheme="https://jsxzswz.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="mysql" scheme="https://jsxzswz.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Sublime Text3安装教程</title>
    <link href="https://jsxzswz.github.io/2019/01/04/blog20181214/"/>
    <id>https://jsxzswz.github.io/2019/01/04/blog20181214/</id>
    <published>2019-01-04T09:21:27.002Z</published>
    <updated>2019-01-22T03:09:29.427Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Sublime Text是2008年开发出来的一个代码编辑器，界面友好，功能非凡， 默认支持html, xml, javascript, ruby, python, php… 等等主流语言的语法高亮，它支持众多插件扩展，用它来写代码，绝对是一种享受。但是ST再强大也只是一个文本编辑器，不是真正意义上的IDE,像打断点调试这样的ST是做不到的。</p><a id="more"></a><h2 id="Sublime-Text3安装"><a href="#Sublime-Text3安装" class="headerlink" title="Sublime Text3安装"></a>Sublime Text3安装</h2><p>Windows系统下访问<a href="https://www.sublimetext.com" target="_blank" rel="noopener">sublimetext官网</a>，点击DOWNLOAD FOR WINDOWS按钮下载最新版，这里下载的是3176版本，如下图所示：</p><p><img src="/images/sublime1.png" alt="Sublime Text3" title="Sublime Text3"></p><p>下载完成后，运行程序开始安装，点击Next,选择合适的安装目录后Next，点击Install开始安装。安装完成后，运行Sublime后点击Help选项里的Enter License选项，将激活码填入即可，如下图所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">----- BEGIN LICENSE -----</span><br><span class="line">sgbteam</span><br><span class="line">Single User License</span><br><span class="line">EA7E-1153259</span><br><span class="line">8891CBB9 F1513E4F 1A3405C1 A865D53F</span><br><span class="line">115F202E 7B91AB2D 0D2A40ED 352B269B</span><br><span class="line">76E84F0B CD69BFC7 59F2DFEF E267328F</span><br><span class="line">215652A3 E88F9D8F 4C38E3BA 5B2DAAE4</span><br><span class="line">969624E7 DC9CD4D5 717FB40C 1B9738CF</span><br><span class="line">20B3C4F1 E917B5B3 87C38D9C ACCE7DD8</span><br><span class="line">5F7EF854 86B9743C FADC04AA FB0DA5C0</span><br><span class="line">F913BE58 42FEA319 F954EFDD AE881E0B</span><br><span class="line">------ END LICENSE ------</span><br></pre></td></tr></table></figure></p><p><img src="/images/sublime2.png" alt="Sublime Text3" title="License"></p><h2 id="安装常用插件"><a href="#安装常用插件" class="headerlink" title="安装常用插件"></a>安装常用插件</h2><h3 id="直接安装"><a href="#直接安装" class="headerlink" title="直接安装"></a>直接安装</h3><p>安装Sublime text3插件很方便，可以直接下载安装包解压缩到Packages目录（preferences-&gt;Browse Packages）。</p><h3 id="使用Package-Control组件安装（以LESS为例）"><a href="#使用Package-Control组件安装（以LESS为例）" class="headerlink" title="使用Package Control组件安装（以LESS为例）"></a>使用Package Control组件安装（以LESS为例）</h3><ul><li>按Ctrl+ `(此符号为tab按键上面的按键) 调出console（注：避免热键冲突）</li><li><p>粘贴以下代码到命令行并回车：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import urllib.request,os; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path();</span><br><span class="line">urllib.request.install_opener ( urllib.request.build_opener( urllib.request.ProxyHandler()) );</span><br><span class="line">open(os.path.join(ipp, pf), &apos;wb&apos;).write(urllib.request.urlopen ( &apos;http://sublime.wbond.net/&apos; + pf.replace(&apos; &apos;,&apos;%20&apos;)).read())</span><br></pre></td></tr></table></figure></li><li><p>重启Sublime Text 3。</p></li><li>如果在Perferences-&gt;package settings中看到package control这一项，则安装成功。</li></ul><p>Package Control安装插件的方法:</p><ul><li>按下Ctrl+Shift+P调出命令面板</li><li>输入install 调出 Install Package 选项并回车，如下图所示：</li></ul><p><img src="/images/sublime3.png" alt="Sublime Text3" title="Install Package"></p><p>然后在列表中选择要安装的插件,如图所示：</p><p><img src="/images/sublime4.png" alt="Sublime Text3" title="Install LESS"></p><p>等待一会即可完成安装！</p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>好了，到这里Sublime Text3就已经安装完成了，大家赶紧去尝试，享受编码的乐趣吧！</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Sublime Text是2008年开发出来的一个代码编辑器，界面友好，功能非凡， 默认支持html, xml, javascript, ruby, python, php… 等等主流语言的语法高亮，它支持众多插件扩展，用它来写代码，绝对是一种享受。但是ST再强大也只是一个文本编辑器，不是真正意义上的IDE,像打断点调试这样的ST是做不到的。&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="https://jsxzswz.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>IDEA安装教程</title>
    <link href="https://jsxzswz.github.io/2019/01/04/blog20181211/"/>
    <id>https://jsxzswz.github.io/2019/01/04/blog20181211/</id>
    <published>2019-01-04T09:21:26.999Z</published>
    <updated>2019-01-22T03:09:22.810Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>说起Java的IDE,大家琅琅上口的不外乎Jbuilder,Eclipse,NetBeans这三个,如果你只是想找个IDE来学习Java，或者你需要漂亮的图标，再或者你的电脑配置并不高，那么Eclipse是个不错的选择。如果你想找个能提升开发效率的IDE，想找一个更快更方便的工具，推荐你用IntelliJ IDEA。</p><a id="more"></a><h2 id="IntelliJ-IDEA优势"><a href="#IntelliJ-IDEA优势" class="headerlink" title="IntelliJ IDEA优势"></a>IntelliJ IDEA优势</h2><ul><li>更好的调试。IntelliJ IDEA在调试上的表现，可以说比Eclipse强大太多。在调试过程中哦，当我们需要求一些表达式的值时，如果使用Eclipse就需要选定整个表达式，然后用Crtl+Shift+I看到这个表达式的值。但是，在IntelliJ IDEA中，只需要移动光标到表达式下然后用Alt+F8就可以实现。IntelliJ IDEA能够很好地理解你可能需要的表达式，还会给出的建议参数变量。你可以直接编辑并能立刻得到这个表达式的值，不会像在Eclipse中一个Debug界面跳来跳去。</li><li>更高的开发效率。IntelliJ IDEA在代码自动生成方面表现比Eclipse更为智能，比如IntelliJ IDEA能生成某个类的测试类，还能正确地放到test的相应目录下。在对ZenCoding的支持上，写html非常方便，tab快速补全，和原生集成一样。IntelliJ IDEA在开发效率上更明显的一点是，对JS、CSS以及插件的支持更好。</li><li>更智能的重构。这一点其实也属于开发效率，但是IntelliJ IDEA得重构功能还是想让我单独强调一下。所有的现代IDE都提供重构功能，这一点上，IntelliJ IDEA能读懂你需要什么，并且会针对不同的情况给你提供最合适的解决方案。</li><li>目录分层少而清。IntelliJ IDEA的目录分层很少，但是却很清晰，IDE配置的东西都能在Settings利找到，工程的配置也能在Project Settings里找到。</li></ul><h2 id="IntelliJ-IDEA安装"><a href="#IntelliJ-IDEA安装" class="headerlink" title="IntelliJ IDEA安装"></a>IntelliJ IDEA安装</h2><p>访问地址<a href="https://www.jetbrains.com/idea/download/previous.html" target="_blank" rel="noopener">IDEA历史版本</a>，选择合适的版本，这里楼主选择的是15.0.6终极版。如图：</p><p><img src="/images/idea1.png" alt="IntelliJ IDEA 15.0.6" title="IDEA 15.0.6"></p><p>点击下载,下载完成后，运行程序开始安装，点击Next，选择合适的安装目录后Next，勾选Create Desktop shortcut创建桌面快捷方式Next后点击Install开始安装。几分钟后安装完成关闭安装页面。打开桌面上的IntelliJ IDEA 15.0.6，进入页面后选择合适的主题，点击Register激活产品！</p><p><img src="/images/idea2.png" alt="IntelliJ IDEA 15.0.6" title="Register"></p><p>访问地址<a href="http://idea.lanyus.com" target="_blank" rel="noopener">获取激活码</a>，点击获得注册码，将注册码复制粘贴到框里即可!</p><p><img src="/images/idea3.png" alt="IntelliJ IDEA 15.0.6" title="Code"></p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>好了，到这里IDEA就已经安装完成了，大家赶紧去尝试，享受编码的乐趣吧！</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;说起Java的IDE,大家琅琅上口的不外乎Jbuilder,Eclipse,NetBeans这三个,如果你只是想找个IDE来学习Java，或者你需要漂亮的图标，再或者你的电脑配置并不高，那么Eclipse是个不错的选择。如果你想找个能提升开发效率的IDE，想找一个更快更方便的工具，推荐你用IntelliJ IDEA。&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="https://jsxzswz.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>Java8十大新特性整理</title>
    <link href="https://jsxzswz.github.io/2019/01/04/blog20181210/"/>
    <id>https://jsxzswz.github.io/2019/01/04/blog20181210/</id>
    <published>2019-01-04T09:21:26.997Z</published>
    <updated>2019-01-29T08:07:37.164Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Java8已经发布很久了，毫无疑问，这是继java5之后一次重大的版本升级，这个版本包含语言、编译器、库、工具和JVM等方面的十多个新特性。有人认为，虽然这些新特性领Java开发人员十分期待，但同时也需要花不少精力去学习。因此，本文综合了一些资料，整理成一份关于Java 8新特性的参考教材，希望你有所收获。<br>本文中所用的实例请点击：<a href="https://github.com/jsxzswz/Java8Demo" target="_blank" rel="noopener">Java8新特性实例</a></p><a id="more"></a><h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>Lambda表达式的语法格式如下：<br><code>(parameters)-&gt;expression</code> 或 <code>(parameters)-&gt;{statements;}</code></p><p>以下是Lambda表达式的重要特征：</p><ul><li>可选类型声明：不需要声明参数类型，编译器可以统一识别参数值；</li><li>可选参数圆括号：一个参数无需定义圆括号，但多个参数需要定义圆括号；</li><li>可选的大括号：如果主体包含了一个语句，就不需要使用大括号；</li><li>可选的返回关键字：如果主体只有一个返回值则编译器会自动返主体回值，大括号需要指定表达式返回一个数值。</li></ul><p>使用Lambda表达式需要注意以下两点：</p><ul><li>使用Lambda表达式主要用来定义执行行内执行的方法类型接口，例如，一个简单方法接口。在上面例子中，我们使用各种类型的Lambda表达式来定义MathOperation接口的方法，然后我们定义了sayMessage的执行。</li><li>Lambda表达式免去了使用匿名方法的麻烦，并且给予Java简单但强大的函数化的编程能力。</li></ul><h3 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h3><p>注意点：</p><ul><li>Lambda表达式只能引用标记了 final 的外层局部变量，这就是说不能在lambda 内部修改定义在域外的局部变量，否则会编译错误。</li><li>Lambda表达式的局部变量可以不用声明为 final，但是必须不可被后面的代码修改（即隐性的具有final 的语义）</li><li>Lambda表达式当中不允许声明一个与局部变量同名的参数或者局部变量。</li></ul><h3 id="Lambda表达式实例"><a href="#Lambda表达式实例" class="headerlink" title="Lambda表达式实例"></a>Lambda表达式实例</h3><p>以下是Lambda的使用实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @Package: com.swz</span><br><span class="line"> * @Description: Lambda测试</span><br><span class="line"> * @author: swz</span><br><span class="line"> * @date: 2018/11/29 10:30</span><br><span class="line"> */</span><br><span class="line">public class LambdaTest &#123;</span><br><span class="line"></span><br><span class="line">    final static String salutation = &quot;Hello! &quot;;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        LambdaTest LambdaTest = new LambdaTest();</span><br><span class="line">        // 类型声明</span><br><span class="line">        MathOperation addition = (int a, int b) -&gt; a + b;</span><br><span class="line">        // 不用类型声明</span><br><span class="line">        MathOperation subtraction = (a, b) -&gt; a - b;</span><br><span class="line">        // 大括号中的返回值</span><br><span class="line">        MathOperation multiplication = (int a, int b) -&gt; &#123;</span><br><span class="line">            return a * b;</span><br><span class="line">        &#125;;</span><br><span class="line">        // 没有大括号及返回语句</span><br><span class="line">        MathOperation division = (int a, int b) -&gt; a / b;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;10 + 5 = &quot; + LambdaTest.operate(10, 5, addition));</span><br><span class="line">        System.out.println(&quot;10 - 5 = &quot; + LambdaTest.operate(10, 5, subtraction));</span><br><span class="line">        System.out.println(&quot;10 x 5 = &quot; + LambdaTest.operate(10, 5, multiplication));</span><br><span class="line">        System.out.println(&quot;10 / 5 = &quot; + LambdaTest.operate(10, 5, division));</span><br><span class="line"></span><br><span class="line">        // 不用括号</span><br><span class="line">        GreetingService greetService1 = message -&gt; System.out.println(&quot;Hello &quot; + message);</span><br><span class="line">        // 用括号</span><br><span class="line">        GreetingService greetService2 = (message) -&gt; System.out.println(salutation + message);</span><br><span class="line"></span><br><span class="line">        greetService1.sayMessage(&quot;Runoob&quot;);</span><br><span class="line">        greetService2.sayMessage(&quot;Google&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    interface MathOperation &#123;</span><br><span class="line">        int operatation(int a, int b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    interface GreetingService &#123;</span><br><span class="line">        void sayMessage(String message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private int operate(int a, int b, MathOperation mathOperation) &#123;</span><br><span class="line">        return mathOperation.operatation(a, b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Java8方法引用"><a href="#Java8方法引用" class="headerlink" title="Java8方法引用"></a>Java8方法引用</h2><p>方法引用通过方法的名字来指向一个方法。<br>方法引用可以使语言的构造更紧凑简洁，减少冗余代码。<br>方法引用使用一对冒号 :: 。</p><h3 id="方法引用实例"><a href="#方法引用实例" class="headerlink" title="方法引用实例"></a>方法引用实例</h3><p>以下是方法引用的使用实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @Package: com.swz</span><br><span class="line"> * @Description: 方法引用</span><br><span class="line"> * @author: swz</span><br><span class="line"> * @date: 2018/11/29 13:45</span><br><span class="line"> */</span><br><span class="line">public class MethodQuoteTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List names = new ArrayList&lt;&gt;();</span><br><span class="line">        names.add(&quot;Google&quot;);</span><br><span class="line">        names.add(&quot;SWZ&quot;);</span><br><span class="line">        names.add(&quot;taobao&quot;);</span><br><span class="line">        names.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Java8函数式接口"><a href="#Java8函数式接口" class="headerlink" title="Java8函数式接口"></a>Java8函数式接口</h2><p>函数式接口(FunctionalInterface)是一个有且仅有一个抽象方法，但可以有多个非抽象方法的接口。<br>函数式接口可以被隐式转换为Lambda表达式。<br>函数式接口可以现有的函数友好地支持Lambda。</p><h3 id="函数式接口实例"><a href="#函数式接口实例" class="headerlink" title="函数式接口实例"></a>函数式接口实例</h3><p>Predicate <t> 接口是一个函数式接口，它接受一个输入参数 T，返回一个布尔值结果。<br>该接口包含多种默认方法来将Predicate组合成其他复杂的逻辑（比如：与，或，非）。<br>该接口用于测试对象是 true 或 false。</t></p><p>以下是函数式接口的实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @Package: com.swz</span><br><span class="line"> * @Description: 函数式接口</span><br><span class="line"> * @author: swz</span><br><span class="line"> * @date: 2018/11/29 14:30</span><br><span class="line"> */</span><br><span class="line">public class FunctionalInterfaceTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9);</span><br><span class="line">        Predicate&lt;Integer&gt; predicate = n -&gt; n % 2 == 0;</span><br><span class="line">        // 传递参数 n</span><br><span class="line">        System.out.print(&quot;输出所有偶数: &quot;);</span><br><span class="line">        eval(list, predicate);</span><br><span class="line">        Predicate&lt;Integer&gt; predicate2 = n -&gt; n &gt; 3;</span><br><span class="line">        System.out.print(&quot;\n输出大于3的所有数字: &quot;);</span><br><span class="line">        eval(list, predicate2 );</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void eval(List&lt;Integer&gt; list, Predicate&lt;Integer&gt; predicate) &#123;</span><br><span class="line">        for (Integer i : list) &#123;</span><br><span class="line">            if (predicate.test(i)) &#123;</span><br><span class="line">                System.out.print(i + &quot; &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Java8默认方法"><a href="#Java8默认方法" class="headerlink" title="Java8默认方法"></a>Java8默认方法</h2><ul><li>简单说，默认方法就是接口可以有实现方法，而且不需要实现类去实现其方法;</li><li>我们只需在方法名前面加个default关键字即可实现默认方法。</li><li>默认方法是为了解决接口的修改与现有的实现不兼容的问题。</li><li>另一个特性是接口可以声明（并且可以提供实现）静态方法</li></ul><h3 id="默认方法实例"><a href="#默认方法实例" class="headerlink" title="默认方法实例"></a>默认方法实例</h3><p>以下是默认方法的使用实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @Package: com.swz</span><br><span class="line"> * @Description: 默认方法</span><br><span class="line"> * @author: swz</span><br><span class="line"> * @date: 2018/11/29 15:01</span><br><span class="line"> */</span><br><span class="line">public class DefaultMethodTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Vehicle vehicle = new Car();</span><br><span class="line">        vehicle.print();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     interface Vehicle &#123;</span><br><span class="line">        default void print() &#123;</span><br><span class="line">            System.out.println(&quot;我是一辆车!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 静态方法</span><br><span class="line">        static void blowHorn() &#123;</span><br><span class="line">            System.out.println(&quot;按喇叭!!!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     interface FourWheeler &#123;</span><br><span class="line">        default void print() &#123;</span><br><span class="line">            System.out.println(&quot;我是一辆四轮车!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Car implements Vehicle, FourWheeler &#123;</span><br><span class="line"></span><br><span class="line">        //@Override</span><br><span class="line">        //public void print() &#123;</span><br><span class="line">        //    System.out.println(&quot;我是一辆四轮汽车!&quot;);</span><br><span class="line">        //&#125;</span><br><span class="line">        public void print() &#123;</span><br><span class="line">            Vehicle.super.print();</span><br><span class="line">            FourWheeler.super.print();</span><br><span class="line">            Vehicle.blowHorn();</span><br><span class="line">            System.out.println(&quot;我是一辆汽车!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Java8-流Stream"><a href="#Java8-流Stream" class="headerlink" title="Java8 流Stream"></a>Java8 流Stream</h2><p>Stream使用一种类似用SQL语句从数据库查询数据的直观方式来提供一种对Java集合运算和表达的高阶抽象;<br>Stream API可以极大提高Java程序员的生产力，让程序员写出高效率、干净、简洁的代码;<br>这种风格将要处理的元素集合看作一种流，流在管道中传输，并且可以在管道的节点上进行处理，比如筛选，排序，聚合等;<br>元素流在管道中经过中间操作（intermediate operation）的处理，最后由最终操作(terminal operation)得到前面处理的结果。</p><h3 id="什么是Stream"><a href="#什么是Stream" class="headerlink" title="什么是Stream"></a>什么是Stream</h3><p>Stream（流）是一个来自数据源的元素队列并支持聚合操作;</p><ul><li>元素：是特定类型的对象，形成一个队列。Java中的Stream并不会存储元素，而是按需计算;</li><li>数据源 ：流的来源。可以是集合，数组，I/O channel，产生器generator等;</li><li>聚合操作： 类似SQL语句一样的操作，比如filter, map, reduce, find,match, sorted等。</li></ul><h3 id="Stream流特征"><a href="#Stream流特征" class="headerlink" title="Stream流特征"></a>Stream流特征</h3><ul><li>Pipelining:：中间操作都会返回流对象本身。这样多个操作可以串联成一个管道，如同流式风格（fluent style）。<br>这样做可以对操作进行优化，比如延迟执行(laziness)和短路( short-circuiting)。</li><li>内部迭代：以前对集合遍历都是通过Iterator或者For-Each的方式,显式的在集合外部进行迭代，这叫做外部迭代。<br>Stream提供了内部迭代的方式，通过访问者模式(Visitor)实现。</li></ul><h3 id="Stream流实例"><a href="#Stream流实例" class="headerlink" title="Stream流实例"></a>Stream流实例</h3><p>以下是Stream流的使用实例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @Package: com.swz</span><br><span class="line"> * @Description: 流Stream</span><br><span class="line"> * @author: swz</span><br><span class="line"> * @date: 2018/11/29 15:17</span><br><span class="line"> */</span><br><span class="line">public class StreamTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        // stream() −为集合创建串行流。</span><br><span class="line">        // parallelStream() − 为集合创建并行流。</span><br><span class="line">        List&lt;String&gt; strings = Arrays.asList(&quot;abc&quot;, &quot;&quot;, &quot;bc&quot;, &quot;efg&quot;, &quot;&quot;, &quot;jkl&quot;);</span><br><span class="line">        List&lt;String&gt; filtered = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.toList());</span><br><span class="line">        System.out.println(filtered);</span><br><span class="line"></span><br><span class="line">        // Stream 提供了新的方法 &apos;forEach&apos; 来迭代流中的每个数据。以下代码片段使用forEach 输出了10个随机数</span><br><span class="line">        // limit 方法用于获取指定数量的流。以下代码片段使用 limit 方法打印出 10 条数据</span><br><span class="line">        // sorted 方法用于对流进行排序。以下代码片段使用 sorted 方法对输出的 10 个随机数进行排序</span><br><span class="line">        Random random = new Random();</span><br><span class="line">        random.ints().limit(10).sorted().forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">        // map 方法用于映射每个元素到对应的结果，以下代码片段使用 map 输出了元素对应的平方数：</span><br><span class="line">        List&lt;Integer&gt; numbers = Arrays.asList(3, 2, 3, 4, 3, 5);</span><br><span class="line">        List&lt;Integer&gt; squaresList  = numbers.stream().map(i -&gt;i*i).distinct().collect(Collectors.toList());</span><br><span class="line">        System.out.println(squaresList);</span><br><span class="line"></span><br><span class="line">        // filter 方法用于通过设置条件过滤出元素。以下代码片段使用filter 方法过滤出空字符串：</span><br><span class="line">        List&lt;String&gt; strings2 = Arrays.asList(&quot;abc&quot;, &quot;&quot;, &quot;bc&quot;, &quot;efg&quot;, &quot;abcd&quot;,&quot;&quot;, &quot;jkl&quot;);</span><br><span class="line">        // 获取空字符串的数量</span><br><span class="line">        int count = (int) strings2.stream().filter(string -&gt; string.isEmpty()).count();</span><br><span class="line">        System.out.println(count);</span><br><span class="line"></span><br><span class="line">        // Collectors 类实现了很多归约操作，例如将流转换成集合和聚合元素。Collectors可用于返回列表或字符串：</span><br><span class="line">        List&lt;String&gt; strings3 = Arrays.asList(&quot;abc&quot;, &quot;&quot;, &quot;bc&quot;, &quot;efg&quot;, &quot;abcd&quot;, &quot;&quot;, &quot;jkl&quot;);</span><br><span class="line">        List&lt;String&gt; filtered3 = strings3.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.toList());</span><br><span class="line">        System.out.println(&quot;筛选列表: &quot; + filtered3);</span><br><span class="line">        String mergedString = strings3.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.joining(&quot;, &quot;));</span><br><span class="line">        System.out.println(&quot;合并字符串: &quot; + mergedString);</span><br><span class="line">        // 一些产生统计结果的收集器也非常有用。它们主要用于int、double、long等基本类型上，它们可以用来产生类似如下的统计结果</span><br><span class="line">        List&lt;Integer&gt; numbers2 = Arrays.asList(3, 2, 2, 3, 7, 3, 5);</span><br><span class="line">        IntSummaryStatistics stats = numbers2.stream().mapToInt((x) -&gt; x).summaryStatistics();</span><br><span class="line">        System.out.println(&quot;列表中最大的数 : &quot; + stats.getMax());</span><br><span class="line">        System.out.println(&quot;列表中最小的数 : &quot; + stats.getMin());</span><br><span class="line">        System.out.println(&quot;所有数之和 : &quot; + stats.getSum());</span><br><span class="line">        System.out.println(&quot;平均数 : &quot; + stats.getAverage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @Package: com.swz</span><br><span class="line"> * @Description: 流Stream</span><br><span class="line"> * @author: swz</span><br><span class="line"> * @date: 2018/11/29 16:02</span><br><span class="line"> */</span><br><span class="line">public class Stream2Test &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">        System.out.println(&quot;使用 Java 7: &quot;);</span><br><span class="line">        // 计算空字符串</span><br><span class="line">        List&lt;String&gt; strings = Arrays.asList(&quot;abc&quot;, &quot;&quot;, &quot;bc&quot;, &quot;efg&quot;, &quot;abcd&quot;, &quot;&quot;, &quot;jkl&quot;);</span><br><span class="line">        System.out.println(&quot;列表: &quot; + strings);</span><br><span class="line">        long count = getCountEmptyStringUsingJava7(strings);</span><br><span class="line">        System.out.println(&quot;空字符数量为: &quot; + count);</span><br><span class="line">        count = getCountLength3UsingJava7(strings);</span><br><span class="line">        System.out.println(&quot;字符串长度为 3 的数量为: &quot; + count);</span><br><span class="line">        // 删除空字符串</span><br><span class="line">        List&lt;String&gt; filtered = deleteEmptyStringsUsingJava7(strings);</span><br><span class="line">        System.out.println(&quot;筛选后的列表: &quot; + filtered);</span><br><span class="line">        // 删除空字符串，并使用逗号把它们合并起来</span><br><span class="line">        String mergedString = getMergedStringUsingJava7(strings, &quot;, &quot;);</span><br><span class="line">        System.out.println(&quot;合并字符串: &quot; + mergedString);</span><br><span class="line">        List&lt;Integer&gt; numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5);</span><br><span class="line">        // 获取列表元素平方数</span><br><span class="line">        List&lt;Integer&gt; squaresList = getSquares(numbers);</span><br><span class="line">        System.out.println(&quot;平方数列表: &quot; + squaresList);</span><br><span class="line">        List&lt;Integer&gt; integers = Arrays.asList(1, 2, 13, 4, 15, 6, 17, 8, 19);</span><br><span class="line">        System.out.println(&quot;列表: &quot; + integers);</span><br><span class="line">        System.out.println(&quot;列表中最大的数 : &quot; + getMax(integers));</span><br><span class="line">        System.out.println(&quot;列表中最小的数 : &quot; + getMin(integers));</span><br><span class="line">        System.out.println(&quot;所有数之和 : &quot; + getSum(integers));</span><br><span class="line">        System.out.println(&quot;平均数 : &quot; + getAverage(integers));</span><br><span class="line">        System.out.println(&quot;随机数: &quot;);</span><br><span class="line">        // 输出10个随机数</span><br><span class="line">        Random random = new Random();</span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            System.out.println(random.nextInt());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;使用 Java 8: &quot;);</span><br><span class="line">        System.out.println(&quot;列表: &quot; + strings);</span><br><span class="line">        count = strings.stream().filter(string -&gt; string.isEmpty()).count();</span><br><span class="line">        System.out.println(&quot;空字符串数量为: &quot; + count);</span><br><span class="line">        count = strings.stream().filter(string -&gt; string.length() == 3).count();</span><br><span class="line">        System.out.println(&quot;字符串长度为 3 的数量为: &quot; + count);</span><br><span class="line">        filtered = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.toList());</span><br><span class="line">        System.out.println(&quot;筛选后的列表: &quot; + filtered);</span><br><span class="line">        mergedString = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.joining(&quot;, &quot;));</span><br><span class="line">        System.out.println(&quot;合并字符串: &quot; + mergedString);</span><br><span class="line">        squaresList = numbers.stream().map(i -&gt; i * i).distinct().collect(Collectors.toList());</span><br><span class="line">        System.out.println(&quot;Squares List: &quot; + squaresList);</span><br><span class="line">        System.out.println(&quot;列表: &quot; + integers);</span><br><span class="line">        IntSummaryStatistics stats = integers.stream().mapToInt((x) -&gt; x).summaryStatistics();</span><br><span class="line">        System.out.println(&quot;列表中最大的数 : &quot; + stats.getMax());</span><br><span class="line">        System.out.println(&quot;列表中最小的数 : &quot; + stats.getMin());</span><br><span class="line">        System.out.println(&quot;所有数之和 : &quot; + stats.getSum());</span><br><span class="line">        System.out.println(&quot;平均数 : &quot; + stats.getAverage());</span><br><span class="line">        System.out.println(&quot;随机数: &quot;);</span><br><span class="line">        random.ints().limit(10).sorted().forEach(System.out::println);</span><br><span class="line">        // 并行处理</span><br><span class="line">        count = strings.parallelStream().filter(string -&gt; string.isEmpty()).count();</span><br><span class="line">        System.out.println(&quot;空字符串的数量为: &quot; + count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static int getCountEmptyStringUsingJava7(List&lt;String&gt; strings) &#123;</span><br><span class="line">        int count = 0;</span><br><span class="line">        for (String string : strings) &#123;</span><br><span class="line">            if (string.isEmpty()) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static int getCountLength3UsingJava7(List&lt;String&gt; strings) &#123;</span><br><span class="line">        int count = 0;</span><br><span class="line">        for (String string : strings) &#123;</span><br><span class="line">            if (string.length() == 3) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static List&lt;String&gt; deleteEmptyStringsUsingJava7(List&lt;String&gt; strings) &#123;</span><br><span class="line">        List&lt;String&gt; filteredList = new ArrayList&lt;String&gt;();</span><br><span class="line">        for (String string : strings) &#123;</span><br><span class="line">            if (!string.isEmpty()) &#123;</span><br><span class="line">                filteredList.add(string);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return filteredList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static String getMergedStringUsingJava7(List&lt;String&gt; strings, String separator) &#123;</span><br><span class="line">        StringBuilder stringBuilder = new StringBuilder();</span><br><span class="line">        for (String string : strings) &#123;</span><br><span class="line">            if (!string.isEmpty()) &#123;</span><br><span class="line">                stringBuilder.append(string);</span><br><span class="line">                stringBuilder.append(separator);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        String mergedString = stringBuilder.toString();</span><br><span class="line">        return mergedString.substring(0, mergedString.length() - 2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static List&lt;Integer&gt; getSquares(List&lt;Integer&gt; numbers) &#123;</span><br><span class="line">        List&lt;Integer&gt; squaresList = new ArrayList&lt;Integer&gt;();</span><br><span class="line">        for (Integer number : numbers) &#123;</span><br><span class="line">            Integer square = new Integer(number.intValue() * number.intValue());</span><br><span class="line">            if (!squaresList.contains(square)) &#123;</span><br><span class="line">                squaresList.add(square);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return squaresList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static int getMax(List&lt;Integer&gt; numbers) &#123;</span><br><span class="line">        int max = numbers.get(0);</span><br><span class="line">        for (int i = 1; i &lt; numbers.size(); i++) &#123;</span><br><span class="line">            Integer number = numbers.get(i);</span><br><span class="line">            if (number.intValue() &gt; max) &#123;</span><br><span class="line">                max = number.intValue();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static int getMin(List&lt;Integer&gt; numbers) &#123;</span><br><span class="line">        int min = numbers.get(0);</span><br><span class="line">        for (int i = 1; i &lt; numbers.size(); i++) &#123;</span><br><span class="line">            Integer number = numbers.get(i);</span><br><span class="line">            if (number.intValue() &lt; min) &#123;</span><br><span class="line">                min = number.intValue();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return min;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static int getSum(List numbers) &#123;</span><br><span class="line">        int sum = (int) (numbers.get(0));</span><br><span class="line">        for (int i = 1; i &lt; numbers.size(); i++) &#123;</span><br><span class="line">            sum += (int) numbers.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static int getAverage(List&lt;Integer&gt; numbers) &#123;</span><br><span class="line">        return getSum(numbers) / numbers.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Java-8-Optional-类"><a href="#Java-8-Optional-类" class="headerlink" title="Java 8 Optional 类"></a>Java 8 Optional 类</h2><p>Optional类是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象；<br>Optional十个容器：它可以保存类型为T的值，或仅仅保存null；<br>Optional类的引入很好的解决空指针异常。</p><h3 id="类声明"><a href="#类声明" class="headerlink" title="类声明"></a>类声明</h3><p>以下是一个 java.util.Optional<t> 类的声明：<br><code>publicfinalclassOptional&lt;T&gt; extendsObject</code></t></p><h3 id="Optional实例"><a href="#Optional实例" class="headerlink" title="Optional实例"></a>Optional实例</h3><p>以下是Optional的使用实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @Package: com.swz</span><br><span class="line"> * @Description: Optional类</span><br><span class="line"> * @author: swz</span><br><span class="line"> * @date: 2018/11/30 11:25</span><br><span class="line"> */</span><br><span class="line">public class OptionalTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        OptionalTest optionalTest = new OptionalTest();</span><br><span class="line">        Integer value1 = null;</span><br><span class="line">        Integer value2 = new Integer(10);</span><br><span class="line">        // 允许传递为 null 参数</span><br><span class="line">        Optional&lt;Integer&gt; a = Optional.ofNullable(value1);</span><br><span class="line">        // 如果传递的参数是 null，抛出异常 NullPointerException</span><br><span class="line">        Optional&lt;Integer&gt; b = Optional.of(value2);</span><br><span class="line">        System.out.println(optionalTest.sum(a, b));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer sum(Optional&lt;Integer&gt; a, Optional&lt;Integer&gt; b) &#123;</span><br><span class="line">        // 判断值是否存在</span><br><span class="line">        System.out.println(&quot;第一个参数值存在： &quot; + a.isPresent());</span><br><span class="line">        System.out.println(&quot;第二个参数值存在： &quot; + b.isPresent());</span><br><span class="line">        // 如果值存在，返回它，否则返回默认值</span><br><span class="line">        Integer value1 = a.orElse(new Integer(0));</span><br><span class="line">        Integer value2 = b.get();</span><br><span class="line">        return value1 + value2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Java8-Nashorn-JavaScript"><a href="#Java8-Nashorn-JavaScript" class="headerlink" title="Java8 Nashorn JavaScript"></a>Java8 Nashorn JavaScript</h2><ul><li>Nashorn 一个 javascript 引擎。<br>从JDK1.8开始，Nashorn取代Rhino(JDK 1.6, JDK1.7)成为Java的嵌入式JavaScript引擎。Nashorn完全支持ECMAScript 5.1规范以及一些扩展。它使用基于JSR292的新语言特性，其中包含在JDK 7中引入的 invokedynamic，将JavaScript编译成Java字节码。与先前的Rhino实现相比，这带来了2到10倍的性能提升。</li><li>jjs是个基于Nashorn引擎的命令行工具。它接受一些JavaScript源代码为参数，并且执行这些源代码</li><li>使用ScriptEngineManager, JavaScript 代码可以在 Java 中执行</li></ul><h3 id="Nashorn实例"><a href="#Nashorn实例" class="headerlink" title="Nashorn实例"></a>Nashorn实例</h3><p>以下是Nashorn的使用实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @Package: com.swz</span><br><span class="line"> * @Description: Nashorn, javascript 引擎。</span><br><span class="line"> * @author: swz</span><br><span class="line"> * @date: 2018/11/30 14:11</span><br><span class="line"> */</span><br><span class="line">public class NashornTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        ScriptEngineManager scriptEngineManager = new ScriptEngineManager();</span><br><span class="line">        ScriptEngine nashorn = scriptEngineManager.getEngineByName(&quot;nashorn&quot;);</span><br><span class="line">        String name = &quot;Runoob&quot;;</span><br><span class="line">        Integer result = null;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            nashorn.eval(&quot;print(&apos;&quot; + name + &quot;&apos;)&quot;);</span><br><span class="line">            result = (Integer) nashorn.eval(&quot;10 + 2&quot;);</span><br><span class="line">        &#125; catch (ScriptException e) &#123;</span><br><span class="line">            System.out.println(&quot;执行脚本错误: &quot; + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(result.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Java8-日期时间API"><a href="#Java8-日期时间API" class="headerlink" title="Java8 日期时间API"></a>Java8 日期时间API</h2><p>在旧版的Java 中，日期时间API 存在诸多问题:</p><ul><li>非线程安全 − java.util.Date 是非线程安全的，所有的日期类都是可变的，这是Java日期类最大的问题之一;</li><li>设计很差 − Java的日期/时间类的定义并不一致，在java.util和java.sql的包中都有日期类;</li><li>时区处理麻烦 − 日期类并不提供国际化，没有时区支持;</li></ul><p>Java 8 在 java.time 包下提供了很多新的 API:</p><ul><li>Local(本地) − 简化了日期时间的处理，没有时区的问题;</li><li>Zoned(时区) − 通过制定的时区处理日期时间;</li><li>新的java.time包涵盖了所有处理日期，时间，日期/时间，时区，时刻（instants），过程（during）与时钟（clock）的操作.</li></ul><h3 id="日期时间实例"><a href="#日期时间实例" class="headerlink" title="日期时间实例"></a>日期时间实例</h3><p>以下是日期时间的使用实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @Package: com.swz</span><br><span class="line"> * @Description: 日期时间API</span><br><span class="line"> * @author: swz</span><br><span class="line"> * @date: 2018/11/30 14:23</span><br><span class="line"> */</span><br><span class="line">public class DateTimeTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        // LocalDate/LocalTime 和 LocalDateTime 类可以在处理时区不是必须的情况</span><br><span class="line">        DateTimeTest dateTimeTest = new DateTimeTest();</span><br><span class="line">        dateTimeTest.testLocalDateTime();</span><br><span class="line">        // 如果我们需要考虑到时区，就可以使用时区的日期时间API</span><br><span class="line">        dateTimeTest.testZonedDateTime();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void testLocalDateTime() &#123;</span><br><span class="line">        // 获取当前的日期时间</span><br><span class="line">        LocalDateTime localDateTime = LocalDateTime.now();</span><br><span class="line">        System.out.println(&quot;当前时间：&quot; + localDateTime);</span><br><span class="line">        LocalDate localDate = localDateTime.toLocalDate();</span><br><span class="line">        System.out.println(&quot;localDate:&quot; + localDate);</span><br><span class="line">        Month month = localDateTime.getMonth();</span><br><span class="line">        int day = localDateTime.getDayOfMonth();</span><br><span class="line">        int hours = localDateTime.getHour();</span><br><span class="line">        int minutes = localDateTime.getMinute();</span><br><span class="line">        int seconds = localDateTime.getSecond();</span><br><span class="line">        System.out.println(&quot;月：&quot; + month + &quot;,日: &quot; + day + &quot;,时：&quot; + hours + &quot;,分：&quot; + minutes + &quot;,秒: &quot; + seconds);</span><br><span class="line"></span><br><span class="line">        LocalDateTime localDateTime1 = localDateTime.withDayOfMonth(10).withYear(2018);</span><br><span class="line">        System.out.println(&quot;localDateTime1:&quot; + localDateTime1);</span><br><span class="line">        // 2018-11-28</span><br><span class="line">        LocalDate localDate1 = LocalDate.of(2018, Month.NOVEMBER, 28);</span><br><span class="line">        System.out.println(&quot;localDate1:&quot; + localDate1);</span><br><span class="line">        // 22:35</span><br><span class="line">        LocalTime localTime = LocalTime.of(22, 30);</span><br><span class="line">        System.out.println(&quot;localTime:&quot; + localTime);</span><br><span class="line">        // 解析字符串</span><br><span class="line">        LocalTime localTime1 = LocalTime.parse(&quot;22:35:24&quot;);</span><br><span class="line">        System.out.println(&quot;localTime1&quot; + localTime1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void testZonedDateTime() &#123;</span><br><span class="line">        // 获取当前时间日期</span><br><span class="line">        ZonedDateTime date1 = ZonedDateTime.parse(&quot;2015-12-03T10:15:30+05:30[Asia/Shanghai]&quot;);</span><br><span class="line">        System.out.println(&quot;date1: &quot; + date1);</span><br><span class="line">        ZoneId id = ZoneId.of(&quot;Europe/Paris&quot;);</span><br><span class="line">        System.out.println(&quot;ZoneId: &quot; + id);</span><br><span class="line">        ZoneId currentZone = ZoneId.systemDefault();</span><br><span class="line">        System.out.println(&quot;当期时区: &quot; + currentZone);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Java8-Base64"><a href="#Java8-Base64" class="headerlink" title="Java8 Base64"></a>Java8 Base64</h2><p>Base64编码已经成为Java类库的标准；<br>Java8 内置了 Base64 编码的编码器和解码器<br>Base64工具类提供了一套静态方法获取下面三种BASE64编解码器：</p><ul><li>基本：输出被映射到一组字符A-Za-z0-9+/，编码不添加任何行标，输出的解码仅支持A-Za-z0-9+/;</li><li>URL：输出映射到一组字符A-Za-z0-9+_，输出是URL和文件;</li><li>MIME：输出隐射到MIME友好格式。输出每行不超过76字符，并且使用’\r’并跟随’\n’作为分割。编码输出最后没有行分割</li></ul><h3 id="Base64实例"><a href="#Base64实例" class="headerlink" title="Base64实例"></a>Base64实例</h3><p>以下是Base64的使用实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @Package: com.swz</span><br><span class="line"> * @Description: Base64编码</span><br><span class="line"> * @author: swz</span><br><span class="line"> * @date: 2018/11/30 14:56</span><br><span class="line"> */</span><br><span class="line">public class Base64Test &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            // 使用基本编码</span><br><span class="line">            String base64encodedString = Base64.getEncoder().encodeToString(&quot;runoob?java8&quot;.getBytes(&quot;utf-8&quot;));</span><br><span class="line">            System.out.println(&quot;Base64编码字符串(基本)：&quot; + base64encodedString);</span><br><span class="line">            // 解码</span><br><span class="line">            byte[] base64decodedBytes = Base64.getDecoder().decode(base64encodedString);</span><br><span class="line">            System.out.println(&quot;原始字符串: &quot; + new String(base64decodedBytes, &quot;utf-8&quot;));</span><br><span class="line">            // 使用URL编码</span><br><span class="line">            base64encodedString = Base64.getUrlEncoder().encodeToString(&quot;TutorialsPoint?java8&quot;.getBytes(&quot;utf-8&quot;));</span><br><span class="line">            System.out.println(&quot;Base64 编码字符串 (URL) :&quot; + base64encodedString);</span><br><span class="line">            // 使用MIME编码</span><br><span class="line">            StringBuilder stringBuilder = new StringBuilder();</span><br><span class="line">            for (int i = 0; i &lt; 10; ++i) &#123;</span><br><span class="line">                stringBuilder.append(UUID.randomUUID().toString());</span><br><span class="line">            &#125;</span><br><span class="line">            byte[] mimeBytes = stringBuilder.toString().getBytes(&quot;utf-8&quot;);</span><br><span class="line">            String mimeEncodedString = Base64.getMimeEncoder().encodeToString(mimeBytes);</span><br><span class="line">            System.out.println(&quot;Base64 编码字符串 (MIME) :&quot; + mimeEncodedString);</span><br><span class="line">        &#125; catch (UnsupportedEncodingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="重复注解-RepeatingAnnotationTest"><a href="#重复注解-RepeatingAnnotationTest" class="headerlink" title="重复注解-RepeatingAnnotationTest"></a>重复注解-RepeatingAnnotationTest</h2><p>以下是重复注解的使用实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @Package: com.swz</span><br><span class="line"> * @Description: 重复注解，拓宽注解的应用场景</span><br><span class="line"> * @author: swz</span><br><span class="line"> * @date: 2018/11/30 15:18</span><br><span class="line"> */</span><br><span class="line">public class RepeatingAnnotationTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for( Filter filter: Filterable.class.getAnnotationsByType( Filter.class ) ) &#123;</span><br><span class="line">            System.out.println( filter.value() );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Target( ElementType.TYPE )</span><br><span class="line">    @Retention( RetentionPolicy.RUNTIME )</span><br><span class="line">    public @interface Filters &#123;</span><br><span class="line">        Filter[] value();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Target( ElementType.TYPE )</span><br><span class="line">    @Retention( RetentionPolicy.RUNTIME )</span><br><span class="line">    @Repeatable( Filters.class )</span><br><span class="line">    public @interface Filter &#123;</span><br><span class="line">        String value();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Filter( &quot;filter1&quot; )</span><br><span class="line">    @Filter( &quot;filter2&quot; )</span><br><span class="line">    public interface Filterable &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Java8已经发布很久了，毫无疑问，这是继java5之后一次重大的版本升级，这个版本包含语言、编译器、库、工具和JVM等方面的十多个新特性。有人认为，虽然这些新特性领Java开发人员十分期待，但同时也需要花不少精力去学习。因此，本文综合了一些资料，整理成一份关于Java 8新特性的参考教材，希望你有所收获。&lt;br&gt;本文中所用的实例请点击：&lt;a href=&quot;https://github.com/jsxzswz/Java8Demo&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Java8新特性实例&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="https://jsxzswz.github.io/categories/java/"/>
    
    
      <category term="java" scheme="https://jsxzswz.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Mysql常用函数</title>
    <link href="https://jsxzswz.github.io/2019/01/04/blog20181207/"/>
    <id>https://jsxzswz.github.io/2019/01/04/blog20181207/</id>
    <published>2019-01-04T09:21:26.995Z</published>
    <updated>2019-01-30T02:17:55.314Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文章描述"><a href="#文章描述" class="headerlink" title="文章描述"></a>文章描述</h2><p> MySQL数据库中提供了很丰富的函数。MySQL函数包括数学函数、字符串函数、日期和时间函数、条件判断函数、系统信息函数、加密函数、格式化函数等。通过这些函数，可以简化用户的操作。以下是对mysql中的常用函数进行了汇总介绍，需要的朋友可以过来参考下。</p><a id="more"></a><h2 id="数字函数"><a href="#数字函数" class="headerlink" title="数字函数"></a>数字函数</h2><table><thead><tr><th style="text-align:left">函数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">ABS(x)</td><td style="text-align:left">返回x的绝对值</td></tr><tr><td style="text-align:left">BIN(x)</td><td style="text-align:left">返回x的二进制（OCT-八进制，HEX-十六进制）</td></tr><tr><td style="text-align:left">CEILING(x)</td><td style="text-align:left">返回大于x的最小整数值</td></tr><tr><td style="text-align:left">EXP(x)</td><td style="text-align:left">返回值e（自然对数的底）的x次方</td></tr><tr><td style="text-align:left">FLOOR(x)</td><td style="text-align:left">返回小于x的最大整数值</td></tr><tr><td style="text-align:left">GREATEST(x1…,xn)</td><td style="text-align:left">返回集合中最大的值</td></tr><tr><td style="text-align:left">LEAST(x1…,xn)</td><td style="text-align:left">返回集合中最小的值</td></tr><tr><td style="text-align:left">LN(x)</td><td style="text-align:left">返回x的自然对数</td></tr><tr><td style="text-align:left">LOG(x,y)</td><td style="text-align:left">返回x的以y为底的对数</td></tr><tr><td style="text-align:left">MOD(x,y)</td><td style="text-align:left">返回x的以y为底的对数</td></tr><tr><td style="text-align:left">RAND()</td><td style="text-align:left">随机数生成器生成一个指定的值</td></tr><tr><td style="text-align:left">ROUND(x,y)</td><td style="text-align:left">返回参数x的四舍五入的有y位小数的值</td></tr><tr><td style="text-align:left">SIGN(x)</td><td style="text-align:left">返回代表数字x的符号的值</td></tr><tr><td style="text-align:left">SQRT(x)</td><td style="text-align:left">返回一个数的平方根</td></tr><tr><td style="text-align:left">TRUNCATE(x,y)</td><td style="text-align:left">返回数字x截短为y位小数的结果</td></tr></tbody></table><h2 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h2><table><thead><tr><th style="text-align:left">函数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">AVG(col)</td><td style="text-align:left">返回指定列的平均值</td></tr><tr><td style="text-align:left">COUNT(col)</td><td style="text-align:left">返回指定列中非NULL值的个数</td></tr><tr><td style="text-align:left">MIN(col)</td><td style="text-align:left">返回指定列的最小值</td></tr><tr><td style="text-align:left">MAX(col)</td><td style="text-align:left">返回指定列的最大值</td></tr><tr><td style="text-align:left">SUM(col)</td><td style="text-align:left">返回指定列的所有值之和</td></tr><tr><td style="text-align:left">GROUP_CONCAT(col)</td><td style="text-align:left">返回由属于一组的列值连接组合而成的结果</td></tr></tbody></table><h2 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h2><table><thead><tr><th style="text-align:left">函数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">ASCII(char)</td><td style="text-align:left">返回字符的ASCII码值</td></tr><tr><td style="text-align:left">BIT_LENGTH(str)</td><td style="text-align:left">返回字符串的比特长度</td></tr><tr><td style="text-align:left">CONCAT(s1,s2…,sn)</td><td style="text-align:left">将s1,s2…,sn连接成字符串</td></tr><tr><td style="text-align:left">CONCAT_WS(sep,s1,s2…,sn)</td><td style="text-align:left">将s1,s2…,sn连接成字符串，并用sep字符间隔</td></tr><tr><td style="text-align:left">LEFT(str,x)</td><td style="text-align:left">返回字符串str中最左边的x个字符</td></tr><tr><td style="text-align:left">LTRIM(str)</td><td style="text-align:left">从字符串str中切掉开头的空格</td></tr><tr><td style="text-align:left">POSITION(substr,str)</td><td style="text-align:left">substr在字符串str中第一次出现的位置</td></tr><tr><td style="text-align:left">QUOTE(str)</td><td style="text-align:left">用反斜杠转义str中的单引号</td></tr><tr><td style="text-align:left">REPEAT(str,srchstr,rplcstr)</td><td style="text-align:left">返回字符串str重复x次的结果</td></tr><tr><td style="text-align:left">REVERSE(str)</td><td style="text-align:left">返回颠倒字符串str的结果</td></tr><tr><td style="text-align:left">RIGHT(str,x)</td><td style="text-align:left">返回字符串str中最右边的x个字符</td></tr><tr><td style="text-align:left">RTRIM(str)</td><td style="text-align:left">返回字符串str尾部的空格</td></tr><tr><td style="text-align:left">STRCMP(s1,s2)</td><td style="text-align:left">比较字符串s1和s2</td></tr><tr><td style="text-align:left">TRIM(str)</td><td style="text-align:left">去除字符串首部和尾部的所有空格</td></tr><tr><td style="text-align:left">UCASE(str)/UPPER(str)</td><td style="text-align:left">返回字符串str中所有字符改变为大写后的结果</td></tr><tr><td style="text-align:left">LCASE(str)/LOWER(str)</td><td style="text-align:left">返回字符串str中所有字符改变为小写后的结果</td></tr></tbody></table><h2 id="日期和时间函数"><a href="#日期和时间函数" class="headerlink" title="日期和时间函数"></a>日期和时间函数</h2><table><thead><tr><th style="text-align:left">函数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">CURDATE()/CURRENT_DATE()</td><td style="text-align:left">返回当前的日期</td></tr><tr><td style="text-align:left">CURTIME()/CURRENT_TIME()</td><td style="text-align:left">返回当前的时间</td></tr><tr><td style="text-align:left">DATE_FORMAT(date,fmt)</td><td style="text-align:left">依照指定的fmt格式格式化日期date值</td></tr><tr><td style="text-align:left">DAYOFWEEK(date)</td><td style="text-align:left">返回date所代表的一星期中的第几天(1~7)</td></tr><tr><td style="text-align:left">DAYOFMONTH(date)</td><td style="text-align:left">返回date是一个月的第几天(1~31)</td></tr><tr><td style="text-align:left">DAYOFYEAR(date)</td><td style="text-align:left">返回date是一年的第几天(1~366)</td></tr><tr><td style="text-align:left">FROM_UNIXTIME(ts,fmt)</td><td style="text-align:left">根据指定的fmt格式，格式化UNIX时间戳ts</td></tr><tr><td style="text-align:left">UNIX_TIMESTAMP(date)</td><td style="text-align:left">把字符串日期转成时间戳</td></tr><tr><td style="text-align:left">NOW()</td><td style="text-align:left">返回当前的日期和时间</td></tr><tr><td style="text-align:left">WEEK(date)</td><td style="text-align:left">返回日期date为一年中第几周(0~53)</td></tr><tr><td style="text-align:left">YEAR(date)</td><td style="text-align:left">返回日期date的年份(1000~9999)</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT FROM_UNIXTIME(UNIX_TIMESTAMP());</span><br><span class="line">SELECT EXTRACT(YEAR_MONTH FROM CURRENT_DATE);</span><br><span class="line">SELECT EXTRACT(DAY_SECOND FROM CURRENT_DATE);</span><br><span class="line">SELECT EXTRACT(HOUR_MINUTE FROM CURRENT_DATE);</span><br></pre></td></tr></table></figure><h2 id="系统信息函数"><a href="#系统信息函数" class="headerlink" title="系统信息函数"></a>系统信息函数</h2><table><thead><tr><th style="text-align:left">函数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">DATABASE()</td><td style="text-align:left">返回当前数据库名</td></tr><tr><td style="text-align:left">BENCHMARK(count,expr)</td><td style="text-align:left">返回当前的时间</td></tr><tr><td style="text-align:left">CONNECTION_ID()</td><td style="text-align:left">返回当前客户的连接ID</td></tr><tr><td style="text-align:left">FOUND_ROWS()</td><td style="text-align:left">返回最后一个SELECT查询进行检索的总行数</td></tr><tr><td style="text-align:left">USER()/SYSTEM_USER()</td><td style="text-align:left">返回当前登陆用户名</td></tr><tr><td style="text-align:left">VERSION()</td><td style="text-align:left">返回MySQL服务器的版本</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SELECT id , `customer_name` , sex , LEFT(telephone,3) ,USER(),RAND(),WEEK(now()) ,SQRT(4) ,CONCAT(telephone,&apos;-&apos;,id),LOWER(&apos;abc&apos;), CURRENT_TIME(),UNIX_TIMESTAMP(now()),</span><br><span class="line">CASE</span><br><span class="line">WHEN sex = 1 THEN &apos;男&apos;</span><br><span class="line">WHEN sex = 2 THEN &apos;女&apos;</span><br><span class="line">else &apos;保密&apos;</span><br><span class="line">END AS sex</span><br><span class="line">FROM customer_demand</span><br><span class="line">ORDER BY id DESC</span><br><span class="line">LIMIT 10</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>有些函数真的非常有用，真的希望我的总结对你有帮助。谢谢各位的阅读，也希望你能和我分享你的学习心得。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;文章描述&quot;&gt;&lt;a href=&quot;#文章描述&quot; class=&quot;headerlink&quot; title=&quot;文章描述&quot;&gt;&lt;/a&gt;文章描述&lt;/h2&gt;&lt;p&gt; MySQL数据库中提供了很丰富的函数。MySQL函数包括数学函数、字符串函数、日期和时间函数、条件判断函数、系统信息函数、加密函数、格式化函数等。通过这些函数，可以简化用户的操作。以下是对mysql中的常用函数进行了汇总介绍，需要的朋友可以过来参考下。&lt;/p&gt;
    
    </summary>
    
      <category term="数据库" scheme="https://jsxzswz.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="mysql" scheme="https://jsxzswz.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Oracle常用函数</title>
    <link href="https://jsxzswz.github.io/2019/01/04/blog20181206/"/>
    <id>https://jsxzswz.github.io/2019/01/04/blog20181206/</id>
    <published>2019-01-04T09:21:26.993Z</published>
    <updated>2019-01-09T06:08:28.759Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在平时写PL/SQL的时候，经常要用到很多系统自带的函数，而这些函数用起来非常好用，但是每次用完以后，就又忘到脑后了，为了加深自己的印象，以及对这些函数做一个全面的总结，下面就对Oracle常见函数做个整理，方便以后查询。</p><a id="more"></a><h2 id="常用字符函数"><a href="#常用字符函数" class="headerlink" title="常用字符函数"></a>常用字符函数</h2><p>在编写PL/SQL程序时，或多或少的需要进行字符串操作，进行字符串操作又离不开以下的这些函数。</p><table><thead><tr><th style="text-align:left">函数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">LOWER(char)</td><td style="text-align:left">将字符串表达式char中的所有大写字母转换为小写字母</td></tr><tr><td style="text-align:left">UPPER(char)</td><td style="text-align:left">将字符串表达式char中的所有小写字母转换为大写字母</td></tr><tr><td style="text-align:left">INITCAP(char)</td><td style="text-align:left">首字母转换成大写</td></tr><tr><td style="text-align:left">SUBSTR(char, start, length)</td><td style="text-align:left">返回字符串表达式char中从第start开始的length个字符</td></tr><tr><td style="text-align:left">LENGTH(char)</td><td style="text-align:left">返回字符串表达式char的长度</td></tr><tr><td style="text-align:left">ASCII(char)</td><td style="text-align:left">取char的ASCII值</td></tr><tr><td style="text-align:left">CHR(number)</td><td style="text-align:left">取number的ASCII值</td></tr><tr><td style="text-align:left">REPLACE(char,search_str[,replacement_str])</td><td style="text-align:left">将字符串char中的子串search_str替换成replacement_str；如果search_str=null，返回char；如果replacement_str=null，则会去掉char中的search_str</td></tr><tr><td style="text-align:left">INSTR(char1,char2[,n[,m]])</td><td style="text-align:left">获取子串char2在字符串char1中的位置。n为其实搜索位置，m为子串出现的次数；n为负，则从尾部开始搜索；n\m默认为1</td></tr><tr><td style="text-align:left">LPAD(char1,n,char2)</td><td style="text-align:left">在字符串char1的左端填充字符串char2直到长度达到n;char2默认为空格，如果char1.length&gt;n，则返回char1左端的n个字符</td></tr><tr><td style="text-align:left">RPAD(char1,n,char2)</td><td style="text-align:left">在字符串char1的右端填充字符串char2直到长度达到n;char2默认为空格，如果char1.length&gt;n，则返回char1左端的n个字符</td></tr><tr><td style="text-align:left">LTRIM(char1[,set])</td><td style="text-align:left">去掉字符串char1左端包含的set中的任意字符</td></tr><tr><td style="text-align:left">RTRIM(char1[,set])</td><td style="text-align:left">去掉字符串char1右端包含的set中的任意字符</td></tr><tr><td style="text-align:left">TRIM(char &#124; char From string)</td><td style="text-align:left">从字符串的头尾或者两端截断特定字符</td></tr><tr><td style="text-align:left">CONCAT(str1,str2)</td><td style="text-align:left">连接字符串，同 &#124;&#124; 的作用一样</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">-- LOWER测试</span><br><span class="line">select LOWER(&apos;HTTP://WWW.JELLYTHINK.COM&apos;) from dual; -- http://www.jellythink.com</span><br><span class="line"></span><br><span class="line">-- UPPER测试</span><br><span class="line">select UPPER(&apos;http://www.jellythink.com&apos;) from dual; -- HTTP://WWW.JELLYTHINK.COM</span><br><span class="line"></span><br><span class="line">-- INITCAP测试</span><br><span class="line">select INITCAP(&apos;jelly think&apos;) from dual; -- Jelly Think</span><br><span class="line"></span><br><span class="line">-- SUBSTR测试</span><br><span class="line">select SUBSTR(&apos;http://www.jellythink.com&apos;, 12, 10) from dual; -- jellythink(注：下标从1开始)</span><br><span class="line"></span><br><span class="line">-- LENGTH测试</span><br><span class="line">select LENGTH(&apos;JellyThink&apos;) from dual; -- 10</span><br><span class="line"></span><br><span class="line">-- ASCII测试</span><br><span class="line">select ASCII(&apos;A&apos;) from dual; -- 65</span><br><span class="line"></span><br><span class="line">-- CHR测试</span><br><span class="line">select CHR(65) from dual; -- A</span><br><span class="line"></span><br><span class="line">-- REPLACE测试</span><br><span class="line">select REPLACE(&apos;jellythink&apos;, &apos;think&apos;, &apos; is good&apos;) from dual; -- jelly is good</span><br><span class="line"></span><br><span class="line">-- INSTR测试</span><br><span class="line">select INSTR(&apos;JellyThink&apos;, &apos;Jelly&apos;, 1) from dual; -- 1</span><br><span class="line"></span><br><span class="line">-- LPAD测试</span><br><span class="line">select LPAD(&apos;JellyThink&apos;, 12, &apos;*&apos;) from dual; -- **JellyThink</span><br><span class="line"></span><br><span class="line">-- RPAD测试</span><br><span class="line">select RPAD(&apos;JellyThink&apos;, 12, &apos;*&apos;) from dual; -- JellyThink**</span><br><span class="line"></span><br><span class="line">-- LTRIM测试</span><br><span class="line">select LTRIM(&apos;**JellyThink&apos;, &apos;*&apos;) from dual; -- JellyThink</span><br><span class="line"></span><br><span class="line">-- RTRIM测试</span><br><span class="line">select RTRIM(&apos;JellyThink**&apos;, &apos;*&apos;) from dual; -- JellyThink</span><br><span class="line"></span><br><span class="line">-- TRIM测试</span><br><span class="line">select TRIM(&apos;*&apos; from &apos;**JellyThink**&apos;) from dual; -- JellyThink</span><br><span class="line">select TRIM(&apos;  JellyThink  &apos;) from dual; -- JellyThink(注：默认去掉空格)</span><br></pre></td></tr></table></figure><h2 id="常用日期函数"><a href="#常用日期函数" class="headerlink" title="常用日期函数"></a>常用日期函数</h2><p>每天都在和各种日期打交道，一个会得到这个月的最后一天，一会又要得到当前日期，看看以下的函数吧，是否似曾相识。</p><table><thead><tr><th style="text-align:left">函数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">SYSDATE</td><td style="text-align:left">返回系统当前日期和时间</td></tr><tr><td style="text-align:left">NEXT_DAY(day,char)</td><td style="text-align:left">返回指定日期day后的第一个工作日char所对应的日期</td></tr><tr><td style="text-align:left">LAST_DAY(day)</td><td style="text-align:left">返回day日期所指定月份中最后一天所对应的日期</td></tr><tr><td style="text-align:left">ADD_MONTHS(day,n)</td><td style="text-align:left">返回day日期在n个月后(n为正数)或前(n为负数)的日期</td></tr><tr><td style="text-align:left">MONTHS_BETWEEN(day1,day2)</td><td style="text-align:left">返回day1日期和day2日期之间相差得月份</td></tr><tr><td style="text-align:left">ROUND(day[,fmt])</td><td style="text-align:left">返回日期的四舍五入结果。如果fmt指定年度，则7月1日为分界线；如果fmt指定月，则16日为分界线；如果指定天，则中午12:00为分界线，默认舍入到日</td></tr><tr><td style="text-align:left">TRUNC(day,[,fmt])</td><td style="text-align:left">日期截断函数。如果fmt指定年度，则结果为本年度的1月1日；如果为月，则将结果为本月1日，默认截断到日</td></tr><tr><td style="text-align:left">CURRENT_DATE</td><td style="text-align:left">返回当前会话时区所对应日期时间</td></tr><tr><td style="text-align:left">EXTRACT</td><td style="text-align:left">从日期中获取所需要的特定数据</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">-- SYSDATE测试</span><br><span class="line">select TO_CHAR(SYSDATE,&apos;yyyy-MM-dd hh24:mi:ss&apos;) from dual; -- 2015-09-29 15:14:44</span><br><span class="line"></span><br><span class="line">-- NEXT_DAY测试</span><br><span class="line">select NEXT_DAY(SYSDATE, &apos;星期一&apos;) from dual; -- 2015/10/5 15:16:46</span><br><span class="line"></span><br><span class="line">-- LAST_DAY测试</span><br><span class="line">select LAST_DAY(SYSDATE) from dual; -- 2015/9/30 15:17:23</span><br><span class="line"></span><br><span class="line">-- ADD_MONTHS测试</span><br><span class="line">select ADD_MONTHS(SYSDATE, 2) from dual; -- 2015/11/29 15:18:39</span><br><span class="line"></span><br><span class="line">-- MONTHS_BETWEEN测试</span><br><span class="line">select MONTHS_BETWEEN(SYSDATE, SYSDATE) from dual; -- 0</span><br><span class="line">select MONTHS_BETWEEN(ADD_MONTHS(SYSDATE, -2), ADD_MONTHS(SYSDATE, 2)) from dual; -- -4</span><br><span class="line"></span><br><span class="line">-- ROUND测试</span><br><span class="line">select ROUND(SYSDATE) from dual; -- 2015/9/30</span><br><span class="line">select ROUND(SYSDATE, &apos;YEAR&apos;) from dual; -- 2016/1/1</span><br><span class="line">select ROUND(SYSDATE, &apos;MONTH&apos;) from dual; -- 2015/10/1</span><br><span class="line"></span><br><span class="line">-- TRUNC测试</span><br><span class="line">select TRUNC(SYSDATE) from dual; -- 2015/9/29</span><br><span class="line">select TRUNC(SYSDATE, &apos;YEAR&apos;) from dual; -- 2015/1/1</span><br><span class="line">select TRUNC(SYSDATE, &apos;MONTH&apos;) from dual; -- 2015/9/1</span><br><span class="line"></span><br><span class="line">-- CURRENT_DATE测试</span><br><span class="line">select CURRENT_DATE from dual; -- 2015/9/29 15:22:44</span><br></pre></td></tr></table></figure><h2 id="常用类型转换函数"><a href="#常用类型转换函数" class="headerlink" title="常用类型转换函数"></a>常用类型转换函数</h2><p>类型转换函数是太常见了，什么to_char啊，to_date啊，但是你有没有好好的使用过呢？</p><table><thead><tr><th style="text-align:left">函数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">TO_CHAR</td><td style="text-align:left">将一个数字或日期转换成字符串</td></tr><tr><td style="text-align:left">TO_NUMBER</td><td style="text-align:left">将字符型数据转换成数字型数据</td></tr><tr><td style="text-align:left">TO_DATE</td><td style="text-align:left">将字符型数据转换为日期型数据</td></tr><tr><td style="text-align:left">CAST</td><td style="text-align:left">将一种built-in类型转换成另一种built-in类型</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-- TO_CHAR测试</span><br><span class="line">select TO_CHAR(100) from dual; -- 100</span><br><span class="line">select TO_CHAR(SYSDATE, &apos;YYYY-MM-DD HH24:MI:SS&apos;) from dual; -- 2015-09-29 15:36:24</span><br><span class="line"></span><br><span class="line">-- TO_NUMBER测试</span><br><span class="line">select TO_NUMBER(&apos;10&apos;) from dual; -- 10</span><br><span class="line">select TO_NUMBER(&apos;JellyThink&apos;) from dual; -- 无效数字</span><br><span class="line"></span><br><span class="line">-- TO_DATE测试</span><br><span class="line">select TO_DATE(&apos;2015-9-29&apos;, &apos;YYYY-MM-DD&apos;) from dual; -- 2015/9/29</span><br><span class="line"></span><br><span class="line">-- CAST测试</span><br><span class="line">select CAST(&apos;100&apos; as NUMBER) from dual; -- 100</span><br><span class="line">select CAST(2 as char) from dual; -- 2</span><br></pre></td></tr></table></figure><h2 id="集合函数"><a href="#集合函数" class="headerlink" title="集合函数"></a>集合函数</h2><p>有了GROUP BY，怎么可以少了这些用来统计的集合函数呢。</p><table><thead><tr><th style="text-align:left">函数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">AVG</td><td style="text-align:left">计算一列值的平均值</td></tr><tr><td style="text-align:left">COUNT</td><td style="text-align:left">统计一列中值的个数</td></tr><tr><td style="text-align:left">MAX</td><td style="text-align:left">求一列值中的最大值</td></tr><tr><td style="text-align:left">MIN</td><td style="text-align:left">求一列值中的最小值</td></tr><tr><td style="text-align:left">SUM</td><td style="text-align:left">计算一列值的总和</td></tr></tbody></table><h2 id="其它常用函数"><a href="#其它常用函数" class="headerlink" title="其它常用函数"></a>其它常用函数</h2><p>还有一些经常使用的函数不属于上述的任何一种分类，只能作为其它常用函数来分类了，具体你看喽。</p><table><thead><tr><th style="text-align:left">函数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">decode(expression , search , result [, search , result]… [, default])</td><td style="text-align:left">IF语句的另一形式。将输入数值与参数列表比较，返回对应值。应用于将表的行转换成列以及IF语句无法应用的场合</td></tr><tr><td style="text-align:left">SIGN(number)</td><td style="text-align:left">如果number大于0，SIGN则返回1；如果number小于0，SIGN则返回-1；如果number等于0，SIGN则返回0</td></tr><tr><td style="text-align:left">TRUNC(number, [ decimal_places ])</td><td style="text-align:left">number是要截取的数字，decimal_places是要保留的小数位。这个参数必须是个整数。 如果此参数缺省，默认保留0位小数</td></tr><tr><td style="text-align:left">GREATEST(expr1[,expr2]…)</td><td style="text-align:left">返回表达式中值最大的一个</td></tr><tr><td style="text-align:left">LEAST(expr1[,expr2]…)</td><td style="text-align:left">返回表达式中值最小的一个</td></tr><tr><td style="text-align:left">NULLIF(expr1,expr2)</td><td style="text-align:left">如果expr1=expr2；则返回null，否则返回expr1</td></tr><tr><td style="text-align:left">NVL(expr1,expr2)</td><td style="text-align:left">如果expr1=null；则返回expr2，否则返回expr1</td></tr><tr><td style="text-align:left">NVL2(expr1,expr2,expr3)</td><td style="text-align:left">如果expr1!=null；则返回expr2；如果expr1=null；则返回expr3</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">-- DECODE测试</span><br><span class="line">select DECODE(20, 10, 5, 200, 10, 20, 30) from dual; -- 30</span><br><span class="line"></span><br><span class="line">-- SIGN测试</span><br><span class="line">select SIGN(20) from dual; -- 1</span><br><span class="line">select SIGN(-30) from dual; -- -1</span><br><span class="line">select SIGN(0) from dual; -- 0</span><br><span class="line"></span><br><span class="line">-- TRUNC测试</span><br><span class="line">select TRUNC(20.2183, 2) from dual; -- 20.21</span><br><span class="line">select TRUNC(20.1, 4) from dual; -- 20.1</span><br><span class="line"></span><br><span class="line">-- GREATEST测试</span><br><span class="line">select GREATEST(20, 100, 30, 20, 40, 400) from dual; -- 400</span><br><span class="line"></span><br><span class="line">-- LEAST测试</span><br><span class="line">select LEAST(20, 100, 30, 20, 40, 400) from dual; -- 20</span><br><span class="line"></span><br><span class="line">-- NULLIF测试</span><br><span class="line">select NULLIF(20, 20) from dual; -- NULL</span><br><span class="line">select NULLIF(20, 10) from dual; -- 20</span><br><span class="line"></span><br><span class="line">-- NVL测试</span><br><span class="line">select NVL(20, 30) from dual; -- 20</span><br><span class="line">select NVL(NULL, 30) from dual; -- 30</span><br><span class="line"></span><br><span class="line">-- NVL2测试</span><br><span class="line">select NVL2(NULL, 20, 30) from dual; -- 30</span><br><span class="line">select NVL2(&apos;JellyThink&apos;, 20, 30) from dual; -- 20</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>哦，总结完了，感觉还算有点效果，至少又把这些函数重新复习了一遍，不是吗？有些函数真的非常有用，真的希望我的总结对你有帮助。谢谢各位的阅读，也希望你能和我分享你的学习心得。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在平时写PL/SQL的时候，经常要用到很多系统自带的函数，而这些函数用起来非常好用，但是每次用完以后，就又忘到脑后了，为了加深自己的印象，以及对这些函数做一个全面的总结，下面就对Oracle常见函数做个整理，方便以后查询。&lt;/p&gt;
    
    </summary>
    
      <category term="数据库" scheme="https://jsxzswz.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="oracle" scheme="https://jsxzswz.github.io/tags/oracle/"/>
    
  </entry>
  
</feed>
