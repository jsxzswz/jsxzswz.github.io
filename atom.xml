<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>孙文正的Blog</title>
  
  <subtitle>天道酬勤</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://jsxzswz.github.io/"/>
  <updated>2019-01-04T09:21:27.004Z</updated>
  <id>https://jsxzswz.github.io/</id>
  
  <author>
    <name>孙文正</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySQL常见的存储引擎</title>
    <link href="https://jsxzswz.github.io/2019/01/04/blog20190104/"/>
    <id>https://jsxzswz.github.io/2019/01/04/blog20190104/</id>
    <published>2019-01-04T09:21:27.003Z</published>
    <updated>2019-01-04T09:21:27.004Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>数据库存储引擎是数据库底层软件组织，数据库管理系统（DBMS）使用数据引擎进行创建、查询、更新和删除数据。不同的存储引擎提供不同的存储机制、索引技巧、锁定水平等功能，使用不同的存储引擎，还可以获得特定的功能。现在许多不同的数据库管理系统都支持多种不同的数据引擎,MySQL的核心就是存储引擎。在MySQL中的存储引擎有很多种，可以通过“SHOW ENGINES”语句来查看。下面重点关注InnoDB、MyISAM、MEMORY这三种。</p><a id="more"></a><h2 id="InnoDB存储引擎"><a href="#InnoDB存储引擎" class="headerlink" title="InnoDB存储引擎"></a>InnoDB存储引擎</h2><ul><li>InnoDB给MySQL的表提供了事务处理、回滚、崩溃修复能力和多版本并发控制的事务安全。在MySQL从3.23.34a开始包含InnnoDB。它是MySQL上第一个提供外键约束的表引擎。而且InnoDB对事务处理的能力，也是其他存储引擎不能比拟的。靠后版本的MySQL的默认存储引擎就是InnoDB。</li><li>InnoDB存储引擎总支持AUTO_INCREMENT。自动增长列的值不能为空，并且值必须唯一。MySQL中规定自增列必须为主键。在插入值的时候，如果自动增长列不输入值，则插入的值为自动增长后的值；如果输入的值为0或空（NULL），则插入的值也是自动增长后的值；如果插入某个确定的值，且该值在前面没有出现过，就可以直接插入。</li><li>InnoDB还支持外键（FOREIGN KEY）。外键所在的表叫做子表，外键所依赖（REFERENCES）的表叫做父表。父表中被字表外键关联的字段必须为主键。当删除、更新父表中的某条信息时，子表也必须有相应的改变，这是数据库的参照完整性规则。</li><li>InnoDB中，创建的表的表结构存储在.frm文件中。数据和索引存储在innodb_data_home_dir和innodb_data_file_path定义的表空间中。</li><li>InnoDB的优势在于提供了良好的事务处理、崩溃修复能力和并发控制。缺点是读写效率较差，占用的数据空间相对较大。</li></ul><h2 id="MyISAM存储引擎"><a href="#MyISAM存储引擎" class="headerlink" title="MyISAM存储引擎"></a>MyISAM存储引擎</h2><ul><li>MyISAM是MySQL中常见的存储引擎，曾经是MySQL的默认存储引擎。MyISAM是基于ISAM引擎发展起来的，增加了许多有用的扩展。</li><li>MyISAM的表存储成3个文件。文件的名字与表名相同。拓展名为frm、MYD、MYI。其实，frm文件存储表的结构；MYD文件存储数据，是MYData的缩写；MYI文件存储索引，是MYIndex的缩写。</li><li>基于MyISAM存储引擎的表支持3种不同的存储格式。包括静态型、动态型和压缩型。其中，静态型是MyISAM的默认存储格式，它的字段是固定长度的；动态型包含变长字段，记录的长度不是固定的；压缩型需要用到myisampack工具，占用的磁盘空间较小。</li><li>MyISAM的优势在于占用空间小，处理速度快。缺点是不支持事务的完整性和并发性。</li></ul><h2 id="MEMORY存储引擎"><a href="#MEMORY存储引擎" class="headerlink" title="MEMORY存储引擎"></a>MEMORY存储引擎</h2><ul><li>MEMORY是MySQL中一类特殊的存储引擎。它使用存储在内存中的内容来创建表，而且数据全部放在内存中。这些特性与前面的两个很不同。</li><li>每个基于MEMORY存储引擎的表实际对应一个磁盘文件。该文件的文件名与表名相同，类型为frm类型。该文件中只存储表的结构。而其数据文件，都是存储在内存中，这样有利于数据的快速处理，提高整个表的效率。值得注意的是，服务器需要有足够的内存来维持MEMORY存储引擎的表的使用。如果不需要了，可以释放内存，甚至删除不需要的表。</li><li>MEMORY默认使用哈希索引。速度比使用B型树索引快。当然如果你想用B型树索引，可以在创建索引时指定。</li><li>注意，MEMORY用到的很少，因为它是把数据存到内存中，如果内存出现异常就会影响数据。如果重启或者关机，所有数据都会消失。因此，基于MEMORY的表的生命周期很短，一般是一次性的。</li></ul><h2 id="存储引擎的选择"><a href="#存储引擎的选择" class="headerlink" title="存储引擎的选择"></a>存储引擎的选择</h2><p>不同的存储引擎都有各自的特点，以适应不同的需求，如下表所示：</p><table><thead><tr><th style="text-align:center">特性</th><th style="text-align:center">InnoDB</th><th style="text-align:center">MyISAM</th><th style="text-align:center">MEMORY</th></tr></thead><tbody><tr><td style="text-align:center">存储限制</td><td style="text-align:center">支持</td><td style="text-align:center">无</td><td style="text-align:center">无</td></tr><tr><td style="text-align:center">事物安全</td><td style="text-align:center">64TB</td><td style="text-align:center">有</td><td style="text-align:center">有</td></tr><tr><td style="text-align:center">空间使用</td><td style="text-align:center">高</td><td style="text-align:center">低</td><td style="text-align:center">低</td></tr><tr><td style="text-align:center">内存使用</td><td style="text-align:center">高</td><td style="text-align:center">低</td><td style="text-align:center">高</td></tr><tr><td style="text-align:center">插入速度</td><td style="text-align:center">低</td><td style="text-align:center">高</td><td style="text-align:center">高</td></tr><tr><td style="text-align:center">外键支持</td><td style="text-align:center">支持</td><td style="text-align:center">无</td><td style="text-align:center">无</td></tr></tbody></table><ul><li>InnoDB：支持事务处理，支持外键，支持崩溃修复能力和并发控制。如果需要对事务的完整性要求比较高（比如银行），要求实现并发控制（比如售票），那选择InnoDB有很大的优势。如果需要频繁的更新、删除操作的数据库，也可以选择InnoDB，因为支持事务的提交（commit）和回滚（rollback）。</li><li>MyISAM：插入数据快，空间和内存使用比较低。如果表主要是用于插入新记录和读出记录，那么选择MyISAM能实现处理高效率。如果应用的完整性、并发性要求比 较低，也可以使用。</li><li>MEMORY：所有的数据都在内存中，数据的处理速度快，但是安全性不高。如果需要很快的读写速度，对数据的安全性要求较低，可以选择MEMOEY。它对表的大小有要求，不能建立太大的表。所以，这类数据库只使用在相对较小的数据库表。</li><li>注意，同一个数据库也可以使用多种存储引擎的表。如果一个表要求比较高的事务处理，可以选择InnoDB。这个数据库中可以将查询要求比较高的表选择MyISAM存储。如果该数据库需要一个用于查询的临时表，可以选择MEMORY存储引擎。</li></ul><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>使用哪一种引擎需要灵活选择，一个数据库中多个表可以使用不同引擎以满足各种性能和实际需求，使用合适的存储引擎，将会提高整个数据库的性能。MySQL常见的存储引擎就介绍到这里了！</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;数据库存储引擎是数据库底层软件组织，数据库管理系统（DBMS）使用数据引擎进行创建、查询、更新和删除数据。不同的存储引擎提供不同的存储机制、索引技巧、锁定水平等功能，使用不同的存储引擎，还可以获得特定的功能。现在许多不同的数据库管理系统都支持多种不同的数据引擎,MySQL的核心就是存储引擎。在MySQL中的存储引擎有很多种，可以通过“SHOW ENGINES”语句来查看。下面重点关注InnoDB、MyISAM、MEMORY这三种。&lt;/p&gt;
    
    </summary>
    
      <category term="数据库" scheme="https://jsxzswz.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="mysql" scheme="https://jsxzswz.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Sublime Text3安装教程</title>
    <link href="https://jsxzswz.github.io/2019/01/04/blog20181214/"/>
    <id>https://jsxzswz.github.io/2019/01/04/blog20181214/</id>
    <published>2019-01-04T09:21:27.002Z</published>
    <updated>2019-01-04T09:21:27.002Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Sublime Text是2008年开发出来的一个代码编辑器，界面友好，功能非凡， 默认支持html, xml, javascript, ruby, python, php… 等等主流语言的语法高亮，它支持众多插件扩展，用它来写代码，绝对是一种享受。但是ST再强大也只是一个文本编辑器，不是真正意义上的IDE,像打断点调试这样的ST是做不到的。</p><a id="more"></a><h2 id="Sublime-Text3安装"><a href="#Sublime-Text3安装" class="headerlink" title="Sublime Text3安装"></a>Sublime Text3安装</h2><p>Windows系统下访问<a href="https://www.sublimetext.com" target="_blank" rel="noopener">sublimetext官网</a>，点击DOWNLOAD FOR WINDOWS按钮下载最新版，这里下载的是3176版本，如下图所示：</p><p><img src="/images/sublime1.png" alt="Sublime Text3" title="Sublime Text3"></p><p>下载完成后，运行程序开始安装，点击Next,选择合适的安装目录后Next，点击Install开始安装。安装完成后，运行Sublime后点击Help选项里的Enter License选项，将激活码填入即可，如下图所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">----- BEGIN LICENSE -----</span><br><span class="line">sgbteam</span><br><span class="line">Single User License</span><br><span class="line">EA7E-1153259</span><br><span class="line">8891CBB9 F1513E4F 1A3405C1 A865D53F</span><br><span class="line">115F202E 7B91AB2D 0D2A40ED 352B269B</span><br><span class="line">76E84F0B CD69BFC7 59F2DFEF E267328F</span><br><span class="line">215652A3 E88F9D8F 4C38E3BA 5B2DAAE4</span><br><span class="line">969624E7 DC9CD4D5 717FB40C 1B9738CF</span><br><span class="line">20B3C4F1 E917B5B3 87C38D9C ACCE7DD8</span><br><span class="line">5F7EF854 86B9743C FADC04AA FB0DA5C0</span><br><span class="line">F913BE58 42FEA319 F954EFDD AE881E0B</span><br><span class="line">------ END LICENSE ------</span><br></pre></td></tr></table></figure></p><p><img src="/images/sublime2.png" alt="Sublime Text3" title="License"></p><h2 id="安装常用插件"><a href="#安装常用插件" class="headerlink" title="安装常用插件"></a>安装常用插件</h2><h3 id="直接安装"><a href="#直接安装" class="headerlink" title="直接安装"></a>直接安装</h3><p>安装Sublime text3插件很方便，可以直接下载安装包解压缩到Packages目录（preferences-&gt;Browse Packages）。</p><h3 id="使用Package-Control组件安装（以LESS为例）"><a href="#使用Package-Control组件安装（以LESS为例）" class="headerlink" title="使用Package Control组件安装（以LESS为例）"></a>使用Package Control组件安装（以LESS为例）</h3><ul><li>按Ctrl+ `(此符号为tab按键上面的按键) 调出console（注：避免热键冲突）</li><li><p>粘贴以下代码到命令行并回车：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import urllib.request,os; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path();</span><br><span class="line">urllib.request.install_opener ( urllib.request.build_opener( urllib.request.ProxyHandler()) );</span><br><span class="line">open(os.path.join(ipp, pf), &apos;wb&apos;).write(urllib.request.urlopen ( &apos;http://sublime.wbond.net/&apos; + pf.replace(&apos; &apos;,&apos;%20&apos;)).read())</span><br></pre></td></tr></table></figure></li><li><p>重启Sublime Text 3。</p></li><li>如果在Perferences-&gt;package settings中看到package control这一项，则安装成功。</li></ul><p>Package Control安装插件的方法:</p><ul><li>按下Ctrl+Shift+P调出命令面板</li><li>输入install 调出 Install Package 选项并回车，如下图所示：</li></ul><p><img src="/images/sublime3.png" alt="Sublime Text3" title="Install Package"></p><p>然后在列表中选择要安装的插件,如图所示：</p><p><img src="/images/sublime4.png" alt="Sublime Text3" title="Install LESS"></p><p>等待一会即可完成安装！</p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>好了，到这里Sublime Text3就已经安装完成了，大家赶紧去尝试，享受编码的乐趣吧！</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Sublime Text是2008年开发出来的一个代码编辑器，界面友好，功能非凡， 默认支持html, xml, javascript, ruby, python, php… 等等主流语言的语法高亮，它支持众多插件扩展，用它来写代码，绝对是一种享受。但是ST再强大也只是一个文本编辑器，不是真正意义上的IDE,像打断点调试这样的ST是做不到的。&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="https://jsxzswz.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>IDEA安装教程</title>
    <link href="https://jsxzswz.github.io/2019/01/04/blog20181211/"/>
    <id>https://jsxzswz.github.io/2019/01/04/blog20181211/</id>
    <published>2019-01-04T09:21:26.999Z</published>
    <updated>2019-01-04T09:21:27.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>说起Java的IDE,大家琅琅上口的不外乎Jbuilder,Eclipse,NetBeans这三个,如果你只是想找个IDE来学习Java，或者你需要漂亮的图标，再或者你的电脑配置并不高，那么Eclipse是个不错的选择。如果你想找个能提升开发效率的IDE，想找一个更快更方便的工具，推荐你用IntelliJ IDEA。</p><a id="more"></a><h2 id="IntelliJ-IDEA优势"><a href="#IntelliJ-IDEA优势" class="headerlink" title="IntelliJ IDEA优势"></a>IntelliJ IDEA优势</h2><ul><li>更好的调试。IntelliJ IDEA在调试上的表现，可以说比Eclipse强大太多。在调试过程中哦，当我们需要求一些表达式的值时，如果使用Eclipse就需要选定整个表达式，然后用Crtl+Shift+I看到这个表达式的值。但是，在IntelliJ IDEA中，只需要移动光标到表达式下然后用Alt+F8就可以实现。IntelliJ IDEA能够很好地理解你可能需要的表达式，还会给出的建议参数变量。你可以直接编辑并能立刻得到这个表达式的值，不会像在Eclipse中一个Debug界面跳来跳去。</li><li>更高的开发效率。IntelliJ IDEA在代码自动生成方面表现比Eclipse更为智能，比如IntelliJ IDEA能生成某个类的测试类，还能正确地放到test的相应目录下。在对ZenCoding的支持上，写html非常方便，tab快速补全，和原生集成一样。IntelliJ IDEA在开发效率上更明显的一点是，对JS、CSS以及插件的支持更好。</li><li>更智能的重构。这一点其实也属于开发效率，但是IntelliJ IDEA得重构功能还是想让我单独强调一下。所有的现代IDE都提供重构功能，这一点上，IntelliJ IDEA能读懂你需要什么，并且会针对不同的情况给你提供最合适的解决方案。</li><li>目录分层少而清。IntelliJ IDEA的目录分层很少，但是却很清晰，IDE配置的东西都能在Settings利找到，工程的配置也能在Project Settings里找到。</li></ul><h2 id="IntelliJ-IDEA安装"><a href="#IntelliJ-IDEA安装" class="headerlink" title="IntelliJ IDEA安装"></a>IntelliJ IDEA安装</h2><p>访问地址<a href="https://www.jetbrains.com/idea/download/previous.html" target="_blank" rel="noopener">IDEA历史版本</a>，选择合适的版本，这里楼主选择的是15.0.6终极版。如图：</p><p><img src="/images/idea1.png" alt="IntelliJ IDEA 15.0.6" title="IDEA 15.0.6"></p><p>点击下载,下载完成后，运行程序开始安装，点击Next，选择合适的安装目录后Next，勾选Create Desktop shortcut创建桌面快捷方式Next后点击Install开始安装。几分钟后安装完成关闭安装页面。打开桌面上的IntelliJ IDEA 15.0.6，进入页面后选择合适的主题，点击Register激活产品！</p><p><img src="/images/idea2.png" alt="IntelliJ IDEA 15.0.6" title="Register"></p><p>访问地址<a href="http://idea.lanyus.com" target="_blank" rel="noopener">获取激活码</a>，点击获得注册码，将注册码复制粘贴到框里即可!</p><p><img src="/images/idea3.png" alt="IntelliJ IDEA 15.0.6" title="Code"></p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>好了，到这里IDEA就已经安装完成了，大家赶紧去尝试，享受编码的乐趣吧！</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;说起Java的IDE,大家琅琅上口的不外乎Jbuilder,Eclipse,NetBeans这三个,如果你只是想找个IDE来学习Java，或者你需要漂亮的图标，再或者你的电脑配置并不高，那么Eclipse是个不错的选择。如果你想找个能提升开发效率的IDE，想找一个更快更方便的工具，推荐你用IntelliJ IDEA。&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="https://jsxzswz.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>Java8十大新特性整理</title>
    <link href="https://jsxzswz.github.io/2019/01/04/blog20181210/"/>
    <id>https://jsxzswz.github.io/2019/01/04/blog20181210/</id>
    <published>2019-01-04T09:21:26.997Z</published>
    <updated>2019-01-04T09:21:26.997Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Java8已经发布很久了，毫无疑问，这是继java5之后一次重大的版本升级，这个版本包含语言、编译器、库、工具和JVM等方面的十多个新特性。有人认为，虽然这些新特性领Java开发人员十分期待，但同时也需要花不少精力去学习。因此，本文综合了一些资料，整理成一份关于Java 8新特性的参考教材，希望你有所收获。<br>本文中所用的实例请点击：<a href="https://github.com/jsxzswz/Java8Demo" target="_blank" rel="noopener">Java8新特性实例</a></p><a id="more"></a><h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>Lambda表达式的语法格式如下：<br><code>(parameters)-&gt;expression</code> 或 <code>(parameters)-&gt;{statements;}</code></p><p>以下是Lambda表达式的重要特征：</p><ul><li>可选类型声明：不需要声明参数类型，编译器可以统一识别参数值；</li><li>可选参数圆括号：一个参数无需定义圆括号，但多个参数需要定义圆括号；</li><li>可选的大括号：如果主体包含了一个语句，就不需要使用大括号；</li><li>可选的返回关键字：如果主体只有一个返回值则编译器会自动返主体回值，大括号需要指定表达式返回一个数值。</li></ul><p>使用Lambda表达式需要注意以下两点：</p><ul><li>使用Lambda表达式主要用来定义执行行内执行的方法类型接口，例如，一个简单方法接口。在上面例子中，我们使用各种类型的Lambda表达式来定义MathOperation接口的方法，然后我们定义了sayMessage的执行。</li><li>Lambda表达式免去了使用匿名方法的麻烦，并且给予Java简单但强大的函数化的编程能力。</li></ul><h3 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h3><p>注意点：</p><ul><li>Lambda表达式只能引用标记了 final 的外层局部变量，这就是说不能在lambda 内部修改定义在域外的局部变量，否则会编译错误。</li><li>Lambda表达式的局部变量可以不用声明为 final，但是必须不可被后面的代码修改（即隐性的具有final 的语义）</li><li>Lambda表达式当中不允许声明一个与局部变量同名的参数或者局部变量。</li></ul><h3 id="Lambda表达式实例"><a href="#Lambda表达式实例" class="headerlink" title="Lambda表达式实例"></a>Lambda表达式实例</h3><p>以下是Lambda的使用实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @Package: com.swz</span><br><span class="line"> * @Description: Lambda测试</span><br><span class="line"> * @author: swz</span><br><span class="line"> * @date: 2018/11/29 10:30</span><br><span class="line"> */</span><br><span class="line">public class LambdaTest &#123;</span><br><span class="line"></span><br><span class="line">    final static String salutation = &quot;Hello! &quot;;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        LambdaTest LambdaTest = new LambdaTest();</span><br><span class="line">        // 类型声明</span><br><span class="line">        MathOperation addition = (int a, int b) -&gt; a + b;</span><br><span class="line">        // 不用类型声明</span><br><span class="line">        MathOperation subtraction = (a, b) -&gt; a - b;</span><br><span class="line">        // 大括号中的返回值</span><br><span class="line">        MathOperation multiplication = (int a, int b) -&gt; &#123;</span><br><span class="line">            return a * b;</span><br><span class="line">        &#125;;</span><br><span class="line">        // 没有大括号及返回语句</span><br><span class="line">        MathOperation division = (int a, int b) -&gt; a / b;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;10 + 5 = &quot; + LambdaTest.operate(10, 5, addition));</span><br><span class="line">        System.out.println(&quot;10 - 5 = &quot; + LambdaTest.operate(10, 5, subtraction));</span><br><span class="line">        System.out.println(&quot;10 x 5 = &quot; + LambdaTest.operate(10, 5, multiplication));</span><br><span class="line">        System.out.println(&quot;10 / 5 = &quot; + LambdaTest.operate(10, 5, division));</span><br><span class="line"></span><br><span class="line">        // 不用括号</span><br><span class="line">        GreetingService greetService1 = message -&gt; System.out.println(&quot;Hello &quot; + message);</span><br><span class="line">        // 用括号</span><br><span class="line">        GreetingService greetService2 = (message) -&gt; System.out.println(salutation + message);</span><br><span class="line"></span><br><span class="line">        greetService1.sayMessage(&quot;Runoob&quot;);</span><br><span class="line">        greetService2.sayMessage(&quot;Google&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    interface MathOperation &#123;</span><br><span class="line">        int operatation(int a, int b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    interface GreetingService &#123;</span><br><span class="line">        void sayMessage(String message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private int operate(int a, int b, MathOperation mathOperation) &#123;</span><br><span class="line">        return mathOperation.operatation(a, b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Java8方法引用"><a href="#Java8方法引用" class="headerlink" title="Java8方法引用"></a>Java8方法引用</h2><p>方法引用通过方法的名字来指向一个方法。<br>方法引用可以使语言的构造更紧凑简洁，减少冗余代码。<br>方法引用使用一对冒号 :: 。</p><h3 id="方法引用实例"><a href="#方法引用实例" class="headerlink" title="方法引用实例"></a>方法引用实例</h3><p>以下是方法引用的使用实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @Package: com.swz</span><br><span class="line"> * @Description: 方法引用</span><br><span class="line"> * @author: swz</span><br><span class="line"> * @date: 2018/11/29 13:45</span><br><span class="line"> */</span><br><span class="line">public class MethodQuoteTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List names = new ArrayList&lt;&gt;();</span><br><span class="line">        names.add(&quot;Google&quot;);</span><br><span class="line">        names.add(&quot;SWZ&quot;);</span><br><span class="line">        names.add(&quot;taobao&quot;);</span><br><span class="line">        names.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Java8函数式接口"><a href="#Java8函数式接口" class="headerlink" title="Java8函数式接口"></a>Java8函数式接口</h2><p>函数式接口(FunctionalInterface)是一个有且仅有一个抽象方法，但可以有多个非抽象方法的接口。<br>函数式接口可以被隐式转换为Lambda表达式。<br>函数式接口可以现有的函数友好地支持Lambda。</p><h3 id="函数式接口实例"><a href="#函数式接口实例" class="headerlink" title="函数式接口实例"></a>函数式接口实例</h3><p>Predicate <t> 接口是一个函数式接口，它接受一个输入参数 T，返回一个布尔值结果。<br>该接口包含多种默认方法来将Predicate组合成其他复杂的逻辑（比如：与，或，非）。<br>该接口用于测试对象是 true 或 false。</t></p><p>以下是函数式接口的实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @Package: com.swz</span><br><span class="line"> * @Description: 函数式接口</span><br><span class="line"> * @author: swz</span><br><span class="line"> * @date: 2018/11/29 14:30</span><br><span class="line"> */</span><br><span class="line">public class FunctionalInterfaceTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9);</span><br><span class="line">        Predicate&lt;Integer&gt; predicate = n -&gt; n % 2 == 0;</span><br><span class="line">        // 传递参数 n</span><br><span class="line">        System.out.print(&quot;输出所有偶数: &quot;);</span><br><span class="line">        eval(list, predicate);</span><br><span class="line">        Predicate&lt;Integer&gt; predicate2 = n -&gt; n &gt; 3;</span><br><span class="line">        System.out.print(&quot;\n输出大于3的所有数字: &quot;);</span><br><span class="line">        eval(list, predicate2 );</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void eval(List&lt;Integer&gt; list, Predicate&lt;Integer&gt; predicate) &#123;</span><br><span class="line">        for (Integer i : list) &#123;</span><br><span class="line">            if (predicate.test(i)) &#123;</span><br><span class="line">                System.out.print(i + &quot; &quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Java8默认方法"><a href="#Java8默认方法" class="headerlink" title="Java8默认方法"></a>Java8默认方法</h2><ul><li>简单说，默认方法就是接口可以有实现方法，而且不需要实现类去实现其方法;</li><li>我们只需在方法名前面加个default关键字即可实现默认方法。</li><li>默认方法是为了解决接口的修改与现有的实现不兼容的问题。</li><li>另一个特性是接口可以声明（并且可以提供实现）静态方法</li></ul><h3 id="默认方法实例"><a href="#默认方法实例" class="headerlink" title="默认方法实例"></a>默认方法实例</h3><p>以下是默认方法的使用实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @Package: com.swz</span><br><span class="line"> * @Description: 默认方法</span><br><span class="line"> * @author: swz</span><br><span class="line"> * @date: 2018/11/29 15:01</span><br><span class="line"> */</span><br><span class="line">public class DefaultMethodTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Vehicle vehicle = new Car();</span><br><span class="line">        vehicle.print();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     interface Vehicle &#123;</span><br><span class="line">        default void print() &#123;</span><br><span class="line">            System.out.println(&quot;我是一辆车!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 静态方法</span><br><span class="line">        static void blowHorn() &#123;</span><br><span class="line">            System.out.println(&quot;按喇叭!!!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     interface FourWheeler &#123;</span><br><span class="line">        default void print() &#123;</span><br><span class="line">            System.out.println(&quot;我是一辆四轮车!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Car implements Vehicle, FourWheeler &#123;</span><br><span class="line"></span><br><span class="line">        //@Override</span><br><span class="line">        //public void print() &#123;</span><br><span class="line">        //    System.out.println(&quot;我是一辆四轮汽车!&quot;);</span><br><span class="line">        //&#125;</span><br><span class="line">        public void print() &#123;</span><br><span class="line">            Vehicle.super.print();</span><br><span class="line">            FourWheeler.super.print();</span><br><span class="line">            Vehicle.blowHorn();</span><br><span class="line">            System.out.println(&quot;我是一辆汽车!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Java8-流Stream"><a href="#Java8-流Stream" class="headerlink" title="Java8 流Stream"></a>Java8 流Stream</h2><p>Stream使用一种类似用SQL语句从数据库查询数据的直观方式来提供一种对Java集合运算和表达的高阶抽象;<br>Stream API可以极大提高Java程序员的生产力，让程序员写出高效率、干净、简洁的代码;<br>这种风格将要处理的元素集合看作一种流，流在管道中传输，并且可以在管道的节点上进行处理，比如筛选，排序，聚合等;<br>元素流在管道中经过中间操作（intermediate operation）的处理，最后由最终操作(terminal operation)得到前面处理的结果。</p><h3 id="什么是Stream"><a href="#什么是Stream" class="headerlink" title="什么是Stream"></a>什么是Stream</h3><p>Stream（流）是一个来自数据源的元素队列并支持聚合操作;</p><ul><li>元素：是特定类型的对象，形成一个队列。Java中的Stream并不会存储元素，而是按需计算;</li><li>数据源 ：流的来源。可以是集合，数组，I/O channel，产生器generator等;</li><li>聚合操作： 类似SQL语句一样的操作，比如filter, map, reduce, find,match, sorted等。</li></ul><h3 id="Stream流特征"><a href="#Stream流特征" class="headerlink" title="Stream流特征"></a>Stream流特征</h3><ul><li>Pipelining:：中间操作都会返回流对象本身。这样多个操作可以串联成一个管道，如同流式风格（fluent style）。<br>这样做可以对操作进行优化，比如延迟执行(laziness)和短路( short-circuiting)。</li><li>内部迭代：以前对集合遍历都是通过Iterator或者For-Each的方式,显式的在集合外部进行迭代，这叫做外部迭代。<br>Stream提供了内部迭代的方式，通过访问者模式(Visitor)实现。</li></ul><h3 id="Stream流实例"><a href="#Stream流实例" class="headerlink" title="Stream流实例"></a>Stream流实例</h3><p>以下是Stream流的使用实例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @Package: com.swz</span><br><span class="line"> * @Description: 流Stream</span><br><span class="line"> * @author: swz</span><br><span class="line"> * @date: 2018/11/29 15:17</span><br><span class="line"> */</span><br><span class="line">public class StreamTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        // stream() −为集合创建串行流。</span><br><span class="line">        // parallelStream() − 为集合创建并行流。</span><br><span class="line">        List&lt;String&gt; strings = Arrays.asList(&quot;abc&quot;, &quot;&quot;, &quot;bc&quot;, &quot;efg&quot;, &quot;&quot;, &quot;jkl&quot;);</span><br><span class="line">        List&lt;String&gt; filtered = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.toList());</span><br><span class="line">        System.out.println(filtered);</span><br><span class="line"></span><br><span class="line">        // Stream 提供了新的方法 &apos;forEach&apos; 来迭代流中的每个数据。以下代码片段使用forEach 输出了10个随机数</span><br><span class="line">        // limit 方法用于获取指定数量的流。以下代码片段使用 limit 方法打印出 10 条数据</span><br><span class="line">        // sorted 方法用于对流进行排序。以下代码片段使用 sorted 方法对输出的 10 个随机数进行排序</span><br><span class="line">        Random random = new Random();</span><br><span class="line">        random.ints().limit(10).sorted().forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">        // map 方法用于映射每个元素到对应的结果，以下代码片段使用 map 输出了元素对应的平方数：</span><br><span class="line">        List&lt;Integer&gt; numbers = Arrays.asList(3, 2, 3, 4, 3, 5);</span><br><span class="line">        List&lt;Integer&gt; squaresList  = numbers.stream().map(i -&gt;i*i).distinct().collect(Collectors.toList());</span><br><span class="line">        System.out.println(squaresList);</span><br><span class="line"></span><br><span class="line">        // filter 方法用于通过设置条件过滤出元素。以下代码片段使用filter 方法过滤出空字符串：</span><br><span class="line">        List&lt;String&gt; strings2 = Arrays.asList(&quot;abc&quot;, &quot;&quot;, &quot;bc&quot;, &quot;efg&quot;, &quot;abcd&quot;,&quot;&quot;, &quot;jkl&quot;);</span><br><span class="line">        // 获取空字符串的数量</span><br><span class="line">        int count = (int) strings2.stream().filter(string -&gt; string.isEmpty()).count();</span><br><span class="line">        System.out.println(count);</span><br><span class="line"></span><br><span class="line">        // Collectors 类实现了很多归约操作，例如将流转换成集合和聚合元素。Collectors可用于返回列表或字符串：</span><br><span class="line">        List&lt;String&gt; strings3 = Arrays.asList(&quot;abc&quot;, &quot;&quot;, &quot;bc&quot;, &quot;efg&quot;, &quot;abcd&quot;, &quot;&quot;, &quot;jkl&quot;);</span><br><span class="line">        List&lt;String&gt; filtered3 = strings3.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.toList());</span><br><span class="line">        System.out.println(&quot;筛选列表: &quot; + filtered3);</span><br><span class="line">        String mergedString = strings3.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.joining(&quot;, &quot;));</span><br><span class="line">        System.out.println(&quot;合并字符串: &quot; + mergedString);</span><br><span class="line">        // 一些产生统计结果的收集器也非常有用。它们主要用于int、double、long等基本类型上，它们可以用来产生类似如下的统计结果</span><br><span class="line">        List&lt;Integer&gt; numbers2 = Arrays.asList(3, 2, 2, 3, 7, 3, 5);</span><br><span class="line">        IntSummaryStatistics stats = numbers2.stream().mapToInt((x) -&gt; x).summaryStatistics();</span><br><span class="line">        System.out.println(&quot;列表中最大的数 : &quot; + stats.getMax());</span><br><span class="line">        System.out.println(&quot;列表中最小的数 : &quot; + stats.getMin());</span><br><span class="line">        System.out.println(&quot;所有数之和 : &quot; + stats.getSum());</span><br><span class="line">        System.out.println(&quot;平均数 : &quot; + stats.getAverage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @Package: com.swz</span><br><span class="line"> * @Description: 流Stream</span><br><span class="line"> * @author: swz</span><br><span class="line"> * @date: 2018/11/29 16:02</span><br><span class="line"> */</span><br><span class="line">public class Stream2Test &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String args[]) &#123;</span><br><span class="line">        System.out.println(&quot;使用 Java 7: &quot;);</span><br><span class="line">        // 计算空字符串</span><br><span class="line">        List&lt;String&gt; strings = Arrays.asList(&quot;abc&quot;, &quot;&quot;, &quot;bc&quot;, &quot;efg&quot;, &quot;abcd&quot;, &quot;&quot;, &quot;jkl&quot;);</span><br><span class="line">        System.out.println(&quot;列表: &quot; + strings);</span><br><span class="line">        long count = getCountEmptyStringUsingJava7(strings);</span><br><span class="line">        System.out.println(&quot;空字符数量为: &quot; + count);</span><br><span class="line">        count = getCountLength3UsingJava7(strings);</span><br><span class="line">        System.out.println(&quot;字符串长度为 3 的数量为: &quot; + count);</span><br><span class="line">        // 删除空字符串</span><br><span class="line">        List&lt;String&gt; filtered = deleteEmptyStringsUsingJava7(strings);</span><br><span class="line">        System.out.println(&quot;筛选后的列表: &quot; + filtered);</span><br><span class="line">        // 删除空字符串，并使用逗号把它们合并起来</span><br><span class="line">        String mergedString = getMergedStringUsingJava7(strings, &quot;, &quot;);</span><br><span class="line">        System.out.println(&quot;合并字符串: &quot; + mergedString);</span><br><span class="line">        List&lt;Integer&gt; numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5);</span><br><span class="line">        // 获取列表元素平方数</span><br><span class="line">        List&lt;Integer&gt; squaresList = getSquares(numbers);</span><br><span class="line">        System.out.println(&quot;平方数列表: &quot; + squaresList);</span><br><span class="line">        List&lt;Integer&gt; integers = Arrays.asList(1, 2, 13, 4, 15, 6, 17, 8, 19);</span><br><span class="line">        System.out.println(&quot;列表: &quot; + integers);</span><br><span class="line">        System.out.println(&quot;列表中最大的数 : &quot; + getMax(integers));</span><br><span class="line">        System.out.println(&quot;列表中最小的数 : &quot; + getMin(integers));</span><br><span class="line">        System.out.println(&quot;所有数之和 : &quot; + getSum(integers));</span><br><span class="line">        System.out.println(&quot;平均数 : &quot; + getAverage(integers));</span><br><span class="line">        System.out.println(&quot;随机数: &quot;);</span><br><span class="line">        // 输出10个随机数</span><br><span class="line">        Random random = new Random();</span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            System.out.println(random.nextInt());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;使用 Java 8: &quot;);</span><br><span class="line">        System.out.println(&quot;列表: &quot; + strings);</span><br><span class="line">        count = strings.stream().filter(string -&gt; string.isEmpty()).count();</span><br><span class="line">        System.out.println(&quot;空字符串数量为: &quot; + count);</span><br><span class="line">        count = strings.stream().filter(string -&gt; string.length() == 3).count();</span><br><span class="line">        System.out.println(&quot;字符串长度为 3 的数量为: &quot; + count);</span><br><span class="line">        filtered = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.toList());</span><br><span class="line">        System.out.println(&quot;筛选后的列表: &quot; + filtered);</span><br><span class="line">        mergedString = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.joining(&quot;, &quot;));</span><br><span class="line">        System.out.println(&quot;合并字符串: &quot; + mergedString);</span><br><span class="line">        squaresList = numbers.stream().map(i -&gt; i * i).distinct().collect(Collectors.toList());</span><br><span class="line">        System.out.println(&quot;Squares List: &quot; + squaresList);</span><br><span class="line">        System.out.println(&quot;列表: &quot; + integers);</span><br><span class="line">        IntSummaryStatistics stats = integers.stream().mapToInt((x) -&gt; x).summaryStatistics();</span><br><span class="line">        System.out.println(&quot;列表中最大的数 : &quot; + stats.getMax());</span><br><span class="line">        System.out.println(&quot;列表中最小的数 : &quot; + stats.getMin());</span><br><span class="line">        System.out.println(&quot;所有数之和 : &quot; + stats.getSum());</span><br><span class="line">        System.out.println(&quot;平均数 : &quot; + stats.getAverage());</span><br><span class="line">        System.out.println(&quot;随机数: &quot;);</span><br><span class="line">        random.ints().limit(10).sorted().forEach(System.out::println);</span><br><span class="line">        // 并行处理</span><br><span class="line">        count = strings.parallelStream().filter(string -&gt; string.isEmpty()).count();</span><br><span class="line">        System.out.println(&quot;空字符串的数量为: &quot; + count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static int getCountEmptyStringUsingJava7(List&lt;String&gt; strings) &#123;</span><br><span class="line">        int count = 0;</span><br><span class="line">        for (String string : strings) &#123;</span><br><span class="line">            if (string.isEmpty()) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static int getCountLength3UsingJava7(List&lt;String&gt; strings) &#123;</span><br><span class="line">        int count = 0;</span><br><span class="line">        for (String string : strings) &#123;</span><br><span class="line">            if (string.length() == 3) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static List&lt;String&gt; deleteEmptyStringsUsingJava7(List&lt;String&gt; strings) &#123;</span><br><span class="line">        List&lt;String&gt; filteredList = new ArrayList&lt;String&gt;();</span><br><span class="line">        for (String string : strings) &#123;</span><br><span class="line">            if (!string.isEmpty()) &#123;</span><br><span class="line">                filteredList.add(string);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return filteredList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static String getMergedStringUsingJava7(List&lt;String&gt; strings, String separator) &#123;</span><br><span class="line">        StringBuilder stringBuilder = new StringBuilder();</span><br><span class="line">        for (String string : strings) &#123;</span><br><span class="line">            if (!string.isEmpty()) &#123;</span><br><span class="line">                stringBuilder.append(string);</span><br><span class="line">                stringBuilder.append(separator);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        String mergedString = stringBuilder.toString();</span><br><span class="line">        return mergedString.substring(0, mergedString.length() - 2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static List&lt;Integer&gt; getSquares(List&lt;Integer&gt; numbers) &#123;</span><br><span class="line">        List&lt;Integer&gt; squaresList = new ArrayList&lt;Integer&gt;();</span><br><span class="line">        for (Integer number : numbers) &#123;</span><br><span class="line">            Integer square = new Integer(number.intValue() * number.intValue());</span><br><span class="line">            if (!squaresList.contains(square)) &#123;</span><br><span class="line">                squaresList.add(square);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return squaresList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static int getMax(List&lt;Integer&gt; numbers) &#123;</span><br><span class="line">        int max = numbers.get(0);</span><br><span class="line">        for (int i = 1; i &lt; numbers.size(); i++) &#123;</span><br><span class="line">            Integer number = numbers.get(i);</span><br><span class="line">            if (number.intValue() &gt; max) &#123;</span><br><span class="line">                max = number.intValue();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static int getMin(List&lt;Integer&gt; numbers) &#123;</span><br><span class="line">        int min = numbers.get(0);</span><br><span class="line">        for (int i = 1; i &lt; numbers.size(); i++) &#123;</span><br><span class="line">            Integer number = numbers.get(i);</span><br><span class="line">            if (number.intValue() &lt; min) &#123;</span><br><span class="line">                min = number.intValue();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return min;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static int getSum(List numbers) &#123;</span><br><span class="line">        int sum = (int) (numbers.get(0));</span><br><span class="line">        for (int i = 1; i &lt; numbers.size(); i++) &#123;</span><br><span class="line">            sum += (int) numbers.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static int getAverage(List&lt;Integer&gt; numbers) &#123;</span><br><span class="line">        return getSum(numbers) / numbers.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Java-8-Optional-类"><a href="#Java-8-Optional-类" class="headerlink" title="Java 8 Optional 类"></a>Java 8 Optional 类</h2><p>Optional类是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象；<br>Optional十个容器：它可以保存类型为T的值，或仅仅保存null；<br>Optional类的引入很好的解决空指针异常。</p><h3 id="类声明"><a href="#类声明" class="headerlink" title="类声明"></a>类声明</h3><p>以下是一个 java.util.Optional<t> 类的声明：<br><code>publicfinalclassOptional&lt;T&gt; extendsObject</code></t></p><h3 id="Optional实例"><a href="#Optional实例" class="headerlink" title="Optional实例"></a>Optional实例</h3><p>以下是Optional的使用实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @Package: com.swz</span><br><span class="line"> * @Description: Optional类</span><br><span class="line"> * @author: swz</span><br><span class="line"> * @date: 2018/11/30 11:25</span><br><span class="line"> */</span><br><span class="line">public class OptionalTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        OptionalTest optionalTest = new OptionalTest();</span><br><span class="line">        Integer value1 = null;</span><br><span class="line">        Integer value2 = new Integer(10);</span><br><span class="line">        // 允许传递为 null 参数</span><br><span class="line">        Optional&lt;Integer&gt; a = Optional.ofNullable(value1);</span><br><span class="line">        // 如果传递的参数是 null，抛出异常 NullPointerException</span><br><span class="line">        Optional&lt;Integer&gt; b = Optional.of(value2);</span><br><span class="line">        System.out.println(optionalTest.sum(a, b));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer sum(Optional&lt;Integer&gt; a, Optional&lt;Integer&gt; b) &#123;</span><br><span class="line">        // 判断值是否存在</span><br><span class="line">        System.out.println(&quot;第一个参数值存在： &quot; + a.isPresent());</span><br><span class="line">        System.out.println(&quot;第二个参数值存在： &quot; + b.isPresent());</span><br><span class="line">        // 如果值存在，返回它，否则返回默认值</span><br><span class="line">        Integer value1 = a.orElse(new Integer(0));</span><br><span class="line">        Integer value2 = b.get();</span><br><span class="line">        return value1 + value2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Java8-Nashorn-JavaScript"><a href="#Java8-Nashorn-JavaScript" class="headerlink" title="Java8 Nashorn JavaScript"></a>Java8 Nashorn JavaScript</h2><ul><li>Nashorn 一个 javascript 引擎。<br>从JDK1.8开始，Nashorn取代Rhino(JDK 1.6, JDK1.7)成为Java的嵌入式JavaScript引擎。Nashorn完全支持ECMAScript 5.1规范以及一些扩展。它使用基于JSR292的新语言特性，其中包含在JDK 7中引入的 invokedynamic，将JavaScript编译成Java字节码。与先前的Rhino实现相比，这带来了2到10倍的性能提升。</li><li>jjs是个基于Nashorn引擎的命令行工具。它接受一些JavaScript源代码为参数，并且执行这些源代码</li><li>使用ScriptEngineManager, JavaScript 代码可以在 Java 中执行</li></ul><h3 id="Nashorn实例"><a href="#Nashorn实例" class="headerlink" title="Nashorn实例"></a>Nashorn实例</h3><p>以下是Nashorn的使用实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @Package: com.swz</span><br><span class="line"> * @Description: Nashorn, javascript 引擎。</span><br><span class="line"> * @author: swz</span><br><span class="line"> * @date: 2018/11/30 14:11</span><br><span class="line"> */</span><br><span class="line">public class NashornTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        ScriptEngineManager scriptEngineManager = new ScriptEngineManager();</span><br><span class="line">        ScriptEngine nashorn = scriptEngineManager.getEngineByName(&quot;nashorn&quot;);</span><br><span class="line">        String name = &quot;Runoob&quot;;</span><br><span class="line">        Integer result = null;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            nashorn.eval(&quot;print(&apos;&quot; + name + &quot;&apos;)&quot;);</span><br><span class="line">            result = (Integer) nashorn.eval(&quot;10 + 2&quot;);</span><br><span class="line">        &#125; catch (ScriptException e) &#123;</span><br><span class="line">            System.out.println(&quot;执行脚本错误: &quot; + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(result.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Java8-日期时间API"><a href="#Java8-日期时间API" class="headerlink" title="Java8 日期时间API"></a>Java8 日期时间API</h2><p>在旧版的Java 中，日期时间API 存在诸多问题:</p><ul><li>非线程安全 − java.util.Date 是非线程安全的，所有的日期类都是可变的，这是Java日期类最大的问题之一;</li><li>设计很差 − Java的日期/时间类的定义并不一致，在java.util和java.sql的包中都有日期类;</li><li>时区处理麻烦 − 日期类并不提供国际化，没有时区支持;</li></ul><p>Java 8 在 java.time 包下提供了很多新的 API:</p><ul><li>Local(本地) − 简化了日期时间的处理，没有时区的问题;</li><li>Zoned(时区) − 通过制定的时区处理日期时间;</li><li>新的java.time包涵盖了所有处理日期，时间，日期/时间，时区，时刻（instants），过程（during）与时钟（clock）的操作.</li></ul><h3 id="日期时间实例"><a href="#日期时间实例" class="headerlink" title="日期时间实例"></a>日期时间实例</h3><p>以下是日期时间的使用实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @Package: com.swz</span><br><span class="line"> * @Description: 日期时间API</span><br><span class="line"> * @author: swz</span><br><span class="line"> * @date: 2018/11/30 14:23</span><br><span class="line"> */</span><br><span class="line">public class DateTimeTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        // LocalDate/LocalTime 和 LocalDateTime 类可以在处理时区不是必须的情况</span><br><span class="line">        DateTimeTest dateTimeTest = new DateTimeTest();</span><br><span class="line">        dateTimeTest.testLocalDateTime();</span><br><span class="line">        // 如果我们需要考虑到时区，就可以使用时区的日期时间API</span><br><span class="line">        dateTimeTest.testZonedDateTime();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void testLocalDateTime() &#123;</span><br><span class="line">        // 获取当前的日期时间</span><br><span class="line">        LocalDateTime localDateTime = LocalDateTime.now();</span><br><span class="line">        System.out.println(&quot;当前时间：&quot; + localDateTime);</span><br><span class="line">        LocalDate localDate = localDateTime.toLocalDate();</span><br><span class="line">        System.out.println(&quot;localDate:&quot; + localDate);</span><br><span class="line">        Month month = localDateTime.getMonth();</span><br><span class="line">        int day = localDateTime.getDayOfMonth();</span><br><span class="line">        int hours = localDateTime.getHour();</span><br><span class="line">        int minutes = localDateTime.getMinute();</span><br><span class="line">        int seconds = localDateTime.getSecond();</span><br><span class="line">        System.out.println(&quot;月：&quot; + month + &quot;,日: &quot; + day + &quot;,时：&quot; + hours + &quot;,分：&quot; + minutes + &quot;,秒: &quot; + seconds);</span><br><span class="line"></span><br><span class="line">        LocalDateTime localDateTime1 = localDateTime.withDayOfMonth(10).withYear(2018);</span><br><span class="line">        System.out.println(&quot;localDateTime1:&quot; + localDateTime1);</span><br><span class="line">        // 2018-11-28</span><br><span class="line">        LocalDate localDate1 = LocalDate.of(2018, Month.NOVEMBER, 28);</span><br><span class="line">        System.out.println(&quot;localDate1:&quot; + localDate1);</span><br><span class="line">        // 22:35</span><br><span class="line">        LocalTime localTime = LocalTime.of(22, 30);</span><br><span class="line">        System.out.println(&quot;localTime:&quot; + localTime);</span><br><span class="line">        // 解析字符串</span><br><span class="line">        LocalTime localTime1 = LocalTime.parse(&quot;22:35:24&quot;);</span><br><span class="line">        System.out.println(&quot;localTime1&quot; + localTime1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void testZonedDateTime() &#123;</span><br><span class="line">        // 获取当前时间日期</span><br><span class="line">        ZonedDateTime date1 = ZonedDateTime.parse(&quot;2015-12-03T10:15:30+05:30[Asia/Shanghai]&quot;);</span><br><span class="line">        System.out.println(&quot;date1: &quot; + date1);</span><br><span class="line">        ZoneId id = ZoneId.of(&quot;Europe/Paris&quot;);</span><br><span class="line">        System.out.println(&quot;ZoneId: &quot; + id);</span><br><span class="line">        ZoneId currentZone = ZoneId.systemDefault();</span><br><span class="line">        System.out.println(&quot;当期时区: &quot; + currentZone);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Java8-Base64"><a href="#Java8-Base64" class="headerlink" title="Java8 Base64"></a>Java8 Base64</h2><p>Base64编码已经成为Java类库的标准；<br>Java8 内置了 Base64 编码的编码器和解码器<br>Base64工具类提供了一套静态方法获取下面三种BASE64编解码器：</p><ul><li>基本：输出被映射到一组字符A-Za-z0-9+/，编码不添加任何行标，输出的解码仅支持A-Za-z0-9+/;</li><li>URL：输出映射到一组字符A-Za-z0-9+_，输出是URL和文件;</li><li>MIME：输出隐射到MIME友好格式。输出每行不超过76字符，并且使用’\r’并跟随’\n’作为分割。编码输出最后没有行分割</li></ul><h3 id="Base64实例"><a href="#Base64实例" class="headerlink" title="Base64实例"></a>Base64实例</h3><p>以下是Base64的使用实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @Package: com.swz</span><br><span class="line"> * @Description: Base64编码</span><br><span class="line"> * @author: swz</span><br><span class="line"> * @date: 2018/11/30 14:56</span><br><span class="line"> */</span><br><span class="line">public class Base64Test &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            // 使用基本编码</span><br><span class="line">            String base64encodedString = Base64.getEncoder().encodeToString(&quot;runoob?java8&quot;.getBytes(&quot;utf-8&quot;));</span><br><span class="line">            System.out.println(&quot;Base64编码字符串(基本)：&quot; + base64encodedString);</span><br><span class="line">            // 解码</span><br><span class="line">            byte[] base64decodedBytes = Base64.getDecoder().decode(base64encodedString);</span><br><span class="line">            System.out.println(&quot;原始字符串: &quot; + new String(base64decodedBytes, &quot;utf-8&quot;));</span><br><span class="line">            // 使用URL编码</span><br><span class="line">            base64encodedString = Base64.getUrlEncoder().encodeToString(&quot;TutorialsPoint?java8&quot;.getBytes(&quot;utf-8&quot;));</span><br><span class="line">            System.out.println(&quot;Base64 编码字符串 (URL) :&quot; + base64encodedString);</span><br><span class="line">            // 使用MIME编码</span><br><span class="line">            StringBuilder stringBuilder = new StringBuilder();</span><br><span class="line">            for (int i = 0; i &lt; 10; ++i) &#123;</span><br><span class="line">                stringBuilder.append(UUID.randomUUID().toString());</span><br><span class="line">            &#125;</span><br><span class="line">            byte[] mimeBytes = stringBuilder.toString().getBytes(&quot;utf-8&quot;);</span><br><span class="line">            String mimeEncodedString = Base64.getMimeEncoder().encodeToString(mimeBytes);</span><br><span class="line">            System.out.println(&quot;Base64 编码字符串 (MIME) :&quot; + mimeEncodedString);</span><br><span class="line">        &#125; catch (UnsupportedEncodingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="重复注解-RepeatingAnnotationTest"><a href="#重复注解-RepeatingAnnotationTest" class="headerlink" title="重复注解-RepeatingAnnotationTest"></a>重复注解-RepeatingAnnotationTest</h2><p>以下是重复注解的使用实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @Package: com.swz</span><br><span class="line"> * @Description: 重复注解，拓宽注解的应用场景</span><br><span class="line"> * @author: swz</span><br><span class="line"> * @date: 2018/11/30 15:18</span><br><span class="line"> */</span><br><span class="line">public class RepeatingAnnotationTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for( Filter filter: Filterable.class.getAnnotationsByType( Filter.class ) ) &#123;</span><br><span class="line">            System.out.println( filter.value() );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Target( ElementType.TYPE )</span><br><span class="line">    @Retention( RetentionPolicy.RUNTIME )</span><br><span class="line">    public @interface Filters &#123;</span><br><span class="line">        Filter[] value();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Target( ElementType.TYPE )</span><br><span class="line">    @Retention( RetentionPolicy.RUNTIME )</span><br><span class="line">    @Repeatable( Filters.class )</span><br><span class="line">    public @interface Filter &#123;</span><br><span class="line">        String value();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Filter( &quot;filter1&quot; )</span><br><span class="line">    @Filter( &quot;filter2&quot; )</span><br><span class="line">    public interface Filterable &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Java8已经发布很久了，毫无疑问，这是继java5之后一次重大的版本升级，这个版本包含语言、编译器、库、工具和JVM等方面的十多个新特性。有人认为，虽然这些新特性领Java开发人员十分期待，但同时也需要花不少精力去学习。因此，本文综合了一些资料，整理成一份关于Java 8新特性的参考教材，希望你有所收获。&lt;br&gt;本文中所用的实例请点击：&lt;a href=&quot;https://github.com/jsxzswz/Java8Demo&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Java8新特性实例&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="https://jsxzswz.github.io/categories/java/"/>
    
    
      <category term="java" scheme="https://jsxzswz.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Mysql常用函数</title>
    <link href="https://jsxzswz.github.io/2019/01/04/blog20181207/"/>
    <id>https://jsxzswz.github.io/2019/01/04/blog20181207/</id>
    <published>2019-01-04T09:21:26.995Z</published>
    <updated>2019-01-04T09:21:26.995Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文章描述"><a href="#文章描述" class="headerlink" title="文章描述"></a>文章描述</h2><p>以下是对mysql中的常用函数进行了汇总介绍。需要的朋友可以过来参考下。</p><a id="more"></a><h2 id="数字函数"><a href="#数字函数" class="headerlink" title="数字函数"></a>数字函数</h2><table><thead><tr><th style="text-align:left">函数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">ABS(x)</td><td style="text-align:left">返回x的绝对值</td></tr><tr><td style="text-align:left">BIN(x)</td><td style="text-align:left">返回x的二进制（OCT-八进制，HEX-十六进制）</td></tr><tr><td style="text-align:left">CEILING(x)</td><td style="text-align:left">返回大于x的最小整数值</td></tr><tr><td style="text-align:left">EXP(x)</td><td style="text-align:left">返回值e（自然对数的底）的x次方</td></tr><tr><td style="text-align:left">FLOOR(x)</td><td style="text-align:left">返回小于x的最大整数值</td></tr><tr><td style="text-align:left">GREATEST(x1…,xn)</td><td style="text-align:left">返回集合中最大的值</td></tr><tr><td style="text-align:left">LEAST(x1…,xn)</td><td style="text-align:left">返回集合中最小的值</td></tr><tr><td style="text-align:left">LN(x)</td><td style="text-align:left">返回x的自然对数</td></tr><tr><td style="text-align:left">LOG(x,y)</td><td style="text-align:left">返回x的以y为底的对数</td></tr><tr><td style="text-align:left">MOD(x,y)</td><td style="text-align:left">返回x的以y为底的对数</td></tr><tr><td style="text-align:left">RAND()</td><td style="text-align:left">随机数生成器生成一个指定的值</td></tr><tr><td style="text-align:left">ROUND(x,y)</td><td style="text-align:left">返回参数x的四舍五入的有y位小数的值</td></tr><tr><td style="text-align:left">SIGN(x)</td><td style="text-align:left">返回代表数字x的符号的值</td></tr><tr><td style="text-align:left">SQRT(x)</td><td style="text-align:left">返回一个数的平方根</td></tr><tr><td style="text-align:left">TRUNCATE(x,y)</td><td style="text-align:left">返回数字x截短为y位小数的结果</td></tr></tbody></table><h2 id="聚合函数-常用于GROUP-BY从句的SELECT查询中"><a href="#聚合函数-常用于GROUP-BY从句的SELECT查询中" class="headerlink" title="聚合函数(常用于GROUP BY从句的SELECT查询中)"></a>聚合函数(常用于GROUP BY从句的SELECT查询中)</h2><table><thead><tr><th style="text-align:left">函数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">AVG(col)</td><td style="text-align:left">返回指定列的平均值</td></tr><tr><td style="text-align:left">COUNT(col)</td><td style="text-align:left">返回指定列中非NULL值的个数</td></tr><tr><td style="text-align:left">MIN(col)</td><td style="text-align:left">返回指定列的最小值</td></tr><tr><td style="text-align:left">MAX(col)</td><td style="text-align:left">返回指定列的最大值</td></tr><tr><td style="text-align:left">SUM(col)</td><td style="text-align:left">返回指定列的所有值之和</td></tr><tr><td style="text-align:left">GROUP_CONCAT(col)</td><td style="text-align:left">返回由属于一组的列值连接组合而成的结果</td></tr></tbody></table><h2 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h2><table><thead><tr><th style="text-align:left">函数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">ASCII(char)</td><td style="text-align:left">返回字符的ASCII码值</td></tr><tr><td style="text-align:left">BIT_LENGTH(str)</td><td style="text-align:left">返回字符串的比特长度</td></tr><tr><td style="text-align:left">CONCAT(s1,s2…,sn)</td><td style="text-align:left">将s1,s2…,sn连接成字符串</td></tr><tr><td style="text-align:left">CONCAT_WS(sep,s1,s2…,sn)</td><td style="text-align:left">将s1,s2…,sn连接成字符串，并用sep字符间隔</td></tr><tr><td style="text-align:left">LCASE(str)/LOWER(str)</td><td style="text-align:left">返回将字符串str中所有字符改变为小写后的结果</td></tr><tr><td style="text-align:left">LEFT(str,x)</td><td style="text-align:left">返回字符串str中最左边的x个字符</td></tr><tr><td style="text-align:left">LTRIM(str)</td><td style="text-align:left">从字符串str中切掉开头的空格</td></tr><tr><td style="text-align:left">POSITION(substr,str)</td><td style="text-align:left">substr在字符串str中第一次出现的位置</td></tr><tr><td style="text-align:left">QUOTE(str)</td><td style="text-align:left">用反斜杠转义str中的单引号</td></tr><tr><td style="text-align:left">REPEAT(str,srchstr,rplcstr)</td><td style="text-align:left">返回字符串str重复x次的结果</td></tr><tr><td style="text-align:left">REVERSE(str)</td><td style="text-align:left">返回颠倒字符串str的结果</td></tr><tr><td style="text-align:left">RIGHT(str,x)</td><td style="text-align:left">返回字符串str中最右边的x个字符</td></tr><tr><td style="text-align:left">RTRIM(str)</td><td style="text-align:left">返回字符串str尾部的空格</td></tr><tr><td style="text-align:left">STRCMP(s1,s2)</td><td style="text-align:left">比较字符串s1和s2</td></tr><tr><td style="text-align:left">TRIM(str)</td><td style="text-align:left">去除字符串首部和尾部的所有空格</td></tr><tr><td style="text-align:left">UCASE(str)/ UPPER(str)</td><td style="text-align:left">去除字符串首部和尾部的所有空格</td></tr></tbody></table><h2 id="日期和时间函数"><a href="#日期和时间函数" class="headerlink" title="日期和时间函数"></a>日期和时间函数</h2><table><thead><tr><th style="text-align:left">函数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">CURDATE()/CURRENT_DATE()</td><td style="text-align:left">返回当前的日期</td></tr><tr><td style="text-align:left">CURTIME()/CURRENT_TIME()</td><td style="text-align:left">返回当前的时间</td></tr><tr><td style="text-align:left">DATE_FORMAT(date,fmt)</td><td style="text-align:left">依照指定的fmt格式格式化日期date值</td></tr><tr><td style="text-align:left">DAYOFWEEK(date)</td><td style="text-align:left">返回date所代表的一星期中的第几天(1~7)</td></tr><tr><td style="text-align:left">DAYOFMONTH(date)</td><td style="text-align:left">返回date是一个月的第几天(1~31)</td></tr><tr><td style="text-align:left">DAYOFYEAR(date)</td><td style="text-align:left">返回date是一年的第几天(1~366)</td></tr><tr><td style="text-align:left">FROM_UNIXTIME(ts,fmt)</td><td style="text-align:left">根据指定的fmt格式，格式化UNIX时间戳ts</td></tr><tr><td style="text-align:left">UNIX_TIMESTAMP(date)</td><td style="text-align:left">把字符串日期转成时间戳</td></tr><tr><td style="text-align:left">NOW()</td><td style="text-align:left">返回当前的日期和时间</td></tr><tr><td style="text-align:left">WEEK(date)</td><td style="text-align:left">返回日期date为一年中第几周(0~53)</td></tr><tr><td style="text-align:left">YEAR(date)</td><td style="text-align:left">返回日期date的年份(1000~9999)</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT FROM_UNIXTIME(UNIX_TIMESTAMP());</span><br><span class="line">SELECT EXTRACT(YEAR_MONTH FROM CURRENT_DATE);</span><br><span class="line">SELECT EXTRACT(DAY_SECOND FROM CURRENT_DATE);</span><br><span class="line">SELECT EXTRACT(HOUR_MINUTE FROM CURRENT_DATE);</span><br></pre></td></tr></table></figure><h2 id="系统信息函数"><a href="#系统信息函数" class="headerlink" title="系统信息函数"></a>系统信息函数</h2><table><thead><tr><th style="text-align:left">函数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">DATABASE()</td><td style="text-align:left">返回当前数据库名</td></tr><tr><td style="text-align:left">BENCHMARK(count,expr)</td><td style="text-align:left">返回当前的时间</td></tr><tr><td style="text-align:left">CONNECTION_ID()</td><td style="text-align:left">返回当前客户的连接ID</td></tr><tr><td style="text-align:left">FOUND_ROWS()</td><td style="text-align:left">返回最后一个SELECT查询进行检索的总行数</td></tr><tr><td style="text-align:left">USER()/SYSTEM_USER()</td><td style="text-align:left">返回当前登陆用户名</td></tr><tr><td style="text-align:left">VERSION()</td><td style="text-align:left">返回MySQL服务器的版本</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SELECT id , `customer_name` , sex , LEFT(telephone,3) ,USER(),RAND(),WEEK(now()) ,SQRT(4) ,CONCAT(telephone,&apos;-&apos;,id),LOWER(&apos;abc&apos;), CURRENT_TIME(),UNIX_TIMESTAMP(now()),</span><br><span class="line">CASE</span><br><span class="line">WHEN sex = 1 THEN &apos;男&apos;</span><br><span class="line">WHEN sex = 2 THEN &apos;女&apos;</span><br><span class="line">else &apos;保密&apos;</span><br><span class="line">END AS sex</span><br><span class="line">FROM customer_demand</span><br><span class="line">ORDER BY id DESC</span><br><span class="line">LIMIT 10</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>前几天在看一本sql学习指南 是关于sql语句的介绍 书中主要针对mysql进行讲解 这几天有空 总结上常用的mysql函数 以便日后用到学习。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;文章描述&quot;&gt;&lt;a href=&quot;#文章描述&quot; class=&quot;headerlink&quot; title=&quot;文章描述&quot;&gt;&lt;/a&gt;文章描述&lt;/h2&gt;&lt;p&gt;以下是对mysql中的常用函数进行了汇总介绍。需要的朋友可以过来参考下。&lt;/p&gt;
    
    </summary>
    
      <category term="数据库" scheme="https://jsxzswz.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="mysql" scheme="https://jsxzswz.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Oracle常用函数</title>
    <link href="https://jsxzswz.github.io/2019/01/04/blog20181206/"/>
    <id>https://jsxzswz.github.io/2019/01/04/blog20181206/</id>
    <published>2019-01-04T09:21:26.993Z</published>
    <updated>2019-01-04T09:21:26.994Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一篇鸡肋文章"><a href="#一篇鸡肋文章" class="headerlink" title="一篇鸡肋文章"></a>一篇鸡肋文章</h2><p>在平时写PL/SQL的时候，经常要用到很多系统自带的函数，而这些函数用起来非常好用，但是每次用完以后，就又忘到脑后了，为了加深自己的印象，以及对这些函数做一个全面的总结，就有了今天这篇文章。</p><p>首先这就是一个网上总结烂了的主题。我还要总结，权当自己的学习总结。总结这篇文章时也参考了网上他人总结的文章，如果不喜、勿喷。</p><p>作为一篇“鸡肋”文章，弃之如可惜，食之无所得。读者就当一“乐呵”就好了。有钱的捧个钱场，没钱的捧个人场。</p><a id="more"></a><h2 id="常用字符函数"><a href="#常用字符函数" class="headerlink" title="常用字符函数"></a>常用字符函数</h2><p>在编写PL/SQL程序时，或多或少的需要进行字符串操作，进行字符串操作又离不开以下的这些函数。</p><table><thead><tr><th style="text-align:left">函数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">LOWER(char)</td><td style="text-align:left">将字符串表达式char中的所有大写字母转换为小写字母</td></tr><tr><td style="text-align:left">UPPER(char)</td><td style="text-align:left">将字符串表达式char中的所有小写字母转换为大写字母</td></tr><tr><td style="text-align:left">INITCAP(char)</td><td style="text-align:left">首字母转换成大写</td></tr><tr><td style="text-align:left">SUBSTR(char, start, length)</td><td style="text-align:left">返回字符串表达式char中从第start开始的length个字符</td></tr><tr><td style="text-align:left">LENGTH(char)</td><td style="text-align:left">返回字符串表达式char的长度</td></tr><tr><td style="text-align:left">ASCII(char)</td><td style="text-align:left">取char的ASCII值</td></tr><tr><td style="text-align:left">CHR(number)</td><td style="text-align:left">取number的ASCII值</td></tr><tr><td style="text-align:left">REPLACE(char,search_str[,replacement_str])</td><td style="text-align:left">将字符串char中的子串search_str替换成replacement_str；如果search_str=null，返回char；如果replacement_str=null，则会去掉char中的search_str</td></tr><tr><td style="text-align:left">INSTR(char1,char2[,n[,m]])</td><td style="text-align:left">获取子串char2在字符串char1中的位置。n为其实搜索位置，m为子串出现的次数；n为负，则从尾部开始搜索；n\m默认为1</td></tr><tr><td style="text-align:left">LPAD(char1,n,char2)</td><td style="text-align:left">在字符串char1的左端填充字符串char2直到长度达到n;char2默认为空格，如果char1.length&gt;n，则返回char1左端的n个字符</td></tr><tr><td style="text-align:left">RPAD(char1,n,char2)</td><td style="text-align:left">在字符串char1的右端填充字符串char2直到长度达到n;char2默认为空格，如果char1.length&gt;n，则返回char1左端的n个字符</td></tr><tr><td style="text-align:left">LTRIM(char1[,set])</td><td style="text-align:left">去掉字符串char1左端包含的set中的任意字符</td></tr><tr><td style="text-align:left">RTRIM(char1[,set])</td><td style="text-align:left">去掉字符串char1右端包含的set中的任意字符</td></tr><tr><td style="text-align:left">TRIM(char &#124; char From string)</td><td style="text-align:left">从字符串的头尾或者两端截断特定字符</td></tr><tr><td style="text-align:left">CONCAT(str1,str2)</td><td style="text-align:left">连接字符串，同 &#124;&#124; 的作用一样</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">-- LOWER测试</span><br><span class="line">select LOWER(&apos;HTTP://WWW.JELLYTHINK.COM&apos;) from dual; -- http://www.jellythink.com</span><br><span class="line"></span><br><span class="line">-- UPPER测试</span><br><span class="line">select UPPER(&apos;http://www.jellythink.com&apos;) from dual; -- HTTP://WWW.JELLYTHINK.COM</span><br><span class="line"></span><br><span class="line">-- INITCAP测试</span><br><span class="line">select INITCAP(&apos;jelly think&apos;) from dual; -- Jelly Think</span><br><span class="line"></span><br><span class="line">-- SUBSTR测试</span><br><span class="line">select SUBSTR(&apos;http://www.jellythink.com&apos;, 12, 10) from dual; -- jellythink(注：下标从1开始)</span><br><span class="line"></span><br><span class="line">-- LENGTH测试</span><br><span class="line">select LENGTH(&apos;JellyThink&apos;) from dual; -- 10</span><br><span class="line"></span><br><span class="line">-- ASCII测试</span><br><span class="line">select ASCII(&apos;A&apos;) from dual; -- 65</span><br><span class="line"></span><br><span class="line">-- CHR测试</span><br><span class="line">select CHR(65) from dual; -- A</span><br><span class="line"></span><br><span class="line">-- REPLACE测试</span><br><span class="line">select REPLACE(&apos;jellythink&apos;, &apos;think&apos;, &apos; is good&apos;) from dual; -- jelly is good</span><br><span class="line"></span><br><span class="line">-- INSTR测试</span><br><span class="line">select INSTR(&apos;JellyThink&apos;, &apos;Jelly&apos;, 1) from dual; -- 1</span><br><span class="line"></span><br><span class="line">-- LPAD测试</span><br><span class="line">select LPAD(&apos;JellyThink&apos;, 12, &apos;*&apos;) from dual; -- **JellyThink</span><br><span class="line"></span><br><span class="line">-- RPAD测试</span><br><span class="line">select RPAD(&apos;JellyThink&apos;, 12, &apos;*&apos;) from dual; -- JellyThink**</span><br><span class="line"></span><br><span class="line">-- LTRIM测试</span><br><span class="line">select LTRIM(&apos;**JellyThink&apos;, &apos;*&apos;) from dual; -- JellyThink</span><br><span class="line"></span><br><span class="line">-- RTRIM测试</span><br><span class="line">select RTRIM(&apos;JellyThink**&apos;, &apos;*&apos;) from dual; -- JellyThink</span><br><span class="line"></span><br><span class="line">-- TRIM测试</span><br><span class="line">select TRIM(&apos;*&apos; from &apos;**JellyThink**&apos;) from dual; -- JellyThink</span><br><span class="line">select TRIM(&apos;  JellyThink  &apos;) from dual; -- JellyThink(注：默认去掉空格)</span><br></pre></td></tr></table></figure><h2 id="常用日期函数"><a href="#常用日期函数" class="headerlink" title="常用日期函数"></a>常用日期函数</h2><p>每天都在和各种日期打交道，一个会得到这个月的最后一天，一会又要得到当前日期，看看以下的函数吧，是否似曾相识。</p><table><thead><tr><th style="text-align:left">函数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">SYSDATE</td><td style="text-align:left">返回系统当前日期和时间</td></tr><tr><td style="text-align:left">NEXT_DAY(day,char)</td><td style="text-align:left">返回指定日期day后的第一个工作日char所对应的日期</td></tr><tr><td style="text-align:left">LAST_DAY(day)</td><td style="text-align:left">返回day日期所指定月份中最后一天所对应的日期</td></tr><tr><td style="text-align:left">ADD_MONTHS(day,n)</td><td style="text-align:left">返回day日期在n个月后(n为正数)或前(n为负数)的日期</td></tr><tr><td style="text-align:left">MONTHS_BETWEEN(day1,day2)</td><td style="text-align:left">返回day1日期和day2日期之间相差得月份</td></tr><tr><td style="text-align:left">ROUND(day[,fmt])</td><td style="text-align:left">返回日期的四舍五入结果。如果fmt指定年度，则7月1日为分界线；如果fmt指定月，则16日为分界线；如果指定天，则中午12:00为分界线，默认舍入到日</td></tr><tr><td style="text-align:left">TRUNC(day,[,fmt])</td><td style="text-align:left">日期截断函数。如果fmt指定年度，则结果为本年度的1月1日；如果为月，则将结果为本月1日，默认截断到日</td></tr><tr><td style="text-align:left">CURRENT_DATE</td><td style="text-align:left">返回当前会话时区所对应日期时间</td></tr><tr><td style="text-align:left">EXTRACT</td><td style="text-align:left">从日期中获取所需要的特定数据</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">-- SYSDATE测试</span><br><span class="line">select TO_CHAR(SYSDATE,&apos;yyyy-MM-dd hh24:mi:ss&apos;) from dual; -- 2015-09-29 15:14:44</span><br><span class="line"></span><br><span class="line">-- NEXT_DAY测试</span><br><span class="line">select NEXT_DAY(SYSDATE, &apos;星期一&apos;) from dual; -- 2015/10/5 15:16:46</span><br><span class="line"></span><br><span class="line">-- LAST_DAY测试</span><br><span class="line">select LAST_DAY(SYSDATE) from dual; -- 2015/9/30 15:17:23</span><br><span class="line"></span><br><span class="line">-- ADD_MONTHS测试</span><br><span class="line">select ADD_MONTHS(SYSDATE, 2) from dual; -- 2015/11/29 15:18:39</span><br><span class="line"></span><br><span class="line">-- MONTHS_BETWEEN测试</span><br><span class="line">select MONTHS_BETWEEN(SYSDATE, SYSDATE) from dual; -- 0</span><br><span class="line">select MONTHS_BETWEEN(ADD_MONTHS(SYSDATE, -2), ADD_MONTHS(SYSDATE, 2)) from dual; -- -4</span><br><span class="line"></span><br><span class="line">-- ROUND测试</span><br><span class="line">select ROUND(SYSDATE) from dual; -- 2015/9/30</span><br><span class="line">select ROUND(SYSDATE, &apos;YEAR&apos;) from dual; -- 2016/1/1</span><br><span class="line">select ROUND(SYSDATE, &apos;MONTH&apos;) from dual; -- 2015/10/1</span><br><span class="line"></span><br><span class="line">-- TRUNC测试</span><br><span class="line">select TRUNC(SYSDATE) from dual; -- 2015/9/29</span><br><span class="line">select TRUNC(SYSDATE, &apos;YEAR&apos;) from dual; -- 2015/1/1</span><br><span class="line">select TRUNC(SYSDATE, &apos;MONTH&apos;) from dual; -- 2015/9/1</span><br><span class="line"></span><br><span class="line">-- CURRENT_DATE测试</span><br><span class="line">select CURRENT_DATE from dual; -- 2015/9/29 15:22:44</span><br></pre></td></tr></table></figure><h2 id="常用类型转换函数"><a href="#常用类型转换函数" class="headerlink" title="常用类型转换函数"></a>常用类型转换函数</h2><p>类型转换函数是太常见了，什么to_char啊，to_date啊，但是你有没有好好的使用过呢？</p><table><thead><tr><th style="text-align:left">函数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">TO_CHAR</td><td style="text-align:left">将一个数字或日期转换成字符串</td></tr><tr><td style="text-align:left">TO_NUMBER</td><td style="text-align:left">将字符型数据转换成数字型数据</td></tr><tr><td style="text-align:left">TO_DATE</td><td style="text-align:left">将字符型数据转换为日期型数据</td></tr><tr><td style="text-align:left">CAST</td><td style="text-align:left">将一种built-in类型转换成另一种built-in类型</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-- TO_CHAR测试</span><br><span class="line">select TO_CHAR(100) from dual; -- 100</span><br><span class="line">select TO_CHAR(SYSDATE, &apos;YYYY-MM-DD HH24:MI:SS&apos;) from dual; -- 2015-09-29 15:36:24</span><br><span class="line"></span><br><span class="line">-- TO_NUMBER测试</span><br><span class="line">select TO_NUMBER(&apos;10&apos;) from dual; -- 10</span><br><span class="line">select TO_NUMBER(&apos;JellyThink&apos;) from dual; -- 无效数字</span><br><span class="line"></span><br><span class="line">-- TO_DATE测试</span><br><span class="line">select TO_DATE(&apos;2015-9-29&apos;, &apos;YYYY-MM-DD&apos;) from dual; -- 2015/9/29</span><br><span class="line"></span><br><span class="line">-- CAST测试</span><br><span class="line">select CAST(&apos;100&apos; as NUMBER) from dual; -- 100</span><br><span class="line">select CAST(2 as char) from dual; -- 2</span><br></pre></td></tr></table></figure><h2 id="集合函数"><a href="#集合函数" class="headerlink" title="集合函数"></a>集合函数</h2><p>有了GROUP BY，怎么可以少了这些用来统计的集合函数呢。</p><table><thead><tr><th style="text-align:left">函数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">AVG</td><td style="text-align:left">计算一列值的平均值</td></tr><tr><td style="text-align:left">COUNT</td><td style="text-align:left">统计一列中值的个数</td></tr><tr><td style="text-align:left">MAX</td><td style="text-align:left">求一列值中的最大值</td></tr><tr><td style="text-align:left">MIN</td><td style="text-align:left">求一列值中的最小值</td></tr><tr><td style="text-align:left">SUM</td><td style="text-align:left">计算一列值的总和</td></tr></tbody></table><h2 id="其它常用函数"><a href="#其它常用函数" class="headerlink" title="其它常用函数"></a>其它常用函数</h2><p>还有一些经常使用的函数不属于上述的任何一种分类，只能作为其它常用函数来分类了，具体你看喽。</p><table><thead><tr><th style="text-align:left">函数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">decode(expression , search , result [, search , result]… [, default])</td><td style="text-align:left">IF语句的另一形式。将输入数值与参数列表比较，返回对应值。应用于将表的行转换成列以及IF语句无法应用的场合</td></tr><tr><td style="text-align:left">SIGN(number)</td><td style="text-align:left">如果number大于0，SIGN则返回1；如果number小于0，SIGN则返回-1；如果number等于0，SIGN则返回0</td></tr><tr><td style="text-align:left">TRUNC(number, [ decimal_places ])</td><td style="text-align:left">number是要截取的数字，decimal_places是要保留的小数位。这个参数必须是个整数。 如果此参数缺省，默认保留0位小数</td></tr><tr><td style="text-align:left">GREATEST(expr1[,expr2]…)</td><td style="text-align:left">返回表达式中值最大的一个</td></tr><tr><td style="text-align:left">LEAST(expr1[,expr2]…)</td><td style="text-align:left">返回表达式中值最小的一个</td></tr><tr><td style="text-align:left">NULLIF(expr1,expr2)</td><td style="text-align:left">如果expr1=expr2；则返回null，否则返回expr1</td></tr><tr><td style="text-align:left">NVL(expr1,expr2)</td><td style="text-align:left">如果expr1=null；则返回expr2，否则返回expr1</td></tr><tr><td style="text-align:left">NVL2(expr1,expr2,expr3)</td><td style="text-align:left">如果expr1!=null；则返回expr2；如果expr1=null；则返回expr3</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">-- DECODE测试</span><br><span class="line">select DECODE(20, 10, 5, 200, 10, 20, 30) from dual; -- 30</span><br><span class="line"></span><br><span class="line">-- SIGN测试</span><br><span class="line">select SIGN(20) from dual; -- 1</span><br><span class="line">select SIGN(-30) from dual; -- -1</span><br><span class="line">select SIGN(0) from dual; -- 0</span><br><span class="line"></span><br><span class="line">-- TRUNC测试</span><br><span class="line">select TRUNC(20.2183, 2) from dual; -- 20.21</span><br><span class="line">select TRUNC(20.1, 4) from dual; -- 20.1</span><br><span class="line"></span><br><span class="line">-- GREATEST测试</span><br><span class="line">select GREATEST(20, 100, 30, 20, 40, 400) from dual; -- 400</span><br><span class="line"></span><br><span class="line">-- LEAST测试</span><br><span class="line">select LEAST(20, 100, 30, 20, 40, 400) from dual; -- 20</span><br><span class="line"></span><br><span class="line">-- NULLIF测试</span><br><span class="line">select NULLIF(20, 20) from dual; -- NULL</span><br><span class="line">select NULLIF(20, 10) from dual; -- 20</span><br><span class="line"></span><br><span class="line">-- NVL测试</span><br><span class="line">select NVL(20, 30) from dual; -- 20</span><br><span class="line">select NVL(NULL, 30) from dual; -- 30</span><br><span class="line"></span><br><span class="line">-- NVL2测试</span><br><span class="line">select NVL2(NULL, 20, 30) from dual; -- 30</span><br><span class="line">select NVL2(&apos;JellyThink&apos;, 20, 30) from dual; -- 20</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>哦，总结完了，感觉还算有点效果，至少又把这些函数重新复习了一遍，不是吗？有些函数真的非常有用，真的希望我的总结对你有帮助。谢谢各位的阅读，也希望你能和我分享你的学习心得。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一篇鸡肋文章&quot;&gt;&lt;a href=&quot;#一篇鸡肋文章&quot; class=&quot;headerlink&quot; title=&quot;一篇鸡肋文章&quot;&gt;&lt;/a&gt;一篇鸡肋文章&lt;/h2&gt;&lt;p&gt;在平时写PL/SQL的时候，经常要用到很多系统自带的函数，而这些函数用起来非常好用，但是每次用完以后，就又忘到脑后了，为了加深自己的印象，以及对这些函数做一个全面的总结，就有了今天这篇文章。&lt;/p&gt;
&lt;p&gt;首先这就是一个网上总结烂了的主题。我还要总结，权当自己的学习总结。总结这篇文章时也参考了网上他人总结的文章，如果不喜、勿喷。&lt;/p&gt;
&lt;p&gt;作为一篇“鸡肋”文章，弃之如可惜，食之无所得。读者就当一“乐呵”就好了。有钱的捧个钱场，没钱的捧个人场。&lt;/p&gt;
    
    </summary>
    
      <category term="数据库" scheme="https://jsxzswz.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="oracle" scheme="https://jsxzswz.github.io/tags/oracle/"/>
    
  </entry>
  
</feed>
