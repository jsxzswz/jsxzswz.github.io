<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[java线程及线程池介绍]]></title>
    <url>%2F2019%2F03%2F11%2Fblog20190311%2F</url>
    <content type="text"><![CDATA[前言如果不考虑多线程的话，那么在程序只有一条执行路径，代码串行执行：顺序执行、选择或者循环；如果使用多线程，就可以把一些大任务分解成多个小任务来执行，多个小任务之间互不影响，同时进行，充分利用了cpu资源。 多线程的作用在一个高并发的网站中，多线程是必不可少的。下面先说一下多线程在程序中的作用。 提高前端请求的响应速度； 减清服务器的压力； 提高处理能力，增加性能，充分利用服务器资源。 多线程的使用场景以下是web开发常见的多线程使用场景： 最典型的应用比如tomcat，tomcat内部采用的就是多线程 图形用户界面中，多线程可以提供用户界面响应灵敏度； web服务器本身；各种专用服务器（如游戏服务器）； 后台定时任务，例如：定时向大量（100w以上）的用户发送邮件； 异步处理，例如：发微博、记录日志等。 java中的多线程java中简单的实现多线程的方式继承Thread类，重写run方法; 12345678910111213141516171819public class ThreadTest extends Thread &#123; @Override public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(getName() + &quot; &quot; + i); &#125; &#125; public static void main(String[] args) &#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(Thread.currentThread().getName() + &quot; : &quot; + i); if (i == 20) &#123; new ThreadTest().start(); new ThreadTest().start(); &#125; &#125; &#125;&#125; 实现Runable接口，实现run方法； 1234567891011121314151617181920212223242526272829303132333435363738public class RunnableThreadTest implements Runnable &#123; @Override public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(Thread.currentThread().getName() + &quot; &quot; + i); &#125; &#125; public static void main(String[] args) &#123; //for (int i = 0; i &lt; 100; i++) &#123; // System.out.println(Thread.currentThread().getName() + &quot; &quot; + i); // if (i == 20) &#123; // RunnableThreadTest rt = new RunnableThreadTest(); // new Thread(rt, &quot;新线程1&quot;).start(); // new Thread(rt, &quot;新线程2&quot;).start(); // &#125; //&#125; MyThread t = new MyThread(); for (int i = 0; i &lt; 10; i++) &#123; new Thread(t).start();//同一个t1，如果在Thread中就不行，会报错 &#125; &#125;&#125;class MyThread implements Runnable &#123; private int ticket = 10000; @Override //记得要资源公共，要在run方法之前加上synchronized关键字，要不然会出现抢资源的情况 public synchronized void run() &#123; for (int i = 0; i &lt; 10000; i++) &#123; if (this.ticket &gt; 0) &#123; System.out.println(&quot;卖票：ticket&quot; + this.ticket--); &#125; &#125; &#125;&#125; java线程的状态 创建：当new了一个线程，并没有调用start之前，线程处于创建状态； 就绪：当调用了start之后，线程处于就绪状态，这是，线程调度程序还没有设置执行当前线程； 运行：线程调度程序执行到线程时，当前线程从就绪状态转成运行状态，开始执行run方法里边的代码； 阻塞：线程在运行的时候，被暂停执行（通常等待某项资源就绪后在执行，sleep、wait可以导致线程阻塞），这是该线程处于阻塞状态； 死亡：当一个线程执行完run方法里边的代码或调用了stop方法后，该线程结束运行。 java中的线程池（ThreadPoolExecutor）为什么要引入线程池当我们需要的并发执行线程数量很多时，且每个线程执行很短的时间就结束了，这样，我们频繁的创建、销毁线程就大大降低了工作效率（创建和销毁线程需要时间、资源）。java中的线程池可以达到这样的效果：一个线程执行完任务之后，继续去执行下一个任务，不被销毁，这样线程利用率提高 java线程池各参数介绍java.util.concurrent.ThreadPoolExecutor。ThreadPoolExecutor类是java线程池中的核心类。他的实现方式有四种： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class ThreadPoolExecutor extends AbstractExecutorService &#123; public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) &#123; this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), defaultHandler); &#125; public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory) &#123; this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, defaultHandler); &#125; public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, RejectedExecutionHandler handler) &#123; this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), handler); &#125; public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123; if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler;&#125; 通过ThreadPoolExecutor类的源码可以看出，ThreadPoolExecutor类继承AbstractExecutorService，提供四个构造方法，通过构造方法可以看出前面三个最终掉了最后一个下面介绍下构造方法中的参数： corePoolSize：线程池的大小。线程池创建之后不会立即去创建线程，而是等待线程的到来。当当前执行的线程数大于改值是，线程会加入到缓冲队列； maximumPoolSize：线程池中创建的最大线程数； keepAliveTime：空闲的线程多久时间后被销毁。默认情况下，改值在线程数大于corePoolSize时，对超出corePoolSize值得这些线程起作用。 unit：TimeUnit枚举类型的值，代表keepAliveTime时间单位，可以取下列值： TimeUnit.DAYS; //天 TimeUnit.HOURS; //小时 TimeUnit.MINUTES; //分钟 TimeUnit.SECONDS; //秒 TimeUnit.MILLISECONDS; //毫秒 TimeUnit.MICROSECONDS; //微妙 TimeUnit.NANOSECONDS; //纳秒 workQueue：阻塞队列，用来存储等待执行的任务，决定了线程池的排队策略，有以下取值： ArrayBlockingQueue; LinkedBlockingQueue; SynchronousQueue; threadFactory：线程工厂，是用来创建线程的。默认new Executors.DefaultThreadFactory(); handler:线程拒绝策略。当创建的线程超出maximumPoolSize，且缓冲队列已满时，新任务会拒绝，有以下取值： ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。 ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。 ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程） ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务 execute()方法是Executor中声明的方法，在ThreadPoolExecutor有了具体的实现，这个方法是ThreadPoolExecutor的核心方法，通过这个方法可以向线程池提交一个任务，交由线程池去执行submit()方法是ExecutorService中声明的方法，在AbstractExecutorService中进行了实现，Executor中并没有对其进行重写。从实现中可以看出，submit方法最终也调用了execute方法，也是执行一个人去，但submit方法可以返回执行结果，利用Future来获取任务执行结果。 Spring中线程池的使用Spring中的线程池是由ThreadPoolTaskExecutor类来实现的。该类的实现原理最终也是调用了java中的ThreadPoolExecutor类中的一些方法。ThreadPoolTaskExecutor有两种常用的有两种初始化方式：xml配置，java代码初始化。 xml文件配置123456789&lt;bean id=&quot;taskExecutor&quot; class=&quot;org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor&quot;&gt;&lt;property name=&quot;corePoolSize&quot; value=&quot;5&quot; /&gt;&lt;property name=&quot;keepAliveSeconds&quot; value=&quot;200&quot; /&gt;&lt;property name=&quot;maxPoolSize&quot; value=&quot;10&quot; /&gt;&lt;property name=&quot;queueCapacity&quot; value=&quot;20&quot; /&gt;&lt;property name=&quot;rejectedExecutionHandler&quot;&gt;&lt;bean class=&quot;java.util.concurrent.ThreadPoolExecutor$CallerRunsPolicy&quot; /&gt;&lt;/property&gt;&lt;/bean&gt; 123456789101112public MyThreadPoolTaskExecutor &#123;@Autowiredprivate ThreadPoolTaskExecutor taskExecutor; private void test()&#123; taskExecutor.execute(new Runnable()&#123; @Override public void run() &#123; //执行的代码 &#125;&#125;); &#125;&#125; java程序中配置123456789101112131415private void test2()&#123; ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor(); executor.setCorePoolSize(10); executor.setMaxPoolSize(15); executor.setKeepAliveSeconds(1); executor.setQueueCapacity(5); executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy()); executor.initialize(); executor.execute(new Runnable()&#123; @Override public void run() &#123; //执行的代码 &#125; &#125;);&#125; 附：常用参数总结关于Java线程池的参数设置： 线程池是Java多线程里开发里的重要内容，使用难度不大，但如何用好就要明白参数的含义和如何去设置！ ThreadPoolExecutor的重要参数 corePoolSize：核心线程数 核心线程会一直存活，及时没有任务需要执行 当线程数小于核心线程数时，即使有线程空闲，线程池也会优先创建新线程处理 设置allowCoreThreadTimeout=true（默认false）时，核心线程会超时关闭 queueCapacity：任务队列容量（阻塞队列） 当核心线程数达到最大时，新任务会放在队列中排队等待执行 maxPoolSize：最大线程数 当线程数&gt;=corePoolSize，且任务队列已满时。线程池会创建新线程来处理任务 当线程数=maxPoolSize，且任务队列已满时，线程池会拒绝处理任务而抛出异常 keepAliveTime：线程空闲时间 当线程空闲时间达到keepAliveTime时，线程会退出，直到线程数量=corePoolSize 如果allowCoreThreadTimeout=true，则会直到线程数量=0 allowCoreThreadTimeout：允许核心线程超时 rejectedExecutionHandler：任务拒绝处理器 两种情况会拒绝处理任务： 当线程数已经达到maxPoolSize，切队列已满，会拒绝新任务 当线程池被调用shutdown()后，会等待线程池里的任务执行完毕，再shutdown。如果在调用shutdown()和线程池真正shutdown之间提交任务，会拒绝新任务 线程池会调用rejectedExecutionHandler来处理这个任务。如果没有设置默认是AbortPolicy，会抛出异常 ThreadPoolExecutor类有几个内部实现类来处理这类情况： AbortPolicy 丢弃任务，抛运行时异常 CallerRunsPolicy 执行任务 DiscardPolicy 忽视，什么都不会发生 DiscardOldestPolicy 从队列中踢出最先进入队列（最后一个执行）的任务 实现RejectedExecutionHandler接口，可自定义处理器 ThreadPoolExecutor执行顺序线程池按以下行为执行任务: 当线程数小于核心线程数时，创建线程。 当线程数大于等于核心线程数，且任务队列未满时，将任务放入任务队列。 当线程数大于等于核心线程数，且任务队列已满 若线程数小于最大线程数，创建线程 若线程数等于最大线程数，抛出异常，拒绝任务 如何设置参数 默认值 corePoolSize=1 queueCapacity=Integer.MAX_VALUE maxPoolSize=Integer.MAX_VALUE keepAliveTime=60s allowCoreThreadTimeout=false rejectedExecutionHandler=AbortPolicy() 如何来设置 需要根据几个值来决定 tasks ：每秒的任务数，假设为500~1000 taskcost：每个任务花费时间，假设为0.1sW responsetime：系统允许容忍的最大响应时间，假设为1s corePoolSize = 每秒需要多少个线程处理？ threadcount = tasks/(1/taskcost) =taskstaskcout = (500~1000)0.1 = 50~100 个线程。corePoolSize设置应该大于50 根据8020原则，如果80%的每秒任务数小于800，那么corePoolSize设置为80即可 queueCapacity = (coreSizePool/taskcost)*responsetime 计算可得 queueCapacity = 80/0.1*1 = 80。意思是队列里的线程可以等待1s，超过了的需要新开线程来执行 切记不能设置为Integer.MAX_VALUE，这样队列会很大，线程数只会保持在corePoolSize大小，当任务陡增时，不能新开线程来执行，响应时间会随之陡增。 maxPoolSize = (max(tasks)- queueCapacity)/(1/taskcost) 计算可得 maxPoolSize = (1000-80)/10 = 92 （最大任务数-队列容量）/每个线程每秒处理能力 = 最大线程数 rejectedExecutionHandler：根据具体情况来决定，任务不重要可丢弃，任务重要则要利用一些缓冲机制来处理 keepAliveTime和allowCoreThreadTimeout采用默认通常能满足 以上都是理想值，实际情况下要根据机器性能来决定。如果在未达到最大线程数的情况机器cpu load已经满了，则需要通过升级硬件（呵呵）和优化代码，降低taskcost来处理。 结尾本文内容大体就这些，若大家觉得说的有什么不好的地方，请指正，谢谢！ 参考链接：Java线程池使用和常用参数！]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>线程</tag>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java语言基础]]></title>
    <url>%2F2019%2F02%2F25%2Fblog20190225%2F</url>
    <content type="text"><![CDATA[前言Java 是一门面向对象的编程语言，它不仅吸收了 C++ 语言的各种优点，还摒弃了 C++ 里难以理解的多重继承、指针等概念，因此 Java 语言具有功能强大和简单易用两个特征。此外，Java 还具有简单性、面向对象、分布式、健壮性、安全性、平台独立与可移植性、多线程、动态性等特点。 对象漫谈「万物皆对象」，事实上，也确实如此。在面向对象编程的世界中，我们创建对象、操作对象、销毁对象，我们所做的一切动作都离不开对象。 对象存储在哪里？在 Java 中，对象存储在 5 个地方，分别为： 寄存器。它是最快的存储区，位于处理器内部。一般来说，它根据需求进行分配，我们不能直接进行控制，也很难感觉到它的存在。 堆栈。它位于 RAM（Random Access Memory，随机访问存储器），通过堆栈指针分配内存空间，指针下移，分配内存；指针上移，释放内存。堆栈的处理速度仅次于寄存器，但编译器必须知道存储在堆栈中内容的确切生命周期，这造成了一定的限制。一般来说，基本数据类型，存储在堆栈中。 堆。堆是一种通用的内存池，也位于 RAM 中，它的处理速度稍慢于堆栈，用于存储所有的 Java 对象，更确切的说，所有new出来的对象都存在堆中。 常量存储。常量值通常直接存在代码的内部，但有时为了将常量与其他内容分离，也会存在 ROM（Read Only Memory）中。 非 RAM 存储。有的数据可以存活于程序之外，在程序没有运行的时候也可以存在，例如流对象和持久化对象（写入磁盘）。 在 JDK SE1.5 发布之后，基本数据类型都具有对应的包装器类，使得我们可以在堆中创建一个非基本对象，用来表示对应的基本类型，而且基本数据类型和其对应的包装器类型之间可以自动的进行转换，我们称之为自动装箱和自动拆箱。 BigDecimal支持任意精度的定点数。利用这一特性，我们常用它进行精密的货币计算。 字段、方法和 static 关键字在我们创建一个类的时候，实际上只是给出了类对象的描述，包括属性（字段）和行为（方法），除非我们用new来真正的创建类对象，否则的话，我们并未获得任何对象。只有在执行new来创建对象的时候，数据存储空间才真正被分配，其方法才能够被外界调用。 当我们声明一个static域或方法的时候，就意味着这个域或方法不会与包含它的那个类的任何对象实例联系在一起。使用类名来调用static变量是首选方法，即ClassName.StaticObject。一个static字段对每个类来说都只有一份存储空间，但非static字段则是对每个对象都有一份存储空间。 操作符在 Java 编程的过程中，我们对数据的处理，都是通过操作符来实现的。例如，用于赋值的赋值操作符、用于运算的运算操作符、用于比较的比较操作符，还包括逻辑操作符、按位操作符、移位操作符、三元操作符等等。 赋值操作符基本数据类型存储了实际的数值，而不是指向对象的引用，所以在为其赋值的时候，是直接将一个地方的内容复制到了另一个地方。而为一个对象进行赋值操作的时候，我们实际上是操作对象的引用，即将一个对象的引用赋值给另一个对象 算术操作符如果我们在创建Random对象的时候没有传入任何参数，那么 Java 就会将当前时间作为随机数生成器的种子，因此在每次执行上述程序的时候，都会得到不同的结果。 在算术操作符中有两个比较特殊的操作符，那就是递增（++）和递减（–），递增和递减操作符不仅改变了变量，并且以变量的值作为其结果。对于前缀递增和前缀递减（如i++或者i–），会先执行运算，再生成值；对于后缀递增和后缀递减（如++i或者–i），会先生成值，再执行运算。 关系操作符在 Java 语言中，关系操作符包括&gt;、&lt;、&gt;=、&lt;=、==和!=等，其生成的结果为boolean类型，其中有两个关系操作符需要我们特别注意，那就是==和!=。 ==和!=比较的是对象的引用，我们通过new创建了两个Integer类型的对象，虽然这两个对象的内容相同，但它们在堆上拥有不同的存储空间，也就拥有了不同的对象引用。 在这里纠正一下，equals()方法默认是比较对象的引用，不过在大多数的 Java 类库中都实现了equals()方法，以便用来比较对象的内容，而非比较对象的引用。因此，如果我们想使用equals()方法来比较我们自定义类型的内容而非引用的话，则需要覆盖Object类（终极根类）中的equals()方法，而在覆盖equals()方法的同时，建议同时覆盖hashCode()方法。 控制流程在 Java 中，if-else是最基本的控制程序流程的形式. 迭代常见的迭代形式有三种，分别为for、while和do-while，其中while和do-while的唯一区别就是do-while至少会执行一次循环。在一个控制表达式中，只有for循环可以定义多个变量（且变量的生存周期为循环体内部）。 一种是普通的for循环，其形式如下： 123 for(initialization; boolean-expression; step) &#123; statement&#125; 另一种是高级的for循环，我们也称之为foreach循环，其形式如下： 123 for(variable-type variable-name : collection) &#123; statement&#125; 利用Arrays类中的toString()方法，其返回一个包含数组中所有元素的字符串，这个字符串被放置在一个中括号内部并用逗号进行分隔。 return、break、continuereturn关键字有两种用途： 指定一个方法返回什么值； 强行退出当前的方法，并返回那个值。 在任何迭代语句的主体部分，都可以用break和continue控制循环的流程，其中： break用于强行退出循环，不执行循环中剩余的语句； continue用于停止执行当前的迭代，然后退回循环起始处，开始下一次迭代。 初始化与清理Java 的一大特点就是其自动的初始化与清理功能。对于基本数据类型的全局变量，Java 自动将其初始化为对应的默认值;对于对象，我们可以通过构造方法对其进行初始化；对于清理操作，Java 提供了垃圾回收机制，其可以帮我们自动清理不再使用的对象，释放资源。 构造方法构造方法是一种特殊的方法，它是一个与类同名且没有返回值类型的方法。对象的创建就是通过构造方法来完成，其功能主要是完成对象的初始化。 我们也可以通过构造代码块（包括静态和非静态两种）给对象进行初始化，对象一建立构造代码块就执行，而且优先于构造函数执行。 初始化在类的内部，变量定义的先后顺序决定了初始化的顺序，即使变量定义散布于方法定义之间，它们仍然会在任何方法（包括构造器）被调用之前得到初始化。 构造方法可以看成静态方法。静态初始化只在Class对象首次加载的时候进行一次。 垃圾回收垃圾回收只与内存有关，利用finaliza()方法，我们可以在垃圾回收器执行时做一些重要的清理工作。 方法重载与 this 关键字方法名和参数列表构成了「方法签名」，它能够唯一的标识出一个具体的方法。方法重载，是指方法名相同，而参数个数不同、参数类型不同或者参数个数和参数类型都不同。 this只能在方法的内部调用，表示“调用方法的那个对象”的引用。此外，如果在构造器中为this添加了参数列表，那么将产生对符合此参数列表的构造器的明确调用。 访问权限控制访问权限控制的等级，从最大权限到最小权限依次为：public、protected、包访问权限（没有关键字）和private。 public：任何类都可以访问； protected：该类的子类及同包的类可以访问； 包访问权限：同包的类可以访问； private：只有本类的成员可以访问。 继承、组合、fianl提起「复用类」三个字，相信我们脑海中浮现的都是「组合」和「继承」。 继承Java 用super关键字表示超类（或称之为基类）的意思，类的构建过程是从超类向外“扩散”的。 调用超类构造器必须是我们在导出类构造器中做的第一件事 组合我们有一个设计原则，那就是：多用组合，少用继承。 final一个既是static又是final的域只占据一段不能改变的存储空间。 对于基本类型，final使数值恒定不变；而对于对象的引用，final使引用恒定不变，然后对象自身却是可以被修改的。 使用final方法的唯一理由就是：禁止子类覆盖父类中的方法。 类中所有的private方法都隐式地指定为final的；final类中所有的方法也都隐式指定为final的，因此final类无法继承，其方法也无法覆盖。 多态、初始化顺序在面向对象的编程语言中，有三个特性，分别为：封装、继承和多态。 多态实现多态的前提是继承，多态的作用是消除类型之间的耦合关系。对于多态，我们常说的词有两个，分别为：向上转型和向下转型。 我们把对某个对象的引用视为其基类型的引用的做法，称之为向上转型；把对某个对象的引用视为其导出类型的引用的做法，称之为向下转型。 只有普通的方法调用是多态的，如果某个方法是静态的，它的行为就是不具有多态性。任何域访问操作都是由编译器继解析，因此域也不是多态的。 初始化顺序以基类1 -&gt; 基类2 -&gt; 导出类的继承结构为例，初始化顺序大致如下： 从基类1开始，先进行静态初始化，然后依次向外扩散至基类2和导出类； 然后，依次进行基类1的非静态初始化和构造器初始化； 再依次进行基类2的非静态初始化和构造器初始化； 最后，才是导出类的非静态初始化和构造器初始化。 接口、内部类在 Java 的语言体系中，类和接口是两种常见的定义对象的形式，内部类则是类的一种特殊形式。接口和内部类为我们提供了一种将抽象定义与具体实现相分离的更加结构化的方法。 接口只要类中含有至少一个抽象方法(抽象方法仅有声明而没有方法体)，则该类就是抽象类；并没有限制抽象类中是否可以含有非抽象的方法，而且实际上抽象类中是允许含有非抽象方法的。在接口中，则不允许含有非抽象的方法！ 我们使用接口的原因有两个，分别为： 为了能够向上转型为多个基类型以及由此而带来的灵活性（核心原因）； 防止客户端程序员创建该类的对象（与抽象基类相同）。 内部类我们知道内部类可分为以下几种：成员内部类、静态内部类、方法内部类以及匿名内部类，这里我们先将以这个分类来详细了解各个内部类的情况。然后给内部类作出总结。 成员内部类123456789101112131415161718192021public class Outer &#123; private int a = 10; int b = 5; public class Inner &#123; int b = 6; public void test() &#123; System.out.println(a); System.out.println(this.b);//如果外部类和内部类具有相同的成员变量或方法，内部类默认访问自己的成员变量或方法 System.out.println(Outer.this.b);//如果要访问外部类的成员变量，可以使用 this 关键字 &#125; &#125; public static void main (String[] args) &#123; //外部类不能直接访问内部类的方法，可先创建内部类的对象，然后通过内部类的对象来访问其成员变量和方法 Outer o = new Outer(); Inner i = o.new Inner(); i.test(); &#125;&#125; 从上面的代码中我们可以看到，成员内部类的使用方法： 内部类可以访问任意修饰符的成员变量； 必须使用外部类对象来创建内部类对象，而不能直接去 new 一个内部类对象，内部类 对象名 = 外部类对象.new 内部类( ); 外部类是不能直接使用内部类的成员和方法,可先创建内部类的对象，然后通过内部类的对象来访问其成员变量和方法;原因：Java 编译器在创建内部类对象时，隐式的把其外部类对象的引用也传了进去并一直保存着。这样就使得内部类对象始终可以访问其外部类对象，同时这也是为什么在外部 类作用范围之外向要创建内部类对象必须先创建其外部类对象的原因。 如果外部类和内部类具有相同的成员变量或方法，内部类默认访问自己的成员变量或方法，如果要访问外部类的成员变量，可以使用 this 关键字 静态内部类1234567891011121314151617181920public class Outer2 &#123; private int a =10; static int b =5; static int c =8; public static class Inner2 &#123; int b = 6; public void test() &#123; System.out.println(new Outer2().a);// 静态内部类不能直接访问外部类的非静态成员，但可以通过 new 外部类().成员 的方式访问。 System.out.println(this.b);// System.out.println(c);//如果外部类的静态成员与内部类的成员名称不相同，则可通过“成员名”直接调用外部类的静态成员。 System.out.println(Outer2.b);//如果外部类的静态成员与内部类的成员名称相同，可通过“类名.静态成员”访问外部类的静态成员； &#125; &#125; public static void main(String[] args) &#123; Inner2 i = new Inner2();//创建静态内部类的对象时，不需要外部类的对象，可以直接创建 内部类 对象名= new 内部类(); i.test(); &#125;&#125; 静态内部类是 static 修饰的内部类，这种内部类的特点是： 静态内部类不能直接访问外部类的非静态成员，但可以通过 new 外部类().成员 的方式访问。 如果外部类的静态成员与内部类的成员名称相同，可通过“类名.静态成员”访问外部类的静态成员；如果外部类的静态成员与内部类的成员名称不相同，则可通过“成员名”直接调用外部类的静态成员。 创建静态内部类的对象时，不需要外部类的对象，可以直接创建 内部类 对象名= new 内部类(); 方法内部类12345678910111213141516171819202122public class Outer3 &#123; public void show() &#123; final int a = 10; int b = 6; class Inner3 &#123; int c = 2; public void print() &#123; System.out.println(a); System.out.println(c); System.out.println(b); &#125; &#125; Inner3 i = new Inner3(); i.print(); &#125; public static void main(String[] args) &#123; Outer3 o = new Outer3(); o.show(); &#125;&#125; 方法内部类就是内部类定义在外部类的方法中，方法内部类只在该方法的内部可见，即只在该方法内可以使用。 由于方法内部类不能在外部类的方法以外的地方使用，因此方法内部类不能使用访问控制符和 static 修饰符。 匿名内部类1234567891011121314public class Outer4 &#123; public static void main(String[] args) &#123; Person p = new Person() &#123; public void eat() &#123; System.out.println(&quot;eat something!&quot;); &#125; &#125;; p.eat(); &#125;&#125;abstract class Person &#123; public abstract void eat();&#125; 使用匿名内部类时，必须是继承一个类或实现一个接口，但两者不可兼得，同时也只能继承一个类或者实现一个接口。new &lt;类或接口&gt; &lt;类的主体&gt; 匿名内部类中是不能定义构造函数的。 匿名内部类中不能存在任何的静态成员变量和静态方法。 匿名内部类为局部内部类（即方法内部类），所以局部内部类的所有限制同样对匿名内部类生效。 匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。 匿名内部类的参数必须被声明为 final 。原因：拷贝引用，为了避免引用值发生改变。 内部类总结 内部类隐藏你不想让别人知道的操作，也即封装性。 内部类对象可以访问创建它的外部类对象的内容，甚至包括私有变量！ 异常及错误处理Java 的异常及错误处理机制中，用Throwable这个类来表示可以作为异常被抛出的类。Exception，表示编译或运行时发生的与期望结果不相符的情形。Exception则是可以被抛出的基本类型。 异常在超类Throwable中提供了一个printStackTrace()方法，该方法打印Throwable的调用栈轨迹。1234567try &#123; // some code may cause exception&#125; catch(ExceptionType e) &#123; // handle exception&#125; finally &#123; // some code must be executed&#125; 关键字finally的含义为：无论异常是否被抛出，finally子句总能被执行。 字符串字符串（String）对象是不可变的。 对于操作效率而言，StringBuilder &gt; StringBuffer &gt; String； 对于线程安全而言，StringBuffer是线程安全的，可用于多线程；而StringBuilder是非线程安全的，用于单线程； 对于频繁的字符串操作而言，无论是StringBuffer还是StringBuilder，都优于String。 正则表达式正则表达式又称规则表达式，在代码中常简写为regex、regexp或RE，是对字符串操作的一种逻辑公式。 灵活性、逻辑性和功能性非常的强； 可以迅速地用极简单的方式达到字符串的复杂控制； 对于初学者来说，比较晦涩难懂。 运行时类型识别、反射运行时类型信息能够让我们在程序运行时发现和使用类型信息。在运行时识别对象和类的信息，主要有两个方式，分别为： 一种是传统的RTTI，它假定我们在编译时就已经知道了所有的类型； 另一种是反射机制，它允许我们在运行时发现和使用类的信息。 运行时类型识别forName()为 Class 类（所有 Class 对象都属于这个类）一个静态方法，它以类的全限定名（包括包名）字符串为参数，返回值为是对应参数的 Class 对象的引用。无论何时，只要我们想在运行时使用类型信息，就必须首先获得对恰当的 Class 对象的引用。此外，如果想使用newIntance()方法来创建类实例，则该类必须含有默认（无参）构造器。 instanceof关键字，其返回一个布尔值，告诉我们对象是不是某个特定类型的实例。 instanceof和isInstance()保持了类型的概念，表示“你是这个类或者这个类的派生类吗？” ==和equals()仅比较实际的 Class 对象，没有考虑继承，它要么是这个确切的类型，要么不是。 泛型需要使用类型参数，用尖括号扩住，放在类名后面，然后在使用这个类的时候，用实际的参数类型替换此参数。泛型的核心概念：告诉编译器我们想要使用什么类型，然后编译器帮我们处理一起细节。在实现泛型接口的时候，与实现一般的接口唯一的区别就是：需要指定泛型接口的类型参数。基本数据类型不能作为类型参数。 数组、容器在 Java 中，持有对象的方法只有两种：数组和容器。 数组在 Java 中，数组是一种效率最高的存储和随机访问对象引用序列的方式。对象数组和基本类型数组在使用上几乎是相同的，唯一的区别就是：对象数组保存的是引用，基本类型数组直接保存基本类型的值。Arrays.sort()排序算法的实现：点击数组的排序方法会看到这样几行代码：123public static void sort(int[] a) &#123; DualPivotQuicksort.sort(a, 0, a.length - 1, null, 0, 0); &#125; DualPivotQuicksort翻译是双抽快速排序，继点击方法会看到这样几行代码：12345// Use Quicksort on small arrays if (right - left &lt; QUICKSORT_THRESHOLD) &#123;//286 sort(a, left, right, true); return; &#125; 可以看到小于286时，使用双抽快速排序，继续点击其中的sort()方法，可以看到这样几行代码：12// Use insertion sort on tiny arrays if (length &lt; INSERTION_SORT_THRESHOLD) &#123;//47 可以看到如果数组长度小于47时，使用插入排序；如果长度大于286呢，看这段代码：1234/* * The array is not highly structured, * use Quicksort instead of merge sort.*/ 如果长度大于286，判断数组的升序连续性好不好，如果好就用归并排序，不好就用快速排序！ 总结：如果长度大于等于286且连续性好的话用归并排序，如果长度大于等于286且连续性不好的话使用快速排序；如果长度小于286且大于等于47的话使用双抽快速排序，如果长度小于47的话就是要插入排序。 容器Java 容器类类库的用途是“保存对象”，并将其划分为两个不同的概念： Collection，一个独立元素的序列，包括List、Set、Queue等； Map，一组成对的“键值对”对象，包括HashMap、TreeMap等。 我们可以得到容器的一些特性，如： Collection类型的容器，每个“槽”位只能保存一个元素，这类容器包括：List，其以特定的顺序保存元素；Set，其保存的元素不能重复；Queue其允许容器的一“端”插入对象，并从另一“端移除对象。 Map类型的容器，每个”槽“位保存了两个对象，即“键”和与之关联的“值”。 ArrayList和LinkedList都是List的子类型，它们都按元素插入的顺序保存对象，两者的区别在于底层的实现以及执行某些类型的操作时的性能，其中ArrayList是用数组实现的，因此在执行查询操作时性能优于LinkedList；而LinkedList是用链表实现的，因此在执行增删操作时性能优于ArrayList。 HashSet、TreeSet、LinkedHashSet都是Set的子类型，对于相同的对象，其只保存一次，其中HashSet使用相当复杂的方式来存储对象，以保障查询时的速度，因此其拥有最快的查询速度；TreeSet，按照比较结果的升序保存对象；LinkedHashSet，按照添加元素的顺序保存对象，但因为它在保障查询速度的同时还维护了插入元素的顺序，因此其查询速度略慢于HashSet。 HashMap、TreeMap、LinkedHashMap都是Map的子类型，对于每个键，Map只接受存储一次，与Set一样，其中HashMap也提供了最快的查询速度，也没有按照任何明显的顺序来保持其元素；TreeMap，按照比较结果的升序保存键；而LinkedHashMap，则按照插入的顺序保存键，但查询速度略慢于HashMap。 栈通常是指后进先出（LIFO）的容器；队列是一个典型的先进先出（FIFO）的容器。 Java I/O 系统待定。 并发待定。 序列化待定。 线程安全性待定。 JVM相关待定。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker介绍]]></title>
    <url>%2F2019%2F02%2F20%2Fblog20190220%2F</url>
    <content type="text"><![CDATA[前言docker 功能非常强大，可以保证线上线下环境一致性，可以快速部署启动项目，有极高的平台迁移性，其联合文件系统可以使得镜像非常方便的迭代升级。诸多优点，感兴趣的朋友可以自己搜索下相关的教程先熟悉下docker相关概念。 Docker是什么Docker的思想来自于集装箱，集装箱解决了什么问题？在一艘大船上，可以把货物规整的摆放起来。并且各种各样的货物被集装箱标准化，集装箱和集装箱之间不会互相影响。那么我就不需要专门运送水果的船和专门运送化学品的船了。只要这些货物在集装箱里封装的好好的，那我就可以用一艘大船把他们都运走。 docker就是类似的理念。现在都流行云计算了，云计算就好比大货轮。docker就是集装箱。 不同的应用程序可能会有不同的应用环境，比如.net开发的网站和php开发的网站依赖的软件就不一样，如果把他们依赖的软件都安装在一个服务器上就要调试很久，而且很麻烦，还会造成一些冲突。比如IIS和Apache访问端口冲突。这个时候你就要隔离.net开发的网站和php开发的网站。常规来讲，我们可以在服务器上创建不同的虚拟机在不同的虚拟机上放置不同的应用，但是虚拟机开销比较高。docker可以实现虚拟机隔离应用环境的功能，并且开销比虚拟机小，小就意味着省钱了。 你开发软件的时候用的是Ubuntu，但是运维管理的都是centos，运维在把你的软件从开发环境转移到生产环境的时候就会遇到一些Ubuntu转centos的问题，比如：有个特殊版本的数据库，只有Ubuntu支持，centos不支持，在转移的过程当中运维就得想办法解决这样的问题。这时候要是有docker你就可以把开发环境直接封装转移给运维，运维直接部署你给他的docker就可以了。而且部署速度快。 在服务器负载方面，如果你单独开一个虚拟机，那么虚拟机会占用空闲内存的，docker部署的话，这些内存就会利用起来。 总之docker就是集装箱原理。 可以用Docker做什么【编者的话】有些开发者可能还是不明白 Docker 对自己到底有多大的用处，因此翻译 Docker个人用例 这篇文章中来介绍 Docker 在普通开发者开发过程中的用例。 Docker 如今赢得了许多关注，很多人觉得盛名之下其实难副，因为他们仍然搞不清 Docker 和普通开发者到底有什么关系。许多开发者觉得 Docker 离自己很远，Docker 是生产环境中的工具，和自己无关。我也是花了很长时间才想清楚作为普通开发人员如何在自己的开发中使用 Docker。坦率地说，我仍处在学习的过程中。 这篇文章提供了一个 Docker 用例列表，我希望它能更好地帮助你理解 Docker 并引发你的思考。本文只是描述 Docker 在普通开发者日常的应用，并不提供完整的解决方案。 在介绍用例之前，我希望你能先记住这句话：“Docker 是一个便携的应用容器”。你可以不知道 Docker 所说的的“便携式容器”到底是什么意思，但是你必须清楚 Docker 在日常中能带来非常大的效率提升。 当你需要在容器内运行自己的应用（当然可以是任何应用），Docker 都提供了一个基础系统镜像作为运行应用时的基础系统。也就是说，只要是 Linux 系统上的应用都可以运行在 Docker 中。 可以在 Docker 里面运行数据库吗？当然可以。可以在 Docker 里面运行 Node.js 网站服务器吗？当然可以。可以在 Docker 里面运行 API 服务器吗？当然可以。 Docker 并不在乎你的应用程序是什么、做什么，Docker 提供了一组应用打包、传输和部署的方法，以便你能更好地在容器内运行任何应用。 下面的例子我自己经常使用，当然你有更好的案例也可以分享给我。 尝试新软件对开发者而言，每天会催生出的各式各样的新技术都需要尝试，然而开发者却不太可能为他们一一搭建好环境并进行测试。时间非常宝贵，正是得益于 Docker，让我们有可能在一条或者几条命令内就搭建完环境。Docker 有一个傻瓜化的获取软件的方法，Docker 后台会自动获得环境镜像并且运行环境。 并不仅仅是新技术环境搭建用得到 Docker。如果你想快速在你的笔记本上运行一个 MySQL 数据库，或者一个 Redis 消息队列，那么使用 Docker 便可以非常容易地做到。例如 Docker 只需要一条命令便可以运行 MySQL 数据库：docker run -d -p 3306:3306 tutum/mysql. 译者注：虽然使用命令也能非常快地安装 MySQL 数据库，但是当用到最新的技术或者非常复杂的技术时，使用 Docker 便会是个非常好的选择，例如 Gitlab，普通用户大概需要一天的时间去搭建 Gitlab 平台，而 Docker 则只需要一条命令 进行演示现在我经常需要在周末用自己开发的成果对客户活着别人做一两个演示。搭建演示环境的过程非常麻烦。现在我发现 Docker 已经成为我演示这些工具的最合理的方式。同时，对于客户来说，我可以直接将 Docker 镜像提供给他们，而不必去做任何环境配置的工作，工作的效果也会和在他们演示中所看到的一模一样，同时不必担心他们的环境配置会导致我们的产品无法运行。 避免“我机器上可以运行”无论是上一篇介绍的企业部署 Docker 还是本文的个人 Docker 用例，都提到了这个情况。因为环境配置不同，很多人在开发中也会遇到这个情况，甚至开发的软件到了测试人员的机器上便不能运行。但这都不是重点。重点是，如果我们有一个可靠的、可分发的标准开发环境，那么我们的开发将不会像现在这么痛苦。Docker 便可以解决这个问题。Docker 镜像并不会因为环境的变化而不能运行，也不会在不同的电脑上有不同的运行结果。可以给测试人员提交含有应用的 Docker 镜像，这样便不再会发生“在我机器上是可以运行的”这种事情，很大程度上减轻了开发人员测试人员互相检查机器环境设置带来的时间成本。 另一个 Docker 可以发挥用处的地方是培训班。除了 Docker 容器的隔离性之外，更能体会到 Docker 优势的地方在于环境搭建。培训班的新手每个人都要在环境搭建上花费很多时间，但是如果在这里应用到 Docker 的话，那么我们只需要把标准的运行环境镜像分发下去，然后就可以开始上课了。使用 Docker 和使用虚拟机一样简单，但是 Docker 要更方便、更轻量级。同时，我们也可以告诉学员：“在培训的同时，我们还将学到当下最流行的技术——Docker”，这种双赢的结局，何乐而不为呢。 学习 Linux 脚本当然这个原因看起来可能很奇怪，但是对不不熟悉 Linux 操作系统和 Shell 脚本的人来说，确实是一个好机会。即便本文并不是在讲 Linux，Linux 的重要度仍然不言而喻。如果你用的是 Windows，那么我给你一个建议：从云主机提供商那儿租用一台云主机：我推荐使用 CoreOS 系统的云主机。虽然这样并不会让你成为专业的 Linux 运维，但是可以让你快速地学到 Linux 基础知识，爱上命令行操作，并且慢慢开始熟悉和欣赏 Linux。 更好地利用资源虚拟机的粒度是“虚拟出的机器”，而 Docker 的粒度则是“被限制的应用”，相比较而言 Docker 的内存占用更少，更加轻量级。 对我来说这是 Docker 的一个优势：因为我经常在自己电脑中运行多个 Docker 应用，使用 Docker 比使用虚拟机更加简单，方便，粒度更细，也能持续地跟踪容器状态。 为微服务定制如果你一直在关注科技新闻的话，那么你应该听说过“微服务（Microservices）”的概念。Docker 可以很好地和微服务结合起来。从概念上来说，一个微服务便是一个提供一整套应用程序的部分功能，Docker 便可以在开发、测试和部署过程中一直充当微服务的容器。甚至生产环境也可以在 Docker 中部署微服务。 在云服务提供商之间移植大多数的云主机提供商已经全面支持 Docker。对于开发人员来说，这表示你可以很方便地切换云服务提供商，当然也可以很方便地将你本地的开发环境移动到云主机上，不需要本地上配置一次运行环境、在云主机上还配置一次运行环境。全面部署 Docker (Docker here and Docker there) 作为标准运行环境可以极大地减轻应用上线时的工作量和产生 BUG API 端API 是应用之间的粘合剂，一个合格开发者肯定使用过别人提供的 REST API，或者自己开发过 REST API。需要指出的是，无论是客户端还是 API 提供端，在开发之前都需要先定义一组公共的 API 接口，写成文档，然后才能进行编码。如果服务端和客户端是共同开发的话，那么服务端通常会先实现能返回固定字符串的 API 接口，在以后的开发中再慢慢去实现 API 的功能。 虽然有人会认为在这里 Docker 被滥用了，完全可以用 sample.json 这种文件去实现虚拟 API，但是下面有个实例可以更好地解决前后端分离开发时的 API 问题。 为了更好地解释我的意思，给大家提供一个实例：JSON Server，一个用于提供 JSON 数据的 REST API。使用过这个容器的人就会知道，既然有这么好用的 Docker JSON Server，我们没有理由不用 Docker。 译者注： 运行示例的 JSON Server，同时使用示例中提供的 JSON 文件，只需执行一条命令便可以创建一个服务端的 API 应用。 使用 curl http://127.0.0.1:80/posts 即可获取示例文件中的 posts 段，这样在后端没有开发完 API 的时候，前端一样可以进行协同开发。 技术的创新这点应该算不上是用例，但是我还是来写一下。Docker 正在快速发展，工具也在不断更新，没有人能预见到未来 Docker 会是什么样子的。你在复杂的系统中 Docker 使用的越多，越是可能会发现技术上的空白和未来技术发展的方向。现在还处在 Docker 的发展期，任何你使用 Docker 创建的工具都有可能成为社区关注的热点。这是 Docker 的机会，也是成就你自己的机会。 其他还有两个技巧可以分享给你们。在学习 Docker 的过程中因为有了这两个的帮助，我才得意不断地提升自己。 一：Docker Hub。这是 Docker 的官方镜像仓库，除了托管着 Docker 官方的镜像外，和 Github 一样，你可以在上面上传自己的镜像，也可以在上面搜寻其他有用的镜像，极大地节省自己的时间。例如 Oracle-XE-11g 镜像，所有的一切都是现成的，完全不需要自己去下载 Oracle XE 11g 安装。这样为你和团队节约了大量的时间成本。 如果你不太确定的话，可以去 Docker Hub 上搜有一下有没有自己用得到的镜像。大部分情况下你所需要的镜像在 Docker Hub 上都已经有人构建了。 二：多参考 IaaS 供应商的新闻，虽然我们不能像在他们会议室里那样完全了解他们的公司动态，但是仍然可以从新闻中可以了解到 Docker 最新的发展方向和技术趋势。可以肯定的是，容器化技术是未来的热点，我们不仅可以在本机运行 Docker，不仅仅在一家云服务提供商的主机上运行 Docker，未来所有的云服务提供商都会支持 Docker。 Docker 前景很明确，采用 Docker 只会让开发变得更方便。 原文链接：Docker是什么？可以用Docker做什么？！]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL(解压版)安装教程]]></title>
    <url>%2F2019%2F01%2F21%2Fblog20190121%2F</url>
    <content type="text"><![CDATA[前言MySQL是一种开放源代码的关系型数据库管理系统（RDBMS），MySQL数据库系统使用最常用的数据库管理语言–结构化查询语言（SQL）进行数据库管理。由于MySQL是开放源代码的，因此任何人都可以在General Public License的许可下下载并根据个性化的需要对其进行修改。MySQL因为其速度、可靠性和适应性而备受关注。大多数人都认为在不需要事务化处理的情况下，MySQL是管理内容最好的选择。 MySQL安装MySQL分为安装版和解压版，个人推荐解压版MySQL，详细步骤如下： 下载访问地址MySQL官网下载地址，目前最新版是8.0.13。如果你不想下载最新版，想下载以前的版本，可以点击如下图的链接进行下载： 根据你的系统（32位或者64位）选择后缀是ZIP Archive的压缩包下载到本地，这里我选择的是5.7.21版本，如图： 点击Download进入下载页，这里要求你注册登陆, 不用管直接点击No thanks, just start my download， 按钮进行下载，如下图所示： 解压选择一个路径（建议将常用的工具分类放在同一文件夹如D:\MySQL）解压压缩包。 配置my.ini需要新建一个my.ini文件，在my.ini文件中添加如下信息： 12345678910111213141516[mysql]#设置mysql客户端默认字符集default-character-set=utf8[mysqld]#设置3306端口port=3306# 设置mysql的安装目录basedir=D:\MySQL\mysql-5.7.21-winx64# 设置mysql数据库的数据的存放目录datadir=D:\MySQL\mysql-5.7.21-winx64\data# 允许最大连接数max_connections=200# 服务端使用的字符集默认为8比特编码的latin1字符集character-set-server=utf8# 创建新表时将使用的默认存储引擎default-storage-engine=INNODB 配置环境变量 右键计算机–属性–高级系统设置–环境变量，新建系统变量MySQL_HOME，添加MySQL解压的目录（我这里是D:\MySQL\mysql-5.7.21-winx64）； 在系统变量中找到Path编辑，在结尾处追加%MySQL_HOME%\bin;，如果原变量值结尾没有分号，需要先加分号。如下图所示： 配置环境变量后启动MySQL就不必到MySQL的bin目录下启动了，直接在cmd中直接输入net start mysql 启动服务了。 初始化MySQLwin7用户使用window+R（更高系统版本需要搜索程序cmd右键以管理员身份运行）以管理员身份运行cmd，依次输入命令d:，cd D:\MySQL\mysql-5.7.21-winx64\bin进入MySQL的bin目录，执行mysqld --initialize进行初始化，此时你的MySQL根目录下会生成一个data文件夹，如下图所示： 安装启动MySQL服务还是在bin路径下输入：mysqld install，此时会提示服务安装成功。至此，MySQL（解压版）安装成功！直接在cmd中输入：net start mysql，提示服务启动成功。 登录MySQLcmd输入：mysql -u root -p,这时会提示你输入密码。打开MySQL根目录下的data文件夹，找到后缀是.err的文件以文本打开找到password临时密码（可以ctrl+f搜索）然后在cmd中输入该临时密码。当cmd出现下图信息则代表登录成功。 修改root密码在上述的mysql&gt;后输入：set password for 用户名@localhost = password(&#39;新密码&#39;);，用户名一般是root，并设置新密码，如图所示： 停止服务cmd输入：net stop mysql，提示服务已成功停止。 结尾好了，到这里MySQL就已经安装完成了，祝大家顺利安装！]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL数据类型]]></title>
    <url>%2F2019%2F01%2F14%2Fblog20190114%2F</url>
    <content type="text"><![CDATA[前言MySQL中定义数据字段的类型对数据库的优化是非常重要的，MySQL支持多种类型，大致可以分为五类：整数类型、浮点数类型、日期类型、字符串类型和其他数据类型。对于Mysql的一些常用数据类型了解程度仅限于一知半解，仅仅能满足满足于平时一些最简单的操作。而Mysql常用数据类型的定义以及规范理解的并不是特别的透彻，对于这些东西的理解并不深刻，经不起推敲和较真。故有此文，帮助自己总结归纳，并加深理解。 MySQL的数据类型主要包括以下五大类：整数类型：BIT、BOOL、TINY INT、SMALL INT、MEDIUM INT、 INT、 BIG INT浮点数类型：FLOAT、DOUBLE、DECIMAL字符串类型：CHAR、VARCHAR、TINY TEXT、TEXT、MEDIUM TEXT、LONGTEXT、TINY BLOB、BLOB、MEDIUM BLOB、LONG BLOB日期类型：Date、DateTime、TimeStamp、Time、Year其他数据类型：BINARY、VARBINARY、ENUM、SET、Geometry、Point、MultiPoint、LineString、MultiLineString、Polygon、GeometryCollection等 整型 MySQL数据类型 含义（有符号） tinyint(m) 1个字节 范围(-128~127) smallint(m) 2个字节 范围(-32768~32767) mediumint(m) 3个字节 范围(-8388608~8388607) int(m) 4个字节 范围(-2147483648~2147483647) bigint(m) 8个字节 范围(+-9.22*10的18次方) 取值范围如果加了unsigned，则最大值翻倍，如tinyint unsigned的取值范围为(0~256)。int(m)里的m是表示SELECT查询结果集中的显示宽度，并不影响实际的取值范围，没有影响到显示的宽度，不知道这个m有什么用。 浮点型(float和double) MySQL数据类型 含义 float(m,d) 单精度浮点型 8位精度(4字节) m总个数，d小数位 double(m,d) 双精度浮点型 16位精度(8字节) m总个数，d小数位 设一个字段定义为float(6,3)，如果插入一个数123.45678,实际数据库里存的是123.457，但总个数还以实际为准，即6位。整数部分最大是3位，如果插入数12.123456，存储的是12.1234，如果插入12.12，存储的是12.1200. 定点数浮点型在数据库中存放的是近似值，而定点类型在数据库中存放的是精确值。decimal(m,d) 参数m&lt;65 是总个数，d&lt;30且 小于m是小数位。 字符串(char,varchar,_text) MySQL数据类型 含义 char(n) 固定长度，最多255个字符 varchar(n) 固定长度，最多65535个字符 tinytext 可变长度，最多255个字符 text 可变长度，最多65535个字符 mediumtext 可变长度，最多2的24次方-1个字符 longtext 可变长度，最多2的32次方-1个字符 char和varchar： char(n) 若存入字符数小于n，则以空格补于其后，查询之时再将空格去掉。所以char类型存储的字符串末尾不能有空格，varchar不限于此。 char(n) 固定长度，char(4)不管是存入几个字符，都将占用4个字节，varchar是存入的实际字符数+1个字节（n&lt;=255）或2个字节(n&gt;255)，所以varchar(4),存入3个字符将占用4个字节。 char类型的字符串检索速度要比varchar类型的快。 varchar和text： varchar可指定n，text不能指定，内部存储varchar是存入的实际字符数+1个字节（n&lt;=255）或2个字节(n&gt;255)，text是实际字符数+2个字节。 text类型不能有默认值。 varchar可直接创建索引，text创建索引要指定前多少个字符。varchar查询速度快于text,在都创建索引的情况下，text的索引似乎不起作用。 二进制数据(_Blob) _BLOB和_text存储方式不同，_TEXT以文本方式存储，英文存储区分大小写，而_Blob是以二进制方式存储，不分大小写。 _BLOB存储的数据只能整体读出。 _TEXT可以指定字符集，_BLO不用指定字符集。 日期时间类型 MySQL数据类型 含义 date 日期 ‘2019-01-12’ time 时间 ‘12:25:36’ datetime 日期时间 ‘2019-01-12 22:06:44’ timestamp 自动存储记录修改时间 若定义一个字段为timestamp，这个字段里的时间数据会随其他字段修改的时候自动刷新，所以这个数据类型的字段可以存放这条记录最后被修改的时间。 数据类型的属性 MySQL数据类型 含义 NULL 数据列可包含NULL值 NOT NULL 数据列不允许包含NULL值 DEFAULT 默认值 PRIMARY KEY 主键 AUTO_INCREMENT 自动递增，适用于整数类型 UNSIGNED 无符号 CHARACTER SET name 指定一个字符集 MySQL数据类型的长度和范围各数据类型及字节长度一览表： MySQL数据类型 字节长度 范围或用法 Bit 1 无符号[0,255]，有符号[-128,127]，天缘博客备注：BIT和BOOL布尔型都占用1字节 TinyInt 1 整数[0,255] SmallInt 2 无符号[0,65535]，有符号[-32768,32767] MediumInt 3 无符号[0,2^24-1]，有符号[-2^23,2^23-1]] Int 4 无符号[0,2^32-1]，有符号[-2^31,2^31-1] BigInt 8 无符号[0,2^64-1]，有符号[-2^63 ,2^63 -1] Float(M,D) 4 单精度浮点数。天缘博客提醒这里的D是精度，如果D&lt;=24则为默认的FLOAT，如果D&gt;24则会自动被转换为DOUBLE型。 Double(M,D) 8 双精度浮点。 Decimal(M,D) M+1或M+2 未打包的浮点数，用法类似于FLOAT和DOUBLE，天缘博客提醒您如果在ASP中使用到Decimal数据类型，直接从数据库读出来的Decimal可能需要先转换成Float或Double类型后再进行运算。 Date 3 以YYYY-MM-DD的格式显示，比如：2009-07-19 Datetime 8 以YYYY-MM-DD HH:MM:SS的格式显示，比如：2009-07-19 11：22：30 TimeStamp 4 以YYYY-MM-DD的格式显示，比如：2009-07-19 Time 3 以HH:MM:SS的格式显示。比如：11：22：30 Year 1 以YYYY的格式显示。比如：2009 Char(M) M 定长字符串。 VarChar(M) M 变长字符串，要求M&lt;=255 Binary(M) M 类似Char的二进制存储，特点是插入定长不足补0 VarBinary(M) M 类似VarChar的变长二进制存储，特点是定长不补0 Tiny Text Max:255 大小写不敏感 Text Max:64K 大小写不敏感 Medium Text Max:16M 大小写不敏感 Long Tex t Max:4G 大小写不敏感 TinyBlob Max:255 大小写敏感 Blob Max:64K 大小写敏感 MediumBlob Max:16M 大小写敏感 LongBlob Max:4G 大小写敏感 Enum 1或2 最大可达65535个不同的枚举值 Set 可达8 最大可达64个不同的值 Geometry Point LineString Polygon MultiPoint MultiLineString MultiPolygon GeometryCollection MySQL数据类型使用建议 在指定数据类型的时候一般是采用从小原则，比如能用TINY INT的最好就不用INT，能用FLOAT类型的就不用DOUBLE类型，这样会对MYSQL在运行效率上提高很大，尤其是大数据量测试条件下。 不需要把数据表设计的太过复杂，功能模块上区分或许对于后期的维护更为方便，慎重出现大杂烩数据表 数据表和字段的起名字也是一门学问 设计数据表结构之前请先想象一下是你的房间，或许结果会更加合理、高效 数据库的最后设计结果一定是效率和可扩展性的折中，偏向任何一方都是欠妥的 附录：选择数据类型的基本原则前提：使用合适的存储引擎。选择原则：根据选定的存储引擎，确定如何选择合适的数据类型。下面的选择方法按存储引擎分类： MyISAM 数据存储引擎和数据列：MyISAM数据表，最好使用固定长度(CHAR)的数据列代替可变长度(VARCHAR)的数据列。 MEMORY存储引擎和数据列：MEMORY数据表目前都使用固定长度的数据行存储，因此无论使用CHAR或VARCHAR列都没有关系。两者都是作为CHAR类型处理的。 InnoDB 存储引擎和数据列：建议使用 VARCHAR类型。 对于InnoDB数据表，内部的行存储格式没有区分固定长度和可变长度列（所有数据行都使用指向数据列值的头指针），因此在本质上，使用固定长度的CHAR列不一定比使用可变长度VARCHAR列简单。因而，主要的性能因素是数据行使用的存储总量。由于CHAR平均占用的空间多于VARCHAR，因 此使用VARCHAR来最小化需要处理的数据行的存储总量和磁盘I/O是比较好的。 char与varcharCHAR和VARCHAR类型类似，但它们保存和检索的方式不同。它们的最大长度和是否尾部空格被保留等方面也不同。在存储或检索过程中不进行大小写转换。下面的表显示了将各种字符串值保存到CHAR(4)和VARCHAR(4)列后的结果，说明了CHAR和VARCHAR之间的差别： 值 CHAR(4) 存储需求 VARCHAR(4) 存储需求 ‘’ ‘ ‘ 4个字节 ‘’ 1个字节 ‘ab’ ‘ab ‘ 4个字节 ‘ab ‘ 3个字节 ‘abcd’ ‘abcd’ 4个字节 ‘abcd’ 5个字节 ‘abcdefgh’ ‘abcd’ 4个字节 ‘abcd’ 5个字节 请注意上表中最后一行的值只适用不使用严格模式时；如果MySQL运行在严格模式，超过列长度不的值不保存，并且会出现错误。从CHAR(4)和VARCHAR(4)列检索的值并不总是相同，因为检索时从CHAR列删除了尾部的空格。 text和blob在使用text和blob字段类型时要注意以下几点，以便更好的发挥数据库的性能。 BLOB和TEXT值也会引起自己的一些问题，特别是执行了大量的删除或更新操作的时候。删除这种值会在数据表中留下很大的”空洞”，以后填入这些”空洞”的记录可能长度不同,为了提高性能,建议定期使用 OPTIMIZE TABLE 功能对这类表进行碎片整理. 使用合成的（synthetic）索引。合成的索引列在某些时候是有用的。一种办法是根据其它的列的内容建立一个散列值，并把这个值存储在单独的数据列中。接下来你就可以通过检索散列值找到数据行了。但是，我们要注意这种技术只能用于精确匹配的查询（散列值对于类似&lt;或&gt;=等范围搜索操作符 是没有用处的）。我们可以使用MD5()函数生成散列值，也可以使用SHA1()或CRC32()，或者使用自己的应用程序逻辑来计算散列值。请记住数值型散列值可以很高效率地存储。同样，如果散列算法生成的字符串带有尾部空格，就不要把它们存储在CHAR或VARCHAR列中，它们会受到尾部空格去除的影响。合成的散列索引对于那些BLOB或TEXT数据列特别有用。用散列标识符值查找的速度比搜索BLOB列本身的速度快很多。 在不必要的时候避免检索大型的BLOB或TEXT值。例如，SELECT *查询就不是很好的想法，除非你能够确定作为约束条件的WHERE子句只会找到所需要的数据行。否则，你可能毫无目的地在网络上传输大量的值。这也是 BLOB或TEXT标识符信息存储在合成的索引列中对我们有所帮助的例子。你可以搜索索引列，决定那些需要的数据行，然后从合格的数据行中检索BLOB或 TEXT值。 把BLOB或TEXT列分离到单独的表中。在某些环境中，如果把这些数据列移动到第二张数据表中，可以让你把原数据表中 的数据列转换为固定长度的数据行格式，那么它就是有意义的。这会减少主表中的碎片，使你得到固定长度数据行的性能优势。它还使你在主数据表上运行 SELECT *查询的时候不会通过网络传输大量的BLOB或TEXT值。 浮点数与定点数为了能够引起大家的重视，在介绍浮点数与定点数以前先让大家看一个例子： 12345678910111213mysql&gt; CREATE TABLE test (c1 float(10,2),c2 decimal(10,2));Query OK, 0 rows affected (0.29 sec)mysql&gt; insert into test values(131072.32,131072.32);Query OK, 1 row affected (0.07 sec)mysql&gt; select * from test;+-----------+-----------+| c1 | c2 |+-----------+-----------+| 131072.31 | 131072.32 |+-----------+-----------+1 row in set (0.00 sec) 从上面的例子中我们看到c1列的值由131072.32变成了131072.31，这就是浮点数的不精确性造成的。在mysql中float、double（或real）是浮点数，decimal（或numberic）是定点数。浮点数相对于定点数的优点是在长度一定的情况下，浮点数能够表示更大的数据范围；它的缺点是会引起精度问题。在今后关于浮点数和定点数的应用中，大家要记住以下几点： 浮点数存在误差问题； 对货币等对精度敏感的数据，应该用定点数表示或存储； 编程中，如果用到浮点数，要特别注意误差问题，并尽量避免做浮点数比较； 要注意浮点数中一些特殊值的处理。 结尾关于Mysql的数据类型，就总结记录到这里，以后会继续补充，希望能给大家带来帮助！]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL常见的存储引擎]]></title>
    <url>%2F2019%2F01%2F04%2Fblog20190104%2F</url>
    <content type="text"><![CDATA[前言数据库存储引擎是数据库底层软件组织，数据库管理系统（DBMS）使用数据引擎进行创建、查询、更新和删除数据。不同的存储引擎提供不同的存储机制、索引技巧、锁定水平等功能，使用不同的存储引擎，还可以获得特定的功能。现在许多不同的数据库管理系统都支持多种不同的数据引擎,MySQL的核心就是存储引擎。在MySQL中的存储引擎有很多种，可以通过“SHOW ENGINES”语句来查看。下面重点关注InnoDB、MyISAM、MEMORY这三种。 InnoDB存储引擎 InnoDB给MySQL的表提供了事务处理、回滚、崩溃修复能力和多版本并发控制的事务安全。在MySQL从3.23.34a开始包含InnnoDB。它是MySQL上第一个提供外键约束的表引擎。而且InnoDB对事务处理的能力，也是其他存储引擎不能比拟的。靠后版本的MySQL的默认存储引擎就是InnoDB。 InnoDB存储引擎总支持AUTO_INCREMENT。自动增长列的值不能为空，并且值必须唯一。MySQL中规定自增列必须为主键。在插入值的时候，如果自动增长列不输入值，则插入的值为自动增长后的值；如果输入的值为0或空（NULL），则插入的值也是自动增长后的值；如果插入某个确定的值，且该值在前面没有出现过，就可以直接插入。 InnoDB还支持外键（FOREIGN KEY）。外键所在的表叫做子表，外键所依赖（REFERENCES）的表叫做父表。父表中被字表外键关联的字段必须为主键。当删除、更新父表中的某条信息时，子表也必须有相应的改变，这是数据库的参照完整性规则。 InnoDB中，创建的表的表结构存储在.frm文件中。数据和索引存储在innodb_data_home_dir和innodb_data_file_path定义的表空间中。 InnoDB的优势在于提供了良好的事务处理、崩溃修复能力和并发控制。缺点是读写效率较差，占用的数据空间相对较大。 MyISAM存储引擎 MyISAM是MySQL中常见的存储引擎，曾经是MySQL的默认存储引擎。MyISAM是基于ISAM引擎发展起来的，增加了许多有用的扩展。 MyISAM的表存储成3个文件。文件的名字与表名相同。拓展名为frm、MYD、MYI。其实，frm文件存储表的结构；MYD文件存储数据，是MYData的缩写；MYI文件存储索引，是MYIndex的缩写。 基于MyISAM存储引擎的表支持3种不同的存储格式。包括静态型、动态型和压缩型。其中，静态型是MyISAM的默认存储格式，它的字段是固定长度的；动态型包含变长字段，记录的长度不是固定的；压缩型需要用到myisampack工具，占用的磁盘空间较小。 MyISAM的优势在于占用空间小，处理速度快。缺点是不支持事务的完整性和并发性。 MEMORY存储引擎 MEMORY是MySQL中一类特殊的存储引擎。它使用存储在内存中的内容来创建表，而且数据全部放在内存中。这些特性与前面的两个很不同。 每个基于MEMORY存储引擎的表实际对应一个磁盘文件。该文件的文件名与表名相同，类型为frm类型。该文件中只存储表的结构。而其数据文件，都是存储在内存中，这样有利于数据的快速处理，提高整个表的效率。值得注意的是，服务器需要有足够的内存来维持MEMORY存储引擎的表的使用。如果不需要了，可以释放内存，甚至删除不需要的表。 MEMORY默认使用哈希索引。速度比使用B型树索引快。当然如果你想用B型树索引，可以在创建索引时指定。 注意，MEMORY用到的很少，因为它是把数据存到内存中，如果内存出现异常就会影响数据。如果重启或者关机，所有数据都会消失。因此，基于MEMORY的表的生命周期很短，一般是一次性的。 存储引擎的选择不同的存储引擎都有各自的特点，以适应不同的需求，如下表所示： 特性 InnoDB MyISAM MEMORY 存储限制 支持 无 无 事物安全 64TB 有 有 空间使用 高 低 低 内存使用 高 低 高 插入速度 低 高 高 外键支持 支持 无 无 InnoDB：支持事务处理，支持外键，支持崩溃修复能力和并发控制。如果需要对事务的完整性要求比较高（比如银行），要求实现并发控制（比如售票），那选择InnoDB有很大的优势。如果需要频繁的更新、删除操作的数据库，也可以选择InnoDB，因为支持事务的提交（commit）和回滚（rollback）。 MyISAM：插入数据快，空间和内存使用比较低。如果表主要是用于插入新记录和读出记录，那么选择MyISAM能实现处理高效率。如果应用的完整性、并发性要求比 较低，也可以使用。 MEMORY：所有的数据都在内存中，数据的处理速度快，但是安全性不高。如果需要很快的读写速度，对数据的安全性要求较低，可以选择MEMOEY。它对表的大小有要求，不能建立太大的表。所以，这类数据库只使用在相对较小的数据库表。 注意，同一个数据库也可以使用多种存储引擎的表。如果一个表要求比较高的事务处理，可以选择InnoDB。这个数据库中可以将查询要求比较高的表选择MyISAM存储。如果该数据库需要一个用于查询的临时表，可以选择MEMORY存储引擎。 结尾使用哪一种引擎需要灵活选择，一个数据库中多个表可以使用不同引擎以满足各种性能和实际需求，使用合适的存储引擎，将会提高整个数据库的性能。MySQL常见的存储引擎就介绍到这里了！]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sublime Text3安装教程]]></title>
    <url>%2F2019%2F01%2F04%2Fblog20181214%2F</url>
    <content type="text"><![CDATA[前言Sublime Text是2008年开发出来的一个代码编辑器，界面友好，功能非凡， 默认支持html, xml, javascript, ruby, python, php… 等等主流语言的语法高亮，它支持众多插件扩展，用它来写代码，绝对是一种享受。但是ST再强大也只是一个文本编辑器，不是真正意义上的IDE,像打断点调试这样的ST是做不到的。 Sublime Text3安装Windows系统下访问sublimetext官网，点击DOWNLOAD FOR WINDOWS按钮下载最新版，这里下载的是3176版本，如下图所示： 下载完成后，运行程序开始安装，点击Next,选择合适的安装目录后Next，点击Install开始安装。安装完成后，运行Sublime后点击Help选项里的Enter License选项，将激活码填入即可，如下图所示：12345678910111213----- BEGIN LICENSE -----sgbteamSingle User LicenseEA7E-11532598891CBB9 F1513E4F 1A3405C1 A865D53F115F202E 7B91AB2D 0D2A40ED 352B269B76E84F0B CD69BFC7 59F2DFEF E267328F215652A3 E88F9D8F 4C38E3BA 5B2DAAE4969624E7 DC9CD4D5 717FB40C 1B9738CF20B3C4F1 E917B5B3 87C38D9C ACCE7DD85F7EF854 86B9743C FADC04AA FB0DA5C0F913BE58 42FEA319 F954EFDD AE881E0B------ END LICENSE ------ 安装常用插件直接安装安装Sublime text3插件很方便，可以直接下载安装包解压缩到Packages目录（preferences-&gt;Browse Packages）。 使用Package Control组件安装（以LESS为例） 按Ctrl+ `(此符号为tab按键上面的按键) 调出console（注：避免热键冲突） 粘贴以下代码到命令行并回车： 123import urllib.request,os; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path();urllib.request.install_opener ( urllib.request.build_opener( urllib.request.ProxyHandler()) );open(os.path.join(ipp, pf), &apos;wb&apos;).write(urllib.request.urlopen ( &apos;http://sublime.wbond.net/&apos; + pf.replace(&apos; &apos;,&apos;%20&apos;)).read()) 重启Sublime Text 3。 如果在Perferences-&gt;package settings中看到package control这一项，则安装成功。 Package Control安装插件的方法: 按下Ctrl+Shift+P调出命令面板 输入install 调出 Install Package 选项并回车，如下图所示： 然后在列表中选择要安装的插件,如图所示： 等待一会即可完成安装！ 结尾好了，到这里Sublime Text3就已经安装完成了，大家赶紧去尝试，享受编码的乐趣吧！]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[IDEA安装教程]]></title>
    <url>%2F2019%2F01%2F04%2Fblog20181211%2F</url>
    <content type="text"><![CDATA[前言说起Java的IDE,大家琅琅上口的不外乎Jbuilder,Eclipse,NetBeans这三个,如果你只是想找个IDE来学习Java，或者你需要漂亮的图标，再或者你的电脑配置并不高，那么Eclipse是个不错的选择。如果你想找个能提升开发效率的IDE，想找一个更快更方便的工具，推荐你用IntelliJ IDEA。 IntelliJ IDEA优势 更好的调试。IntelliJ IDEA在调试上的表现，可以说比Eclipse强大太多。在调试过程中哦，当我们需要求一些表达式的值时，如果使用Eclipse就需要选定整个表达式，然后用Crtl+Shift+I看到这个表达式的值。但是，在IntelliJ IDEA中，只需要移动光标到表达式下然后用Alt+F8就可以实现。IntelliJ IDEA能够很好地理解你可能需要的表达式，还会给出的建议参数变量。你可以直接编辑并能立刻得到这个表达式的值，不会像在Eclipse中一个Debug界面跳来跳去。 更高的开发效率。IntelliJ IDEA在代码自动生成方面表现比Eclipse更为智能，比如IntelliJ IDEA能生成某个类的测试类，还能正确地放到test的相应目录下。在对ZenCoding的支持上，写html非常方便，tab快速补全，和原生集成一样。IntelliJ IDEA在开发效率上更明显的一点是，对JS、CSS以及插件的支持更好。 更智能的重构。这一点其实也属于开发效率，但是IntelliJ IDEA得重构功能还是想让我单独强调一下。所有的现代IDE都提供重构功能，这一点上，IntelliJ IDEA能读懂你需要什么，并且会针对不同的情况给你提供最合适的解决方案。 目录分层少而清。IntelliJ IDEA的目录分层很少，但是却很清晰，IDE配置的东西都能在Settings利找到，工程的配置也能在Project Settings里找到。 IntelliJ IDEA安装访问地址IDEA历史版本，选择合适的版本，这里楼主选择的是15.0.6终极版。如图： 点击下载,下载完成后，运行程序开始安装，点击Next，选择合适的安装目录后Next，勾选Create Desktop shortcut创建桌面快捷方式Next后点击Install开始安装。几分钟后安装完成关闭安装页面。打开桌面上的IntelliJ IDEA 15.0.6，进入页面后选择合适的主题，点击Register激活产品！ 访问地址获取激活码，点击获得注册码，将注册码复制粘贴到框里即可! 结尾好了，到这里IDEA就已经安装完成了，大家赶紧去尝试，享受编码的乐趣吧！]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java8十大新特性整理]]></title>
    <url>%2F2019%2F01%2F04%2Fblog20181210%2F</url>
    <content type="text"><![CDATA[前言Java8已经发布很久了，毫无疑问，这是继java5之后一次重大的版本升级，这个版本包含语言、编译器、库、工具和JVM等方面的十多个新特性。有人认为，虽然这些新特性领Java开发人员十分期待，但同时也需要花不少精力去学习。因此，本文综合了一些资料，整理成一份关于Java 8新特性的参考教材，希望你有所收获。本文中所用的实例请点击：Java8新特性实例 Lambda表达式语法Lambda表达式的语法格式如下：(parameters)-&gt;expression 或 (parameters)-&gt;{statements;} 以下是Lambda表达式的重要特征： 可选类型声明：不需要声明参数类型，编译器可以统一识别参数值； 可选参数圆括号：一个参数无需定义圆括号，但多个参数需要定义圆括号； 可选的大括号：如果主体包含了一个语句，就不需要使用大括号； 可选的返回关键字：如果主体只有一个返回值则编译器会自动返主体回值，大括号需要指定表达式返回一个数值。 使用Lambda表达式需要注意以下两点： 使用Lambda表达式主要用来定义执行行内执行的方法类型接口，例如，一个简单方法接口。在上面例子中，我们使用各种类型的Lambda表达式来定义MathOperation接口的方法，然后我们定义了sayMessage的执行。 Lambda表达式免去了使用匿名方法的麻烦，并且给予Java简单但强大的函数化的编程能力。 变量作用域注意点： Lambda表达式只能引用标记了 final 的外层局部变量，这就是说不能在lambda 内部修改定义在域外的局部变量，否则会编译错误。 Lambda表达式的局部变量可以不用声明为 final，但是必须不可被后面的代码修改（即隐性的具有final 的语义） Lambda表达式当中不允许声明一个与局部变量同名的参数或者局部变量。 Lambda表达式实例以下是Lambda的使用实例：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * @Package: com.swz * @Description: Lambda测试 * @author: swz * @date: 2018/11/29 10:30 */public class LambdaTest &#123; final static String salutation = &quot;Hello! &quot;; public static void main(String[] args) &#123; LambdaTest LambdaTest = new LambdaTest(); // 类型声明 MathOperation addition = (int a, int b) -&gt; a + b; // 不用类型声明 MathOperation subtraction = (a, b) -&gt; a - b; // 大括号中的返回值 MathOperation multiplication = (int a, int b) -&gt; &#123; return a * b; &#125;; // 没有大括号及返回语句 MathOperation division = (int a, int b) -&gt; a / b; System.out.println(&quot;10 + 5 = &quot; + LambdaTest.operate(10, 5, addition)); System.out.println(&quot;10 - 5 = &quot; + LambdaTest.operate(10, 5, subtraction)); System.out.println(&quot;10 x 5 = &quot; + LambdaTest.operate(10, 5, multiplication)); System.out.println(&quot;10 / 5 = &quot; + LambdaTest.operate(10, 5, division)); // 不用括号 GreetingService greetService1 = message -&gt; System.out.println(&quot;Hello &quot; + message); // 用括号 GreetingService greetService2 = (message) -&gt; System.out.println(salutation + message); greetService1.sayMessage(&quot;Runoob&quot;); greetService2.sayMessage(&quot;Google&quot;); &#125; interface MathOperation &#123; int operatation(int a, int b); &#125; interface GreetingService &#123; void sayMessage(String message); &#125; private int operate(int a, int b, MathOperation mathOperation) &#123; return mathOperation.operatation(a, b); &#125;&#125; Java8方法引用方法引用通过方法的名字来指向一个方法。方法引用可以使语言的构造更紧凑简洁，减少冗余代码。方法引用使用一对冒号 :: 。 方法引用实例以下是方法引用的使用实例：1234567891011121314151617/** * @Package: com.swz * @Description: 方法引用 * @author: swz * @date: 2018/11/29 13:45 */public class MethodQuoteTest &#123; public static void main(String[] args) &#123; List names = new ArrayList&lt;&gt;(); names.add(&quot;Google&quot;); names.add(&quot;SWZ&quot;); names.add(&quot;taobao&quot;); names.forEach(System.out::println); &#125;&#125; Java8函数式接口函数式接口(FunctionalInterface)是一个有且仅有一个抽象方法，但可以有多个非抽象方法的接口。函数式接口可以被隐式转换为Lambda表达式。函数式接口可以现有的函数友好地支持Lambda。 函数式接口实例Predicate 接口是一个函数式接口，它接受一个输入参数 T，返回一个布尔值结果。该接口包含多种默认方法来将Predicate组合成其他复杂的逻辑（比如：与，或，非）。该接口用于测试对象是 true 或 false。 以下是函数式接口的实例：1234567891011121314151617181920212223242526272829/** * @Package: com.swz * @Description: 函数式接口 * @author: swz * @date: 2018/11/29 14:30 */public class FunctionalInterfaceTest &#123; public static void main(String[] args) &#123; List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9); Predicate&lt;Integer&gt; predicate = n -&gt; n % 2 == 0; // 传递参数 n System.out.print(&quot;输出所有偶数: &quot;); eval(list, predicate); Predicate&lt;Integer&gt; predicate2 = n -&gt; n &gt; 3; System.out.print(&quot;\n输出大于3的所有数字: &quot;); eval(list, predicate2 ); &#125; public static void eval(List&lt;Integer&gt; list, Predicate&lt;Integer&gt; predicate) &#123; for (Integer i : list) &#123; if (predicate.test(i)) &#123; System.out.print(i + &quot; &quot;); &#125; &#125; &#125;&#125; Java8默认方法 简单说，默认方法就是接口可以有实现方法，而且不需要实现类去实现其方法; 我们只需在方法名前面加个default关键字即可实现默认方法。 默认方法是为了解决接口的修改与现有的实现不兼容的问题。 另一个特性是接口可以声明（并且可以提供实现）静态方法 默认方法实例以下是默认方法的使用实例：123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * @Package: com.swz * @Description: 默认方法 * @author: swz * @date: 2018/11/29 15:01 */public class DefaultMethodTest &#123; public static void main(String[] args) &#123; Vehicle vehicle = new Car(); vehicle.print(); &#125; interface Vehicle &#123; default void print() &#123; System.out.println(&quot;我是一辆车!&quot;); &#125; // 静态方法 static void blowHorn() &#123; System.out.println(&quot;按喇叭!!!&quot;); &#125; &#125; interface FourWheeler &#123; default void print() &#123; System.out.println(&quot;我是一辆四轮车!&quot;); &#125; &#125; static class Car implements Vehicle, FourWheeler &#123; //@Override //public void print() &#123; // System.out.println(&quot;我是一辆四轮汽车!&quot;); //&#125; public void print() &#123; Vehicle.super.print(); FourWheeler.super.print(); Vehicle.blowHorn(); System.out.println(&quot;我是一辆汽车!&quot;); &#125; &#125;&#125; Java8 流StreamStream使用一种类似用SQL语句从数据库查询数据的直观方式来提供一种对Java集合运算和表达的高阶抽象;Stream API可以极大提高Java程序员的生产力，让程序员写出高效率、干净、简洁的代码;这种风格将要处理的元素集合看作一种流，流在管道中传输，并且可以在管道的节点上进行处理，比如筛选，排序，聚合等;元素流在管道中经过中间操作（intermediate operation）的处理，最后由最终操作(terminal operation)得到前面处理的结果。 什么是StreamStream（流）是一个来自数据源的元素队列并支持聚合操作; 元素：是特定类型的对象，形成一个队列。Java中的Stream并不会存储元素，而是按需计算; 数据源 ：流的来源。可以是集合，数组，I/O channel，产生器generator等; 聚合操作： 类似SQL语句一样的操作，比如filter, map, reduce, find,match, sorted等。 Stream流特征 Pipelining:：中间操作都会返回流对象本身。这样多个操作可以串联成一个管道，如同流式风格（fluent style）。这样做可以对操作进行优化，比如延迟执行(laziness)和短路( short-circuiting)。 内部迭代：以前对集合遍历都是通过Iterator或者For-Each的方式,显式的在集合外部进行迭代，这叫做外部迭代。Stream提供了内部迭代的方式，通过访问者模式(Visitor)实现。 Stream流实例以下是Stream流的使用实例:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * @Package: com.swz * @Description: 流Stream * @author: swz * @date: 2018/11/29 15:17 */public class StreamTest &#123; public static void main(String[] args) &#123; // stream() −为集合创建串行流。 // parallelStream() − 为集合创建并行流。 List&lt;String&gt; strings = Arrays.asList(&quot;abc&quot;, &quot;&quot;, &quot;bc&quot;, &quot;efg&quot;, &quot;&quot;, &quot;jkl&quot;); List&lt;String&gt; filtered = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.toList()); System.out.println(filtered); // Stream 提供了新的方法 &apos;forEach&apos; 来迭代流中的每个数据。以下代码片段使用forEach 输出了10个随机数 // limit 方法用于获取指定数量的流。以下代码片段使用 limit 方法打印出 10 条数据 // sorted 方法用于对流进行排序。以下代码片段使用 sorted 方法对输出的 10 个随机数进行排序 Random random = new Random(); random.ints().limit(10).sorted().forEach(System.out::println); // map 方法用于映射每个元素到对应的结果，以下代码片段使用 map 输出了元素对应的平方数： List&lt;Integer&gt; numbers = Arrays.asList(3, 2, 3, 4, 3, 5); List&lt;Integer&gt; squaresList = numbers.stream().map(i -&gt;i*i).distinct().collect(Collectors.toList()); System.out.println(squaresList); // filter 方法用于通过设置条件过滤出元素。以下代码片段使用filter 方法过滤出空字符串： List&lt;String&gt; strings2 = Arrays.asList(&quot;abc&quot;, &quot;&quot;, &quot;bc&quot;, &quot;efg&quot;, &quot;abcd&quot;,&quot;&quot;, &quot;jkl&quot;); // 获取空字符串的数量 int count = (int) strings2.stream().filter(string -&gt; string.isEmpty()).count(); System.out.println(count); // Collectors 类实现了很多归约操作，例如将流转换成集合和聚合元素。Collectors可用于返回列表或字符串： List&lt;String&gt; strings3 = Arrays.asList(&quot;abc&quot;, &quot;&quot;, &quot;bc&quot;, &quot;efg&quot;, &quot;abcd&quot;, &quot;&quot;, &quot;jkl&quot;); List&lt;String&gt; filtered3 = strings3.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.toList()); System.out.println(&quot;筛选列表: &quot; + filtered3); String mergedString = strings3.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.joining(&quot;, &quot;)); System.out.println(&quot;合并字符串: &quot; + mergedString); // 一些产生统计结果的收集器也非常有用。它们主要用于int、double、long等基本类型上，它们可以用来产生类似如下的统计结果 List&lt;Integer&gt; numbers2 = Arrays.asList(3, 2, 2, 3, 7, 3, 5); IntSummaryStatistics stats = numbers2.stream().mapToInt((x) -&gt; x).summaryStatistics(); System.out.println(&quot;列表中最大的数 : &quot; + stats.getMax()); System.out.println(&quot;列表中最小的数 : &quot; + stats.getMin()); System.out.println(&quot;所有数之和 : &quot; + stats.getSum()); System.out.println(&quot;平均数 : &quot; + stats.getAverage()); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152/** * @Package: com.swz * @Description: 流Stream * @author: swz * @date: 2018/11/29 16:02 */public class Stream2Test &#123; public static void main(String args[]) &#123; System.out.println(&quot;使用 Java 7: &quot;); // 计算空字符串 List&lt;String&gt; strings = Arrays.asList(&quot;abc&quot;, &quot;&quot;, &quot;bc&quot;, &quot;efg&quot;, &quot;abcd&quot;, &quot;&quot;, &quot;jkl&quot;); System.out.println(&quot;列表: &quot; + strings); long count = getCountEmptyStringUsingJava7(strings); System.out.println(&quot;空字符数量为: &quot; + count); count = getCountLength3UsingJava7(strings); System.out.println(&quot;字符串长度为 3 的数量为: &quot; + count); // 删除空字符串 List&lt;String&gt; filtered = deleteEmptyStringsUsingJava7(strings); System.out.println(&quot;筛选后的列表: &quot; + filtered); // 删除空字符串，并使用逗号把它们合并起来 String mergedString = getMergedStringUsingJava7(strings, &quot;, &quot;); System.out.println(&quot;合并字符串: &quot; + mergedString); List&lt;Integer&gt; numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5); // 获取列表元素平方数 List&lt;Integer&gt; squaresList = getSquares(numbers); System.out.println(&quot;平方数列表: &quot; + squaresList); List&lt;Integer&gt; integers = Arrays.asList(1, 2, 13, 4, 15, 6, 17, 8, 19); System.out.println(&quot;列表: &quot; + integers); System.out.println(&quot;列表中最大的数 : &quot; + getMax(integers)); System.out.println(&quot;列表中最小的数 : &quot; + getMin(integers)); System.out.println(&quot;所有数之和 : &quot; + getSum(integers)); System.out.println(&quot;平均数 : &quot; + getAverage(integers)); System.out.println(&quot;随机数: &quot;); // 输出10个随机数 Random random = new Random(); for (int i = 0; i &lt; 10; i++) &#123; System.out.println(random.nextInt()); &#125; System.out.println(&quot;使用 Java 8: &quot;); System.out.println(&quot;列表: &quot; + strings); count = strings.stream().filter(string -&gt; string.isEmpty()).count(); System.out.println(&quot;空字符串数量为: &quot; + count); count = strings.stream().filter(string -&gt; string.length() == 3).count(); System.out.println(&quot;字符串长度为 3 的数量为: &quot; + count); filtered = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.toList()); System.out.println(&quot;筛选后的列表: &quot; + filtered); mergedString = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.joining(&quot;, &quot;)); System.out.println(&quot;合并字符串: &quot; + mergedString); squaresList = numbers.stream().map(i -&gt; i * i).distinct().collect(Collectors.toList()); System.out.println(&quot;Squares List: &quot; + squaresList); System.out.println(&quot;列表: &quot; + integers); IntSummaryStatistics stats = integers.stream().mapToInt((x) -&gt; x).summaryStatistics(); System.out.println(&quot;列表中最大的数 : &quot; + stats.getMax()); System.out.println(&quot;列表中最小的数 : &quot; + stats.getMin()); System.out.println(&quot;所有数之和 : &quot; + stats.getSum()); System.out.println(&quot;平均数 : &quot; + stats.getAverage()); System.out.println(&quot;随机数: &quot;); random.ints().limit(10).sorted().forEach(System.out::println); // 并行处理 count = strings.parallelStream().filter(string -&gt; string.isEmpty()).count(); System.out.println(&quot;空字符串的数量为: &quot; + count); &#125; private static int getCountEmptyStringUsingJava7(List&lt;String&gt; strings) &#123; int count = 0; for (String string : strings) &#123; if (string.isEmpty()) &#123; count++; &#125; &#125; return count; &#125; private static int getCountLength3UsingJava7(List&lt;String&gt; strings) &#123; int count = 0; for (String string : strings) &#123; if (string.length() == 3) &#123; count++; &#125; &#125; return count; &#125; private static List&lt;String&gt; deleteEmptyStringsUsingJava7(List&lt;String&gt; strings) &#123; List&lt;String&gt; filteredList = new ArrayList&lt;String&gt;(); for (String string : strings) &#123; if (!string.isEmpty()) &#123; filteredList.add(string); &#125; &#125; return filteredList; &#125; private static String getMergedStringUsingJava7(List&lt;String&gt; strings, String separator) &#123; StringBuilder stringBuilder = new StringBuilder(); for (String string : strings) &#123; if (!string.isEmpty()) &#123; stringBuilder.append(string); stringBuilder.append(separator); &#125; &#125; String mergedString = stringBuilder.toString(); return mergedString.substring(0, mergedString.length() - 2); &#125; private static List&lt;Integer&gt; getSquares(List&lt;Integer&gt; numbers) &#123; List&lt;Integer&gt; squaresList = new ArrayList&lt;Integer&gt;(); for (Integer number : numbers) &#123; Integer square = new Integer(number.intValue() * number.intValue()); if (!squaresList.contains(square)) &#123; squaresList.add(square); &#125; &#125; return squaresList; &#125; private static int getMax(List&lt;Integer&gt; numbers) &#123; int max = numbers.get(0); for (int i = 1; i &lt; numbers.size(); i++) &#123; Integer number = numbers.get(i); if (number.intValue() &gt; max) &#123; max = number.intValue(); &#125; &#125; return max; &#125; private static int getMin(List&lt;Integer&gt; numbers) &#123; int min = numbers.get(0); for (int i = 1; i &lt; numbers.size(); i++) &#123; Integer number = numbers.get(i); if (number.intValue() &lt; min) &#123; min = number.intValue(); &#125; &#125; return min; &#125; private static int getSum(List numbers) &#123; int sum = (int) (numbers.get(0)); for (int i = 1; i &lt; numbers.size(); i++) &#123; sum += (int) numbers.get(i); &#125; return sum; &#125; private static int getAverage(List&lt;Integer&gt; numbers) &#123; return getSum(numbers) / numbers.size(); &#125;&#125; Java 8 Optional 类Optional类是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象；Optional十个容器：它可以保存类型为T的值，或仅仅保存null；Optional类的引入很好的解决空指针异常。 类声明以下是一个 java.util.Optional 类的声明：publicfinalclassOptional&lt;T&gt; extendsObject Optional实例以下是Optional的使用实例：12345678910111213141516171819202122232425262728293031/** * @Package: com.swz * @Description: Optional类 * @author: swz * @date: 2018/11/30 11:25 */public class OptionalTest &#123; public static void main(String[] args) &#123; OptionalTest optionalTest = new OptionalTest(); Integer value1 = null; Integer value2 = new Integer(10); // 允许传递为 null 参数 Optional&lt;Integer&gt; a = Optional.ofNullable(value1); // 如果传递的参数是 null，抛出异常 NullPointerException Optional&lt;Integer&gt; b = Optional.of(value2); System.out.println(optionalTest.sum(a, b)); &#125; public Integer sum(Optional&lt;Integer&gt; a, Optional&lt;Integer&gt; b) &#123; // 判断值是否存在 System.out.println(&quot;第一个参数值存在： &quot; + a.isPresent()); System.out.println(&quot;第二个参数值存在： &quot; + b.isPresent()); // 如果值存在，返回它，否则返回默认值 Integer value1 = a.orElse(new Integer(0)); Integer value2 = b.get(); return value1 + value2; &#125;&#125; Java8 Nashorn JavaScript Nashorn 一个 javascript 引擎。从JDK1.8开始，Nashorn取代Rhino(JDK 1.6, JDK1.7)成为Java的嵌入式JavaScript引擎。Nashorn完全支持ECMAScript 5.1规范以及一些扩展。它使用基于JSR292的新语言特性，其中包含在JDK 7中引入的 invokedynamic，将JavaScript编译成Java字节码。与先前的Rhino实现相比，这带来了2到10倍的性能提升。 jjs是个基于Nashorn引擎的命令行工具。它接受一些JavaScript源代码为参数，并且执行这些源代码 使用ScriptEngineManager, JavaScript 代码可以在 Java 中执行 Nashorn实例以下是Nashorn的使用实例：123456789101112131415161718192021222324/** * @Package: com.swz * @Description: Nashorn, javascript 引擎。 * @author: swz * @date: 2018/11/30 14:11 */public class NashornTest &#123; public static void main(String[] args) &#123; ScriptEngineManager scriptEngineManager = new ScriptEngineManager(); ScriptEngine nashorn = scriptEngineManager.getEngineByName(&quot;nashorn&quot;); String name = &quot;Runoob&quot;; Integer result = null; try &#123; nashorn.eval(&quot;print(&apos;&quot; + name + &quot;&apos;)&quot;); result = (Integer) nashorn.eval(&quot;10 + 2&quot;); &#125; catch (ScriptException e) &#123; System.out.println(&quot;执行脚本错误: &quot; + e.getMessage()); &#125; System.out.println(result.toString()); &#125;&#125; Java8 日期时间API在旧版的Java 中，日期时间API 存在诸多问题: 非线程安全 − java.util.Date 是非线程安全的，所有的日期类都是可变的，这是Java日期类最大的问题之一; 设计很差 − Java的日期/时间类的定义并不一致，在java.util和java.sql的包中都有日期类; 时区处理麻烦 − 日期类并不提供国际化，没有时区支持; Java 8 在 java.time 包下提供了很多新的 API: Local(本地) − 简化了日期时间的处理，没有时区的问题; Zoned(时区) − 通过制定的时区处理日期时间; 新的java.time包涵盖了所有处理日期，时间，日期/时间，时区，时刻（instants），过程（during）与时钟（clock）的操作. 日期时间实例以下是日期时间的使用实例：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * @Package: com.swz * @Description: 日期时间API * @author: swz * @date: 2018/11/30 14:23 */public class DateTimeTest &#123; public static void main(String[] args) &#123; // LocalDate/LocalTime 和 LocalDateTime 类可以在处理时区不是必须的情况 DateTimeTest dateTimeTest = new DateTimeTest(); dateTimeTest.testLocalDateTime(); // 如果我们需要考虑到时区，就可以使用时区的日期时间API dateTimeTest.testZonedDateTime(); &#125; public void testLocalDateTime() &#123; // 获取当前的日期时间 LocalDateTime localDateTime = LocalDateTime.now(); System.out.println(&quot;当前时间：&quot; + localDateTime); LocalDate localDate = localDateTime.toLocalDate(); System.out.println(&quot;localDate:&quot; + localDate); Month month = localDateTime.getMonth(); int day = localDateTime.getDayOfMonth(); int hours = localDateTime.getHour(); int minutes = localDateTime.getMinute(); int seconds = localDateTime.getSecond(); System.out.println(&quot;月：&quot; + month + &quot;,日: &quot; + day + &quot;,时：&quot; + hours + &quot;,分：&quot; + minutes + &quot;,秒: &quot; + seconds); LocalDateTime localDateTime1 = localDateTime.withDayOfMonth(10).withYear(2018); System.out.println(&quot;localDateTime1:&quot; + localDateTime1); // 2018-11-28 LocalDate localDate1 = LocalDate.of(2018, Month.NOVEMBER, 28); System.out.println(&quot;localDate1:&quot; + localDate1); // 22:35 LocalTime localTime = LocalTime.of(22, 30); System.out.println(&quot;localTime:&quot; + localTime); // 解析字符串 LocalTime localTime1 = LocalTime.parse(&quot;22:35:24&quot;); System.out.println(&quot;localTime1&quot; + localTime1); &#125; public void testZonedDateTime() &#123; // 获取当前时间日期 ZonedDateTime date1 = ZonedDateTime.parse(&quot;2015-12-03T10:15:30+05:30[Asia/Shanghai]&quot;); System.out.println(&quot;date1: &quot; + date1); ZoneId id = ZoneId.of(&quot;Europe/Paris&quot;); System.out.println(&quot;ZoneId: &quot; + id); ZoneId currentZone = ZoneId.systemDefault(); System.out.println(&quot;当期时区: &quot; + currentZone); &#125;&#125; Java8 Base64Base64编码已经成为Java类库的标准；Java8 内置了 Base64 编码的编码器和解码器Base64工具类提供了一套静态方法获取下面三种BASE64编解码器： 基本：输出被映射到一组字符A-Za-z0-9+/，编码不添加任何行标，输出的解码仅支持A-Za-z0-9+/; URL：输出映射到一组字符A-Za-z0-9+_，输出是URL和文件; MIME：输出隐射到MIME友好格式。输出每行不超过76字符，并且使用’\r’并跟随’\n’作为分割。编码输出最后没有行分割 Base64实例以下是Base64的使用实例：12345678910111213141516171819202122232425262728293031323334/** * @Package: com.swz * @Description: Base64编码 * @author: swz * @date: 2018/11/30 14:56 */public class Base64Test &#123; public static void main(String[] args) &#123; try &#123; // 使用基本编码 String base64encodedString = Base64.getEncoder().encodeToString(&quot;runoob?java8&quot;.getBytes(&quot;utf-8&quot;)); System.out.println(&quot;Base64编码字符串(基本)：&quot; + base64encodedString); // 解码 byte[] base64decodedBytes = Base64.getDecoder().decode(base64encodedString); System.out.println(&quot;原始字符串: &quot; + new String(base64decodedBytes, &quot;utf-8&quot;)); // 使用URL编码 base64encodedString = Base64.getUrlEncoder().encodeToString(&quot;TutorialsPoint?java8&quot;.getBytes(&quot;utf-8&quot;)); System.out.println(&quot;Base64 编码字符串 (URL) :&quot; + base64encodedString); // 使用MIME编码 StringBuilder stringBuilder = new StringBuilder(); for (int i = 0; i &lt; 10; ++i) &#123; stringBuilder.append(UUID.randomUUID().toString()); &#125; byte[] mimeBytes = stringBuilder.toString().getBytes(&quot;utf-8&quot;); String mimeEncodedString = Base64.getMimeEncoder().encodeToString(mimeBytes); System.out.println(&quot;Base64 编码字符串 (MIME) :&quot; + mimeEncodedString); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 重复注解-RepeatingAnnotationTest以下是重复注解的使用实例：123456789101112131415161718192021222324252627282930313233/** * @Package: com.swz * @Description: 重复注解，拓宽注解的应用场景 * @author: swz * @date: 2018/11/30 15:18 */public class RepeatingAnnotationTest &#123; public static void main(String[] args) &#123; for( Filter filter: Filterable.class.getAnnotationsByType( Filter.class ) ) &#123; System.out.println( filter.value() ); &#125; &#125; @Target( ElementType.TYPE ) @Retention( RetentionPolicy.RUNTIME ) public @interface Filters &#123; Filter[] value(); &#125; @Target( ElementType.TYPE ) @Retention( RetentionPolicy.RUNTIME ) @Repeatable( Filters.class ) public @interface Filter &#123; String value(); &#125; @Filter( &quot;filter1&quot; ) @Filter( &quot;filter2&quot; ) public interface Filterable &#123; &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql常用函数]]></title>
    <url>%2F2019%2F01%2F04%2Fblog20181207%2F</url>
    <content type="text"><![CDATA[文章描述 MySQL数据库中提供了很丰富的函数。MySQL函数包括数学函数、字符串函数、日期和时间函数、条件判断函数、系统信息函数、加密函数、格式化函数等。通过这些函数，可以简化用户的操作。以下是对mysql中的常用函数进行了汇总介绍，需要的朋友可以过来参考下。 数字函数 函数 描述 ABS(x) 返回x的绝对值 BIN(x) 返回x的二进制（OCT-八进制，HEX-十六进制） CEILING(x) 返回大于x的最小整数值 EXP(x) 返回值e（自然对数的底）的x次方 FLOOR(x) 返回小于x的最大整数值 GREATEST(x1…,xn) 返回集合中最大的值 LEAST(x1…,xn) 返回集合中最小的值 LN(x) 返回x的自然对数 LOG(x,y) 返回x的以y为底的对数 MOD(x,y) 返回x的以y为底的对数 RAND() 随机数生成器生成一个指定的值 ROUND(x,y) 返回参数x的四舍五入的有y位小数的值 SIGN(x) 返回代表数字x的符号的值 SQRT(x) 返回一个数的平方根 TRUNCATE(x,y) 返回数字x截短为y位小数的结果 聚合函数 函数 描述 AVG(col) 返回指定列的平均值 COUNT(col) 返回指定列中非NULL值的个数 MIN(col) 返回指定列的最小值 MAX(col) 返回指定列的最大值 SUM(col) 返回指定列的所有值之和 GROUP_CONCAT(col) 返回由属于一组的列值连接组合而成的结果 字符串函数 函数 描述 ASCII(char) 返回字符的ASCII码值 BIT_LENGTH(str) 返回字符串的比特长度 CONCAT(s1,s2…,sn) 将s1,s2…,sn连接成字符串 CONCAT_WS(sep,s1,s2…,sn) 将s1,s2…,sn连接成字符串，并用sep字符间隔 LEFT(str,x) 返回字符串str中最左边的x个字符 LTRIM(str) 从字符串str中切掉开头的空格 POSITION(substr,str) substr在字符串str中第一次出现的位置 QUOTE(str) 用反斜杠转义str中的单引号 REPEAT(str,srchstr,rplcstr) 返回字符串str重复x次的结果 REVERSE(str) 返回颠倒字符串str的结果 RIGHT(str,x) 返回字符串str中最右边的x个字符 RTRIM(str) 返回字符串str尾部的空格 STRCMP(s1,s2) 比较字符串s1和s2 TRIM(str) 去除字符串首部和尾部的所有空格 UCASE(str)/UPPER(str) 返回字符串str中所有字符改变为大写后的结果 LCASE(str)/LOWER(str) 返回字符串str中所有字符改变为小写后的结果 日期和时间函数 函数 描述 CURDATE()/CURRENT_DATE() 返回当前的日期 CURTIME()/CURRENT_TIME() 返回当前的时间 DATE_FORMAT(date,fmt) 依照指定的fmt格式格式化日期date值 STR_TO_DATE(str,fmt) 字符串转日期,fmt格式必须和str的格式相同 DAYOFWEEK(date) 返回date所代表的一星期中的第几天(1~7) DAYOFMONTH(date) 返回date是一个月的第几天(1~31) DAYOFYEAR(date) 返回date是一年的第几天(1~366) FROM_UNIXTIME(ts,fmt) 根据指定的fmt格式，格式化UNIX时间戳ts UNIX_TIMESTAMP(date) 把字符串日期转成时间戳 NOW() 返回当前的日期和时间 WEEK(date) 返回日期date为一年中第几周(0~53) YEAR(date) 返回日期date的年份(1000~9999) 1234SELECT FROM_UNIXTIME(UNIX_TIMESTAMP());SELECT EXTRACT(YEAR_MONTH FROM CURRENT_DATE);SELECT EXTRACT(DAY_SECOND FROM CURRENT_DATE);SELECT EXTRACT(HOUR_MINUTE FROM CURRENT_DATE); 系统信息函数 函数 描述 DATABASE() 返回当前数据库名 BENCHMARK(count,expr) 返回当前的时间 CONNECTION_ID() 返回当前客户的连接ID FOUND_ROWS() 返回最后一个SELECT查询进行检索的总行数 USER()/SYSTEM_USER() 返回当前登陆用户名 VERSION() 返回MySQL服务器的版本 123456789SELECT id , `customer_name` , sex , LEFT(telephone,3) ,USER(),RAND(),WEEK(now()) ,SQRT(4) ,CONCAT(telephone,&apos;-&apos;,id),LOWER(&apos;abc&apos;), CURRENT_TIME(),UNIX_TIMESTAMP(now()),CASEWHEN sex = 1 THEN &apos;男&apos;WHEN sex = 2 THEN &apos;女&apos;else &apos;保密&apos;END AS sexFROM customer_demandORDER BY id DESCLIMIT 10 总结有些函数真的非常有用，真的希望我的总结对你有帮助。谢谢各位的阅读，也希望你能和我分享你的学习心得。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle常用函数]]></title>
    <url>%2F2019%2F01%2F04%2Fblog20181206%2F</url>
    <content type="text"><![CDATA[前言在平时写PL/SQL的时候，经常要用到很多系统自带的函数，而这些函数用起来非常好用，但是每次用完以后，就又忘到脑后了，为了加深自己的印象，以及对这些函数做一个全面的总结，下面就对Oracle常见函数做个整理，方便以后查询。 常用字符函数在编写PL/SQL程序时，或多或少的需要进行字符串操作，进行字符串操作又离不开以下的这些函数。 函数 描述 LOWER(char) 将字符串表达式char中的所有大写字母转换为小写字母 UPPER(char) 将字符串表达式char中的所有小写字母转换为大写字母 INITCAP(char) 首字母转换成大写 SUBSTR(char, start, length) 返回字符串表达式char中从第start开始的length个字符 LENGTH(char) 返回字符串表达式char的长度 ASCII(char) 取char的ASCII值 CHR(number) 取number的ASCII值 REPLACE(char,search_str[,replacement_str]) 将字符串char中的子串search_str替换成replacement_str；如果search_str=null，返回char；如果replacement_str=null，则会去掉char中的search_str INSTR(char1,char2[,n[,m]]) 获取子串char2在字符串char1中的位置。n为其实搜索位置，m为子串出现的次数；n为负，则从尾部开始搜索；n\m默认为1 LPAD(char1,n,char2) 在字符串char1的左端填充字符串char2直到长度达到n;char2默认为空格，如果char1.length&gt;n，则返回char1左端的n个字符 RPAD(char1,n,char2) 在字符串char1的右端填充字符串char2直到长度达到n;char2默认为空格，如果char1.length&gt;n，则返回char1左端的n个字符 LTRIM(char1[,set]) 去掉字符串char1左端包含的set中的任意字符 RTRIM(char1[,set]) 去掉字符串char1右端包含的set中的任意字符 TRIM(char &#124; char From string) 从字符串的头尾或者两端截断特定字符 CONCAT(str1,str2) 连接字符串，同 &#124;&#124; 的作用一样 123456789101112131415161718192021222324252627282930313233343536373839404142-- LOWER测试select LOWER(&apos;HTTP://WWW.JELLYTHINK.COM&apos;) from dual; -- http://www.jellythink.com-- UPPER测试select UPPER(&apos;http://www.jellythink.com&apos;) from dual; -- HTTP://WWW.JELLYTHINK.COM-- INITCAP测试select INITCAP(&apos;jelly think&apos;) from dual; -- Jelly Think-- SUBSTR测试select SUBSTR(&apos;http://www.jellythink.com&apos;, 12, 10) from dual; -- jellythink(注：下标从1开始)-- LENGTH测试select LENGTH(&apos;JellyThink&apos;) from dual; -- 10-- ASCII测试select ASCII(&apos;A&apos;) from dual; -- 65-- CHR测试select CHR(65) from dual; -- A-- REPLACE测试select REPLACE(&apos;jellythink&apos;, &apos;think&apos;, &apos; is good&apos;) from dual; -- jelly is good-- INSTR测试select INSTR(&apos;JellyThink&apos;, &apos;Jelly&apos;, 1) from dual; -- 1-- LPAD测试select LPAD(&apos;JellyThink&apos;, 12, &apos;*&apos;) from dual; -- **JellyThink-- RPAD测试select RPAD(&apos;JellyThink&apos;, 12, &apos;*&apos;) from dual; -- JellyThink**-- LTRIM测试select LTRIM(&apos;**JellyThink&apos;, &apos;*&apos;) from dual; -- JellyThink-- RTRIM测试select RTRIM(&apos;JellyThink**&apos;, &apos;*&apos;) from dual; -- JellyThink-- TRIM测试select TRIM(&apos;*&apos; from &apos;**JellyThink**&apos;) from dual; -- JellyThinkselect TRIM(&apos; JellyThink &apos;) from dual; -- JellyThink(注：默认去掉空格) 常用日期函数每天都在和各种日期打交道，一个会得到这个月的最后一天，一会又要得到当前日期，看看以下的函数吧，是否似曾相识。 函数 描述 SYSDATE 返回系统当前日期和时间 NEXT_DAY(day,char) 返回指定日期day后的第一个工作日char所对应的日期 LAST_DAY(day) 返回day日期所指定月份中最后一天所对应的日期 ADD_MONTHS(day,n) 返回day日期在n个月后(n为正数)或前(n为负数)的日期 MONTHS_BETWEEN(day1,day2) 返回day1日期和day2日期之间相差得月份 ROUND(day[,fmt]) 返回日期的四舍五入结果。如果fmt指定年度，则7月1日为分界线；如果fmt指定月，则16日为分界线；如果指定天，则中午12:00为分界线，默认舍入到日 TRUNC(day,[,fmt]) 日期截断函数。如果fmt指定年度，则结果为本年度的1月1日；如果为月，则将结果为本月1日，默认截断到日 CURRENT_DATE 返回当前会话时区所对应日期时间 EXTRACT 从日期中获取所需要的特定数据 12345678910111213141516171819202122232425262728-- SYSDATE测试select TO_CHAR(SYSDATE,&apos;yyyy-MM-dd hh24:mi:ss&apos;) from dual; -- 2015-09-29 15:14:44-- NEXT_DAY测试select NEXT_DAY(SYSDATE, &apos;星期一&apos;) from dual; -- 2015/10/5 15:16:46-- LAST_DAY测试select LAST_DAY(SYSDATE) from dual; -- 2015/9/30 15:17:23-- ADD_MONTHS测试select ADD_MONTHS(SYSDATE, 2) from dual; -- 2015/11/29 15:18:39-- MONTHS_BETWEEN测试select MONTHS_BETWEEN(SYSDATE, SYSDATE) from dual; -- 0select MONTHS_BETWEEN(ADD_MONTHS(SYSDATE, -2), ADD_MONTHS(SYSDATE, 2)) from dual; -- -4-- ROUND测试select ROUND(SYSDATE) from dual; -- 2015/9/30select ROUND(SYSDATE, &apos;YEAR&apos;) from dual; -- 2016/1/1select ROUND(SYSDATE, &apos;MONTH&apos;) from dual; -- 2015/10/1-- TRUNC测试select TRUNC(SYSDATE) from dual; -- 2015/9/29select TRUNC(SYSDATE, &apos;YEAR&apos;) from dual; -- 2015/1/1select TRUNC(SYSDATE, &apos;MONTH&apos;) from dual; -- 2015/9/1-- CURRENT_DATE测试select CURRENT_DATE from dual; -- 2015/9/29 15:22:44 常用类型转换函数类型转换函数是太常见了，什么to_char啊，to_date啊，但是你有没有好好的使用过呢？ 函数 描述 TO_CHAR 将一个数字或日期转换成字符串 TO_NUMBER 将字符型数据转换成数字型数据 TO_DATE 将字符型数据转换为日期型数据 CAST 将一种built-in类型转换成另一种built-in类型 1234567891011121314-- TO_CHAR测试select TO_CHAR(100) from dual; -- 100select TO_CHAR(SYSDATE, &apos;YYYY-MM-DD HH24:MI:SS&apos;) from dual; -- 2015-09-29 15:36:24-- TO_NUMBER测试select TO_NUMBER(&apos;10&apos;) from dual; -- 10select TO_NUMBER(&apos;JellyThink&apos;) from dual; -- 无效数字-- TO_DATE测试select TO_DATE(&apos;2015-9-29&apos;, &apos;YYYY-MM-DD&apos;) from dual; -- 2015/9/29-- CAST测试select CAST(&apos;100&apos; as NUMBER) from dual; -- 100select CAST(2 as char) from dual; -- 2 集合函数有了GROUP BY，怎么可以少了这些用来统计的集合函数呢。 函数 描述 AVG 计算一列值的平均值 COUNT 统计一列中值的个数 MAX 求一列值中的最大值 MIN 求一列值中的最小值 SUM 计算一列值的总和 其它常用函数还有一些经常使用的函数不属于上述的任何一种分类，只能作为其它常用函数来分类了，具体你看喽。 函数 描述 decode(expression , search , result [, search , result]… [, default]) IF语句的另一形式。将输入数值与参数列表比较，返回对应值。应用于将表的行转换成列以及IF语句无法应用的场合 SIGN(number) 如果number大于0，SIGN则返回1；如果number小于0，SIGN则返回-1；如果number等于0，SIGN则返回0 TRUNC(number, [ decimal_places ]) number是要截取的数字，decimal_places是要保留的小数位。这个参数必须是个整数。 如果此参数缺省，默认保留0位小数 GREATEST(expr1[,expr2]…) 返回表达式中值最大的一个 LEAST(expr1[,expr2]…) 返回表达式中值最小的一个 NULLIF(expr1,expr2) 如果expr1=expr2；则返回null，否则返回expr1 NVL(expr1,expr2) 如果expr1=null；则返回expr2，否则返回expr1 NVL2(expr1,expr2,expr3) 如果expr1!=null；则返回expr2；如果expr1=null；则返回expr3 1234567891011121314151617181920212223242526272829-- DECODE测试select DECODE(20, 10, 5, 200, 10, 20, 30) from dual; -- 30-- SIGN测试select SIGN(20) from dual; -- 1select SIGN(-30) from dual; -- -1select SIGN(0) from dual; -- 0-- TRUNC测试select TRUNC(20.2183, 2) from dual; -- 20.21select TRUNC(20.1, 4) from dual; -- 20.1-- GREATEST测试select GREATEST(20, 100, 30, 20, 40, 400) from dual; -- 400-- LEAST测试select LEAST(20, 100, 30, 20, 40, 400) from dual; -- 20-- NULLIF测试select NULLIF(20, 20) from dual; -- NULLselect NULLIF(20, 10) from dual; -- 20-- NVL测试select NVL(20, 30) from dual; -- 20select NVL(NULL, 30) from dual; -- 30-- NVL2测试select NVL2(NULL, 20, 30) from dual; -- 30select NVL2(&apos;JellyThink&apos;, 20, 30) from dual; -- 20 总结哦，总结完了，感觉还算有点效果，至少又把这些函数重新复习了一遍，不是吗？有些函数真的非常有用，真的希望我的总结对你有帮助。谢谢各位的阅读，也希望你能和我分享你的学习心得。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
</search>
