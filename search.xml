<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Docker介绍]]></title>
    <url>%2F2019%2F02%2F20%2Fblog20190220%2F</url>
    <content type="text"><![CDATA[前言 docker 功能非常强大，可以保证线上线下环境一致性，可以快速部署启动项目，有极高的平台迁移性，其联合文件系统可以使得镜像非常方便的迭代升级。诸多优点，感兴趣的朋友可以自己搜索下相关的教程先熟悉下docker相关概念。 Docker是什么Docker的思想来自于集装箱，集装箱解决了什么问题？在一艘大船上，可以把货物规整的摆放起来。并且各种各样的货物被集装箱标准化，集装箱和集装箱之间不会互相影响。那么我就不需要专门运送水果的船和专门运送化学品的船了。只要这些货物在集装箱里封装的好好的，那我就可以用一艘大船把他们都运走。 docker就是类似的理念。现在都流行云计算了，云计算就好比大货轮。docker就是集装箱。 不同的应用程序可能会有不同的应用环境，比如.net开发的网站和php开发的网站依赖的软件就不一样，如果把他们依赖的软件都安装在一个服务器上就要调试很久，而且很麻烦，还会造成一些冲突。比如IIS和Apache访问端口冲突。这个时候你就要隔离.net开发的网站和php开发的网站。常规来讲，我们可以在服务器上创建不同的虚拟机在不同的虚拟机上放置不同的应用，但是虚拟机开销比较高。docker可以实现虚拟机隔离应用环境的功能，并且开销比虚拟机小，小就意味着省钱了。 你开发软件的时候用的是Ubuntu，但是运维管理的都是centos，运维在把你的软件从开发环境转移到生产环境的时候就会遇到一些Ubuntu转centos的问题，比如：有个特殊版本的数据库，只有Ubuntu支持，centos不支持，在转移的过程当中运维就得想办法解决这样的问题。这时候要是有docker你就可以把开发环境直接封装转移给运维，运维直接部署你给他的docker就可以了。而且部署速度快。 在服务器负载方面，如果你单独开一个虚拟机，那么虚拟机会占用空闲内存的，docker部署的话，这些内存就会利用起来。 总之docker就是集装箱原理。 可以用Docker做什么【编者的话】有些开发者可能还是不明白 Docker 对自己到底有多大的用处，因此翻译 Docker个人用例 这篇文章中来介绍 Docker 在普通开发者开发过程中的用例。 Docker 如今赢得了许多关注，很多人觉得盛名之下其实难副，因为他们仍然搞不清 Docker 和普通开发者到底有什么关系。许多开发者觉得 Docker 离自己很远，Docker 是生产环境中的工具，和自己无关。我也是花了很长时间才想清楚作为普通开发人员如何在自己的开发中使用 Docker。坦率地说，我仍处在学习的过程中。 这篇文章提供了一个 Docker 用例列表，我希望它能更好地帮助你理解 Docker 并引发你的思考。本文只是描述 Docker 在普通开发者日常的应用，并不提供完整的解决方案。 在介绍用例之前，我希望你能先记住这句话：“Docker 是一个便携的应用容器”。你可以不知道 Docker 所说的的“便携式容器”到底是什么意思，但是你必须清楚 Docker 在日常中能带来非常大的效率提升。 当你需要在容器内运行自己的应用（当然可以是任何应用），Docker 都提供了一个基础系统镜像作为运行应用时的基础系统。也就是说，只要是 Linux 系统上的应用都可以运行在 Docker 中。 可以在 Docker 里面运行数据库吗？当然可以。可以在 Docker 里面运行 Node.js 网站服务器吗？当然可以。可以在 Docker 里面运行 API 服务器吗？当然可以。 Docker 并不在乎你的应用程序是什么、做什么，Docker 提供了一组应用打包、传输和部署的方法，以便你能更好地在容器内运行任何应用。 下面的例子我自己经常使用，当然你有更好的案例也可以分享给我。 尝试新软件对开发者而言，每天会催生出的各式各样的新技术都需要尝试，然而开发者却不太可能为他们一一搭建好环境并进行测试。时间非常宝贵，正是得益于 Docker，让我们有可能在一条或者几条命令内就搭建完环境。Docker 有一个傻瓜化的获取软件的方法，Docker 后台会自动获得环境镜像并且运行环境。 并不仅仅是新技术环境搭建用得到 Docker。如果你想快速在你的笔记本上运行一个 MySQL 数据库，或者一个 Redis 消息队列，那么使用 Docker 便可以非常容易地做到。例如 Docker 只需要一条命令便可以运行 MySQL 数据库：docker run -d -p 3306:3306 tutum/mysql. 译者注：虽然使用命令也能非常快地安装 MySQL 数据库，但是当用到最新的技术或者非常复杂的技术时，使用 Docker 便会是个非常好的选择，例如 Gitlab，普通用户大概需要一天的时间去搭建 Gitlab 平台，而 Docker 则只需要一条命令 进行演示现在我经常需要在周末用自己开发的成果对客户活着别人做一两个演示。搭建演示环境的过程非常麻烦。现在我发现 Docker 已经成为我演示这些工具的最合理的方式。同时，对于客户来说，我可以直接将 Docker 镜像提供给他们，而不必去做任何环境配置的工作，工作的效果也会和在他们演示中所看到的一模一样，同时不必担心他们的环境配置会导致我们的产品无法运行。 避免“我机器上可以运行”无论是上一篇介绍的企业部署 Docker 还是本文的个人 Docker 用例，都提到了这个情况。因为环境配置不同，很多人在开发中也会遇到这个情况，甚至开发的软件到了测试人员的机器上便不能运行。但这都不是重点。重点是，如果我们有一个可靠的、可分发的标准开发环境，那么我们的开发将不会像现在这么痛苦。Docker 便可以解决这个问题。Docker 镜像并不会因为环境的变化而不能运行，也不会在不同的电脑上有不同的运行结果。可以给测试人员提交含有应用的 Docker 镜像，这样便不再会发生“在我机器上是可以运行的”这种事情，很大程度上减轻了开发人员测试人员互相检查机器环境设置带来的时间成本。 另一个 Docker 可以发挥用处的地方是培训班。除了 Docker 容器的隔离性之外，更能体会到 Docker 优势的地方在于环境搭建。培训班的新手每个人都要在环境搭建上花费很多时间，但是如果在这里应用到 Docker 的话，那么我们只需要把标准的运行环境镜像分发下去，然后就可以开始上课了。使用 Docker 和使用虚拟机一样简单，但是 Docker 要更方便、更轻量级。同时，我们也可以告诉学员：“在培训的同时，我们还将学到当下最流行的技术——Docker”，这种双赢的结局，何乐而不为呢。 学习 Linux 脚本当然这个原因看起来可能很奇怪，但是对不不熟悉 Linux 操作系统和 Shell 脚本的人来说，确实是一个好机会。即便本文并不是在讲 Linux，Linux 的重要度仍然不言而喻。如果你用的是 Windows，那么我给你一个建议：从云主机提供商那儿租用一台云主机：我推荐使用 CoreOS 系统的云主机。虽然这样并不会让你成为专业的 Linux 运维，但是可以让你快速地学到 Linux 基础知识，爱上命令行操作，并且慢慢开始熟悉和欣赏 Linux。 更好地利用资源虚拟机的粒度是“虚拟出的机器”，而 Docker 的粒度则是“被限制的应用”，相比较而言 Docker 的内存占用更少，更加轻量级。 对我来说这是 Docker 的一个优势：因为我经常在自己电脑中运行多个 Docker 应用，使用 Docker 比使用虚拟机更加简单，方便，粒度更细，也能持续地跟踪容器状态。 为微服务定制如果你一直在关注科技新闻的话，那么你应该听说过“微服务（Microservices）”的概念。Docker 可以很好地和微服务结合起来。从概念上来说，一个微服务便是一个提供一整套应用程序的部分功能，Docker 便可以在开发、测试和部署过程中一直充当微服务的容器。甚至生产环境也可以在 Docker 中部署微服务。 在云服务提供商之间移植大多数的云主机提供商已经全面支持 Docker。对于开发人员来说，这表示你可以很方便地切换云服务提供商，当然也可以很方便地将你本地的开发环境移动到云主机上，不需要本地上配置一次运行环境、在云主机上还配置一次运行环境。全面部署 Docker (Docker here and Docker there) 作为标准运行环境可以极大地减轻应用上线时的工作量和产生 BUG API 端API 是应用之间的粘合剂，一个合格开发者肯定使用过别人提供的 REST API，或者自己开发过 REST API。需要指出的是，无论是客户端还是 API 提供端，在开发之前都需要先定义一组公共的 API 接口，写成文档，然后才能进行编码。如果服务端和客户端是共同开发的话，那么服务端通常会先实现能返回固定字符串的 API 接口，在以后的开发中再慢慢去实现 API 的功能。 虽然有人会认为在这里 Docker 被滥用了，完全可以用 sample.json 这种文件去实现虚拟 API，但是下面有个实例可以更好地解决前后端分离开发时的 API 问题。 为了更好地解释我的意思，给大家提供一个实例：JSON Server，一个用于提供 JSON 数据的 REST API。使用过这个容器的人就会知道，既然有这么好用的 Docker JSON Server，我们没有理由不用 Docker。 译者注： 运行示例的 JSON Server，同时使用示例中提供的 JSON 文件，只需执行一条命令便可以创建一个服务端的 API 应用。 使用 curl http://127.0.0.1:80/posts 即可获取示例文件中的 posts 段，这样在后端没有开发完 API 的时候，前端一样可以进行协同开发。 技术的创新这点应该算不上是用例，但是我还是来写一下。Docker 正在快速发展，工具也在不断更新，没有人能预见到未来 Docker 会是什么样子的。你在复杂的系统中 Docker 使用的越多，越是可能会发现技术上的空白和未来技术发展的方向。现在还处在 Docker 的发展期，任何你使用 Docker 创建的工具都有可能成为社区关注的热点。这是 Docker 的机会，也是成就你自己的机会。 其他还有两个技巧可以分享给你们。在学习 Docker 的过程中因为有了这两个的帮助，我才得意不断地提升自己。 一：Docker Hub。这是 Docker 的官方镜像仓库，除了托管着 Docker 官方的镜像外，和 Github 一样，你可以在上面上传自己的镜像，也可以在上面搜寻其他有用的镜像，极大地节省自己的时间。例如 Oracle-XE-11g 镜像，所有的一切都是现成的，完全不需要自己去下载 Oracle XE 11g 安装。这样为你和团队节约了大量的时间成本。 如果你不太确定的话，可以去 Docker Hub 上搜有一下有没有自己用得到的镜像。大部分情况下你所需要的镜像在 Docker Hub 上都已经有人构建了。 二：多参考 IaaS 供应商的新闻，虽然我们不能像在他们会议室里那样完全了解他们的公司动态，但是仍然可以从新闻中可以了解到 Docker 最新的发展方向和技术趋势。可以肯定的是，容器化技术是未来的热点，我们不仅可以在本机运行 Docker，不仅仅在一家云服务提供商的主机上运行 Docker，未来所有的云服务提供商都会支持 Docker。 Docker 前景很明确，采用 Docker 只会让开发变得更方便。 原文链接：Docker是什么？可以用Docker做什么？！]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL(解压版)安装教程]]></title>
    <url>%2F2019%2F01%2F21%2Fblog20190121%2F</url>
    <content type="text"><![CDATA[前言MySQL是一种开放源代码的关系型数据库管理系统（RDBMS），MySQL数据库系统使用最常用的数据库管理语言–结构化查询语言（SQL）进行数据库管理。由于MySQL是开放源代码的，因此任何人都可以在General Public License的许可下下载并根据个性化的需要对其进行修改。MySQL因为其速度、可靠性和适应性而备受关注。大多数人都认为在不需要事务化处理的情况下，MySQL是管理内容最好的选择。 MySQL安装MySQL分为安装版和解压版，个人推荐解压版MySQL，详细步骤如下： 下载访问地址MySQL官网下载地址，目前最新版是8.0.13。如果你不想下载最新版，想下载以前的版本，可以点击如下图的链接进行下载： 根据你的系统（32位或者64位）选择后缀是ZIP Archive的压缩包下载到本地，这里我选择的是5.7.21版本，如图： 点击Download进入下载页，这里要求你注册登陆, 不用管直接点击No thanks, just start my download， 按钮进行下载，如下图所示： 解压选择一个路径（建议将常用的工具分类放在同一文件夹如D:\MySQL）解压压缩包。 配置my.ini需要新建一个my.ini文件，在my.ini文件中添加如下信息： 12345678910111213141516[mysql]#设置mysql客户端默认字符集default-character-set=utf8[mysqld]#设置3306端口port=3306# 设置mysql的安装目录basedir=D:\MySQL\mysql-5.7.21-winx64# 设置mysql数据库的数据的存放目录datadir=D:\MySQL\mysql-5.7.21-winx64\data# 允许最大连接数max_connections=200# 服务端使用的字符集默认为8比特编码的latin1字符集character-set-server=utf8# 创建新表时将使用的默认存储引擎default-storage-engine=INNODB 配置环境变量 右键计算机–属性–高级系统设置–环境变量，新建系统变量MySQL_HOME，添加MySQL解压的目录（我这里是D:\MySQL\mysql-5.7.21-winx64）； 在系统变量中找到Path编辑，在结尾处追加%MySQL_HOME%\bin;，如果原变量值结尾没有分号，需要先加分号。如下图所示： 配置环境变量后启动MySQL就不必到MySQL的bin目录下启动了，直接在cmd中直接输入net start mysql 启动服务了。 初始化MySQLwin7用户使用window+R（更高系统版本需要搜索程序cmd右键以管理员身份运行）以管理员身份运行cmd，依次输入命令d:，cd D:\MySQL\mysql-5.7.21-winx64\bin进入MySQL的bin目录，执行mysqld --initialize进行初始化，此时你的MySQL根目录下会生成一个data文件夹，如下图所示： 安装启动MySQL服务还是在bin路径下输入：mysqld install，此时会提示服务安装成功。至此，MySQL（解压版）安装成功！直接在cmd中输入：net start mysql，提示服务启动成功。 登录MySQLcmd输入：mysql -u root -p,这时会提示你输入密码。打开MySQL根目录下的data文件夹，找到后缀是.err的文件以文本打开找到password临时密码（可以ctrl+f搜索）然后在cmd中输入该临时密码。当cmd出现下图信息则代表登录成功。 修改root密码在上述的mysql&gt;后输入：set password for 用户名@localhost = password(&#39;新密码&#39;);，用户名一般是root，并设置新密码，如图所示： 停止服务cmd输入：net stop mysql，提示服务已成功停止。 结尾好了，到这里MySQL就已经安装完成了，祝大家顺利安装！]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL数据类型]]></title>
    <url>%2F2019%2F01%2F14%2Fblog20190114%2F</url>
    <content type="text"><![CDATA[前言MySQL中定义数据字段的类型对数据库的优化是非常重要的，MySQL支持多种类型，大致可以分为五类：整数类型、浮点数类型、日期类型、字符串类型和其他数据类型。对于Mysql的一些常用数据类型了解程度仅限于一知半解，仅仅能满足满足于平时一些最简单的操作。而Mysql常用数据类型的定义以及规范理解的并不是特别的透彻，对于这些东西的理解并不深刻，经不起推敲和较真。故有此文，帮助自己总结归纳，并加深理解。 MySQL的数据类型主要包括以下五大类：整数类型：BIT、BOOL、TINY INT、SMALL INT、MEDIUM INT、 INT、 BIG INT浮点数类型：FLOAT、DOUBLE、DECIMAL字符串类型：CHAR、VARCHAR、TINY TEXT、TEXT、MEDIUM TEXT、LONGTEXT、TINY BLOB、BLOB、MEDIUM BLOB、LONG BLOB日期类型：Date、DateTime、TimeStamp、Time、Year其他数据类型：BINARY、VARBINARY、ENUM、SET、Geometry、Point、MultiPoint、LineString、MultiLineString、Polygon、GeometryCollection等 整型 MySQL数据类型 含义（有符号） tinyint(m) 1个字节 范围(-128~127) smallint(m) 2个字节 范围(-32768~32767) mediumint(m) 3个字节 范围(-8388608~8388607) int(m) 4个字节 范围(-2147483648~2147483647) bigint(m) 8个字节 范围(+-9.22*10的18次方) 取值范围如果加了unsigned，则最大值翻倍，如tinyint unsigned的取值范围为(0~256)。int(m)里的m是表示SELECT查询结果集中的显示宽度，并不影响实际的取值范围，没有影响到显示的宽度，不知道这个m有什么用。 浮点型(float和double) MySQL数据类型 含义 float(m,d) 单精度浮点型 8位精度(4字节) m总个数，d小数位 double(m,d) 双精度浮点型 16位精度(8字节) m总个数，d小数位 设一个字段定义为float(6,3)，如果插入一个数123.45678,实际数据库里存的是123.457，但总个数还以实际为准，即6位。整数部分最大是3位，如果插入数12.123456，存储的是12.1234，如果插入12.12，存储的是12.1200. 定点数浮点型在数据库中存放的是近似值，而定点类型在数据库中存放的是精确值。decimal(m,d) 参数m&lt;65 是总个数，d&lt;30且 小于m是小数位。 字符串(char,varchar,_text) MySQL数据类型 含义 char(n) 固定长度，最多255个字符 varchar(n) 固定长度，最多65535个字符 tinytext 可变长度，最多255个字符 text 可变长度，最多65535个字符 mediumtext 可变长度，最多2的24次方-1个字符 longtext 可变长度，最多2的32次方-1个字符 char和varchar： char(n) 若存入字符数小于n，则以空格补于其后，查询之时再将空格去掉。所以char类型存储的字符串末尾不能有空格，varchar不限于此。 char(n) 固定长度，char(4)不管是存入几个字符，都将占用4个字节，varchar是存入的实际字符数+1个字节（n&lt;=255）或2个字节(n&gt;255)，所以varchar(4),存入3个字符将占用4个字节。 char类型的字符串检索速度要比varchar类型的快。 varchar和text： varchar可指定n，text不能指定，内部存储varchar是存入的实际字符数+1个字节（n&lt;=255）或2个字节(n&gt;255)，text是实际字符数+2个字节。 text类型不能有默认值。 varchar可直接创建索引，text创建索引要指定前多少个字符。varchar查询速度快于text,在都创建索引的情况下，text的索引似乎不起作用。 二进制数据(_Blob) _BLOB和_text存储方式不同，_TEXT以文本方式存储，英文存储区分大小写，而_Blob是以二进制方式存储，不分大小写。 _BLOB存储的数据只能整体读出。 _TEXT可以指定字符集，_BLO不用指定字符集。 日期时间类型 MySQL数据类型 含义 date 日期 ‘2019-01-12’ time 时间 ‘12:25:36’ datetime 日期时间 ‘2019-01-12 22:06:44’ timestamp 自动存储记录修改时间 若定义一个字段为timestamp，这个字段里的时间数据会随其他字段修改的时候自动刷新，所以这个数据类型的字段可以存放这条记录最后被修改的时间。 数据类型的属性 MySQL数据类型 含义 NULL 数据列可包含NULL值 NOT NULL 数据列不允许包含NULL值 DEFAULT 默认值 PRIMARY KEY 主键 AUTO_INCREMENT 自动递增，适用于整数类型 UNSIGNED 无符号 CHARACTER SET name 指定一个字符集 MySQL数据类型的长度和范围各数据类型及字节长度一览表： MySQL数据类型 字节长度 范围或用法 Bit 1 无符号[0,255]，有符号[-128,127]，天缘博客备注：BIT和BOOL布尔型都占用1字节 TinyInt 1 整数[0,255] SmallInt 2 无符号[0,65535]，有符号[-32768,32767] MediumInt 3 无符号[0,2^24-1]，有符号[-2^23,2^23-1]] Int 4 无符号[0,2^32-1]，有符号[-2^31,2^31-1] BigInt 8 无符号[0,2^64-1]，有符号[-2^63 ,2^63 -1] Float(M,D) 4 单精度浮点数。天缘博客提醒这里的D是精度，如果D&lt;=24则为默认的FLOAT，如果D&gt;24则会自动被转换为DOUBLE型。 Double(M,D) 8 双精度浮点。 Decimal(M,D) M+1或M+2 未打包的浮点数，用法类似于FLOAT和DOUBLE，天缘博客提醒您如果在ASP中使用到Decimal数据类型，直接从数据库读出来的Decimal可能需要先转换成Float或Double类型后再进行运算。 Date 3 以YYYY-MM-DD的格式显示，比如：2009-07-19 Datetime 8 以YYYY-MM-DD HH:MM:SS的格式显示，比如：2009-07-19 11：22：30 TimeStamp 4 以YYYY-MM-DD的格式显示，比如：2009-07-19 Time 3 以HH:MM:SS的格式显示。比如：11：22：30 Year 1 以YYYY的格式显示。比如：2009 Char(M) M 定长字符串。 VarChar(M) M 变长字符串，要求M&lt;=255 Binary(M) M 类似Char的二进制存储，特点是插入定长不足补0 VarBinary(M) M 类似VarChar的变长二进制存储，特点是定长不补0 Tiny Text Max:255 大小写不敏感 Text Max:64K 大小写不敏感 Medium Text Max:16M 大小写不敏感 Long Tex t Max:4G 大小写不敏感 TinyBlob Max:255 大小写敏感 Blob Max:64K 大小写敏感 MediumBlob Max:16M 大小写敏感 LongBlob Max:4G 大小写敏感 Enum 1或2 最大可达65535个不同的枚举值 Set 可达8 最大可达64个不同的值 Geometry Point LineString Polygon MultiPoint MultiLineString MultiPolygon GeometryCollection MySQL数据类型使用建议 在指定数据类型的时候一般是采用从小原则，比如能用TINY INT的最好就不用INT，能用FLOAT类型的就不用DOUBLE类型，这样会对MYSQL在运行效率上提高很大，尤其是大数据量测试条件下。 不需要把数据表设计的太过复杂，功能模块上区分或许对于后期的维护更为方便，慎重出现大杂烩数据表 数据表和字段的起名字也是一门学问 设计数据表结构之前请先想象一下是你的房间，或许结果会更加合理、高效 数据库的最后设计结果一定是效率和可扩展性的折中，偏向任何一方都是欠妥的 附录：选择数据类型的基本原则前提：使用合适的存储引擎。选择原则：根据选定的存储引擎，确定如何选择合适的数据类型。下面的选择方法按存储引擎分类： MyISAM 数据存储引擎和数据列：MyISAM数据表，最好使用固定长度(CHAR)的数据列代替可变长度(VARCHAR)的数据列。 MEMORY存储引擎和数据列：MEMORY数据表目前都使用固定长度的数据行存储，因此无论使用CHAR或VARCHAR列都没有关系。两者都是作为CHAR类型处理的。 InnoDB 存储引擎和数据列：建议使用 VARCHAR类型。 对于InnoDB数据表，内部的行存储格式没有区分固定长度和可变长度列（所有数据行都使用指向数据列值的头指针），因此在本质上，使用固定长度的CHAR列不一定比使用可变长度VARCHAR列简单。因而，主要的性能因素是数据行使用的存储总量。由于CHAR平均占用的空间多于VARCHAR，因 此使用VARCHAR来最小化需要处理的数据行的存储总量和磁盘I/O是比较好的。 char与varcharCHAR和VARCHAR类型类似，但它们保存和检索的方式不同。它们的最大长度和是否尾部空格被保留等方面也不同。在存储或检索过程中不进行大小写转换。下面的表显示了将各种字符串值保存到CHAR(4)和VARCHAR(4)列后的结果，说明了CHAR和VARCHAR之间的差别： 值 CHAR(4) 存储需求 VARCHAR(4) 存储需求 ‘’ ‘ ‘ 4个字节 ‘’ 1个字节 ‘ab’ ‘ab ‘ 4个字节 ‘ab ‘ 3个字节 ‘abcd’ ‘abcd’ 4个字节 ‘abcd’ 5个字节 ‘abcdefgh’ ‘abcd’ 4个字节 ‘abcd’ 5个字节 请注意上表中最后一行的值只适用不使用严格模式时；如果MySQL运行在严格模式，超过列长度不的值不保存，并且会出现错误。从CHAR(4)和VARCHAR(4)列检索的值并不总是相同，因为检索时从CHAR列删除了尾部的空格。 text和blob在使用text和blob字段类型时要注意以下几点，以便更好的发挥数据库的性能。 BLOB和TEXT值也会引起自己的一些问题，特别是执行了大量的删除或更新操作的时候。删除这种值会在数据表中留下很大的”空洞”，以后填入这些”空洞”的记录可能长度不同,为了提高性能,建议定期使用 OPTIMIZE TABLE 功能对这类表进行碎片整理. 使用合成的（synthetic）索引。合成的索引列在某些时候是有用的。一种办法是根据其它的列的内容建立一个散列值，并把这个值存储在单独的数据列中。接下来你就可以通过检索散列值找到数据行了。但是，我们要注意这种技术只能用于精确匹配的查询（散列值对于类似&lt;或&gt;=等范围搜索操作符 是没有用处的）。我们可以使用MD5()函数生成散列值，也可以使用SHA1()或CRC32()，或者使用自己的应用程序逻辑来计算散列值。请记住数值型散列值可以很高效率地存储。同样，如果散列算法生成的字符串带有尾部空格，就不要把它们存储在CHAR或VARCHAR列中，它们会受到尾部空格去除的影响。合成的散列索引对于那些BLOB或TEXT数据列特别有用。用散列标识符值查找的速度比搜索BLOB列本身的速度快很多。 在不必要的时候避免检索大型的BLOB或TEXT值。例如，SELECT *查询就不是很好的想法，除非你能够确定作为约束条件的WHERE子句只会找到所需要的数据行。否则，你可能毫无目的地在网络上传输大量的值。这也是 BLOB或TEXT标识符信息存储在合成的索引列中对我们有所帮助的例子。你可以搜索索引列，决定那些需要的数据行，然后从合格的数据行中检索BLOB或 TEXT值。 把BLOB或TEXT列分离到单独的表中。在某些环境中，如果把这些数据列移动到第二张数据表中，可以让你把原数据表中 的数据列转换为固定长度的数据行格式，那么它就是有意义的。这会减少主表中的碎片，使你得到固定长度数据行的性能优势。它还使你在主数据表上运行 SELECT *查询的时候不会通过网络传输大量的BLOB或TEXT值。 浮点数与定点数为了能够引起大家的重视，在介绍浮点数与定点数以前先让大家看一个例子： 12345678910111213mysql&gt; CREATE TABLE test (c1 float(10,2),c2 decimal(10,2));Query OK, 0 rows affected (0.29 sec)mysql&gt; insert into test values(131072.32,131072.32);Query OK, 1 row affected (0.07 sec)mysql&gt; select * from test;+-----------+-----------+| c1 | c2 |+-----------+-----------+| 131072.31 | 131072.32 |+-----------+-----------+1 row in set (0.00 sec) 从上面的例子中我们看到c1列的值由131072.32变成了131072.31，这就是浮点数的不精确性造成的。在mysql中float、double（或real）是浮点数，decimal（或numberic）是定点数。浮点数相对于定点数的优点是在长度一定的情况下，浮点数能够表示更大的数据范围；它的缺点是会引起精度问题。在今后关于浮点数和定点数的应用中，大家要记住以下几点： 浮点数存在误差问题； 对货币等对精度敏感的数据，应该用定点数表示或存储； 编程中，如果用到浮点数，要特别注意误差问题，并尽量避免做浮点数比较； 要注意浮点数中一些特殊值的处理。 结尾关于Mysql的数据类型，就总结记录到这里，以后会继续补充，希望能给大家带来帮助！]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL常见的存储引擎]]></title>
    <url>%2F2019%2F01%2F04%2Fblog20190104%2F</url>
    <content type="text"><![CDATA[前言数据库存储引擎是数据库底层软件组织，数据库管理系统（DBMS）使用数据引擎进行创建、查询、更新和删除数据。不同的存储引擎提供不同的存储机制、索引技巧、锁定水平等功能，使用不同的存储引擎，还可以获得特定的功能。现在许多不同的数据库管理系统都支持多种不同的数据引擎,MySQL的核心就是存储引擎。在MySQL中的存储引擎有很多种，可以通过“SHOW ENGINES”语句来查看。下面重点关注InnoDB、MyISAM、MEMORY这三种。 InnoDB存储引擎 InnoDB给MySQL的表提供了事务处理、回滚、崩溃修复能力和多版本并发控制的事务安全。在MySQL从3.23.34a开始包含InnnoDB。它是MySQL上第一个提供外键约束的表引擎。而且InnoDB对事务处理的能力，也是其他存储引擎不能比拟的。靠后版本的MySQL的默认存储引擎就是InnoDB。 InnoDB存储引擎总支持AUTO_INCREMENT。自动增长列的值不能为空，并且值必须唯一。MySQL中规定自增列必须为主键。在插入值的时候，如果自动增长列不输入值，则插入的值为自动增长后的值；如果输入的值为0或空（NULL），则插入的值也是自动增长后的值；如果插入某个确定的值，且该值在前面没有出现过，就可以直接插入。 InnoDB还支持外键（FOREIGN KEY）。外键所在的表叫做子表，外键所依赖（REFERENCES）的表叫做父表。父表中被字表外键关联的字段必须为主键。当删除、更新父表中的某条信息时，子表也必须有相应的改变，这是数据库的参照完整性规则。 InnoDB中，创建的表的表结构存储在.frm文件中。数据和索引存储在innodb_data_home_dir和innodb_data_file_path定义的表空间中。 InnoDB的优势在于提供了良好的事务处理、崩溃修复能力和并发控制。缺点是读写效率较差，占用的数据空间相对较大。 MyISAM存储引擎 MyISAM是MySQL中常见的存储引擎，曾经是MySQL的默认存储引擎。MyISAM是基于ISAM引擎发展起来的，增加了许多有用的扩展。 MyISAM的表存储成3个文件。文件的名字与表名相同。拓展名为frm、MYD、MYI。其实，frm文件存储表的结构；MYD文件存储数据，是MYData的缩写；MYI文件存储索引，是MYIndex的缩写。 基于MyISAM存储引擎的表支持3种不同的存储格式。包括静态型、动态型和压缩型。其中，静态型是MyISAM的默认存储格式，它的字段是固定长度的；动态型包含变长字段，记录的长度不是固定的；压缩型需要用到myisampack工具，占用的磁盘空间较小。 MyISAM的优势在于占用空间小，处理速度快。缺点是不支持事务的完整性和并发性。 MEMORY存储引擎 MEMORY是MySQL中一类特殊的存储引擎。它使用存储在内存中的内容来创建表，而且数据全部放在内存中。这些特性与前面的两个很不同。 每个基于MEMORY存储引擎的表实际对应一个磁盘文件。该文件的文件名与表名相同，类型为frm类型。该文件中只存储表的结构。而其数据文件，都是存储在内存中，这样有利于数据的快速处理，提高整个表的效率。值得注意的是，服务器需要有足够的内存来维持MEMORY存储引擎的表的使用。如果不需要了，可以释放内存，甚至删除不需要的表。 MEMORY默认使用哈希索引。速度比使用B型树索引快。当然如果你想用B型树索引，可以在创建索引时指定。 注意，MEMORY用到的很少，因为它是把数据存到内存中，如果内存出现异常就会影响数据。如果重启或者关机，所有数据都会消失。因此，基于MEMORY的表的生命周期很短，一般是一次性的。 存储引擎的选择不同的存储引擎都有各自的特点，以适应不同的需求，如下表所示： 特性 InnoDB MyISAM MEMORY 存储限制 支持 无 无 事物安全 64TB 有 有 空间使用 高 低 低 内存使用 高 低 高 插入速度 低 高 高 外键支持 支持 无 无 InnoDB：支持事务处理，支持外键，支持崩溃修复能力和并发控制。如果需要对事务的完整性要求比较高（比如银行），要求实现并发控制（比如售票），那选择InnoDB有很大的优势。如果需要频繁的更新、删除操作的数据库，也可以选择InnoDB，因为支持事务的提交（commit）和回滚（rollback）。 MyISAM：插入数据快，空间和内存使用比较低。如果表主要是用于插入新记录和读出记录，那么选择MyISAM能实现处理高效率。如果应用的完整性、并发性要求比 较低，也可以使用。 MEMORY：所有的数据都在内存中，数据的处理速度快，但是安全性不高。如果需要很快的读写速度，对数据的安全性要求较低，可以选择MEMOEY。它对表的大小有要求，不能建立太大的表。所以，这类数据库只使用在相对较小的数据库表。 注意，同一个数据库也可以使用多种存储引擎的表。如果一个表要求比较高的事务处理，可以选择InnoDB。这个数据库中可以将查询要求比较高的表选择MyISAM存储。如果该数据库需要一个用于查询的临时表，可以选择MEMORY存储引擎。 结尾使用哪一种引擎需要灵活选择，一个数据库中多个表可以使用不同引擎以满足各种性能和实际需求，使用合适的存储引擎，将会提高整个数据库的性能。MySQL常见的存储引擎就介绍到这里了！]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sublime Text3安装教程]]></title>
    <url>%2F2019%2F01%2F04%2Fblog20181214%2F</url>
    <content type="text"><![CDATA[前言Sublime Text是2008年开发出来的一个代码编辑器，界面友好，功能非凡， 默认支持html, xml, javascript, ruby, python, php… 等等主流语言的语法高亮，它支持众多插件扩展，用它来写代码，绝对是一种享受。但是ST再强大也只是一个文本编辑器，不是真正意义上的IDE,像打断点调试这样的ST是做不到的。 Sublime Text3安装Windows系统下访问sublimetext官网，点击DOWNLOAD FOR WINDOWS按钮下载最新版，这里下载的是3176版本，如下图所示： 下载完成后，运行程序开始安装，点击Next,选择合适的安装目录后Next，点击Install开始安装。安装完成后，运行Sublime后点击Help选项里的Enter License选项，将激活码填入即可，如下图所示：12345678910111213----- BEGIN LICENSE -----sgbteamSingle User LicenseEA7E-11532598891CBB9 F1513E4F 1A3405C1 A865D53F115F202E 7B91AB2D 0D2A40ED 352B269B76E84F0B CD69BFC7 59F2DFEF E267328F215652A3 E88F9D8F 4C38E3BA 5B2DAAE4969624E7 DC9CD4D5 717FB40C 1B9738CF20B3C4F1 E917B5B3 87C38D9C ACCE7DD85F7EF854 86B9743C FADC04AA FB0DA5C0F913BE58 42FEA319 F954EFDD AE881E0B------ END LICENSE ------ 安装常用插件直接安装安装Sublime text3插件很方便，可以直接下载安装包解压缩到Packages目录（preferences-&gt;Browse Packages）。 使用Package Control组件安装（以LESS为例） 按Ctrl+ `(此符号为tab按键上面的按键) 调出console（注：避免热键冲突） 粘贴以下代码到命令行并回车： 123import urllib.request,os; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path();urllib.request.install_opener ( urllib.request.build_opener( urllib.request.ProxyHandler()) );open(os.path.join(ipp, pf), &apos;wb&apos;).write(urllib.request.urlopen ( &apos;http://sublime.wbond.net/&apos; + pf.replace(&apos; &apos;,&apos;%20&apos;)).read()) 重启Sublime Text 3。 如果在Perferences-&gt;package settings中看到package control这一项，则安装成功。 Package Control安装插件的方法: 按下Ctrl+Shift+P调出命令面板 输入install 调出 Install Package 选项并回车，如下图所示： 然后在列表中选择要安装的插件,如图所示： 等待一会即可完成安装！ 结尾好了，到这里Sublime Text3就已经安装完成了，大家赶紧去尝试，享受编码的乐趣吧！]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[IDEA安装教程]]></title>
    <url>%2F2019%2F01%2F04%2Fblog20181211%2F</url>
    <content type="text"><![CDATA[前言说起Java的IDE,大家琅琅上口的不外乎Jbuilder,Eclipse,NetBeans这三个,如果你只是想找个IDE来学习Java，或者你需要漂亮的图标，再或者你的电脑配置并不高，那么Eclipse是个不错的选择。如果你想找个能提升开发效率的IDE，想找一个更快更方便的工具，推荐你用IntelliJ IDEA。 IntelliJ IDEA优势 更好的调试。IntelliJ IDEA在调试上的表现，可以说比Eclipse强大太多。在调试过程中哦，当我们需要求一些表达式的值时，如果使用Eclipse就需要选定整个表达式，然后用Crtl+Shift+I看到这个表达式的值。但是，在IntelliJ IDEA中，只需要移动光标到表达式下然后用Alt+F8就可以实现。IntelliJ IDEA能够很好地理解你可能需要的表达式，还会给出的建议参数变量。你可以直接编辑并能立刻得到这个表达式的值，不会像在Eclipse中一个Debug界面跳来跳去。 更高的开发效率。IntelliJ IDEA在代码自动生成方面表现比Eclipse更为智能，比如IntelliJ IDEA能生成某个类的测试类，还能正确地放到test的相应目录下。在对ZenCoding的支持上，写html非常方便，tab快速补全，和原生集成一样。IntelliJ IDEA在开发效率上更明显的一点是，对JS、CSS以及插件的支持更好。 更智能的重构。这一点其实也属于开发效率，但是IntelliJ IDEA得重构功能还是想让我单独强调一下。所有的现代IDE都提供重构功能，这一点上，IntelliJ IDEA能读懂你需要什么，并且会针对不同的情况给你提供最合适的解决方案。 目录分层少而清。IntelliJ IDEA的目录分层很少，但是却很清晰，IDE配置的东西都能在Settings利找到，工程的配置也能在Project Settings里找到。 IntelliJ IDEA安装访问地址IDEA历史版本，选择合适的版本，这里楼主选择的是15.0.6终极版。如图： 点击下载,下载完成后，运行程序开始安装，点击Next，选择合适的安装目录后Next，勾选Create Desktop shortcut创建桌面快捷方式Next后点击Install开始安装。几分钟后安装完成关闭安装页面。打开桌面上的IntelliJ IDEA 15.0.6，进入页面后选择合适的主题，点击Register激活产品！ 访问地址获取激活码，点击获得注册码，将注册码复制粘贴到框里即可! 结尾好了，到这里IDEA就已经安装完成了，大家赶紧去尝试，享受编码的乐趣吧！]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java8十大新特性整理]]></title>
    <url>%2F2019%2F01%2F04%2Fblog20181210%2F</url>
    <content type="text"><![CDATA[前言Java8已经发布很久了，毫无疑问，这是继java5之后一次重大的版本升级，这个版本包含语言、编译器、库、工具和JVM等方面的十多个新特性。有人认为，虽然这些新特性领Java开发人员十分期待，但同时也需要花不少精力去学习。因此，本文综合了一些资料，整理成一份关于Java 8新特性的参考教材，希望你有所收获。本文中所用的实例请点击：Java8新特性实例 Lambda表达式语法Lambda表达式的语法格式如下：(parameters)-&gt;expression 或 (parameters)-&gt;{statements;} 以下是Lambda表达式的重要特征： 可选类型声明：不需要声明参数类型，编译器可以统一识别参数值； 可选参数圆括号：一个参数无需定义圆括号，但多个参数需要定义圆括号； 可选的大括号：如果主体包含了一个语句，就不需要使用大括号； 可选的返回关键字：如果主体只有一个返回值则编译器会自动返主体回值，大括号需要指定表达式返回一个数值。 使用Lambda表达式需要注意以下两点： 使用Lambda表达式主要用来定义执行行内执行的方法类型接口，例如，一个简单方法接口。在上面例子中，我们使用各种类型的Lambda表达式来定义MathOperation接口的方法，然后我们定义了sayMessage的执行。 Lambda表达式免去了使用匿名方法的麻烦，并且给予Java简单但强大的函数化的编程能力。 变量作用域注意点： Lambda表达式只能引用标记了 final 的外层局部变量，这就是说不能在lambda 内部修改定义在域外的局部变量，否则会编译错误。 Lambda表达式的局部变量可以不用声明为 final，但是必须不可被后面的代码修改（即隐性的具有final 的语义） Lambda表达式当中不允许声明一个与局部变量同名的参数或者局部变量。 Lambda表达式实例以下是Lambda的使用实例：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * @Package: com.swz * @Description: Lambda测试 * @author: swz * @date: 2018/11/29 10:30 */public class LambdaTest &#123; final static String salutation = &quot;Hello! &quot;; public static void main(String[] args) &#123; LambdaTest LambdaTest = new LambdaTest(); // 类型声明 MathOperation addition = (int a, int b) -&gt; a + b; // 不用类型声明 MathOperation subtraction = (a, b) -&gt; a - b; // 大括号中的返回值 MathOperation multiplication = (int a, int b) -&gt; &#123; return a * b; &#125;; // 没有大括号及返回语句 MathOperation division = (int a, int b) -&gt; a / b; System.out.println(&quot;10 + 5 = &quot; + LambdaTest.operate(10, 5, addition)); System.out.println(&quot;10 - 5 = &quot; + LambdaTest.operate(10, 5, subtraction)); System.out.println(&quot;10 x 5 = &quot; + LambdaTest.operate(10, 5, multiplication)); System.out.println(&quot;10 / 5 = &quot; + LambdaTest.operate(10, 5, division)); // 不用括号 GreetingService greetService1 = message -&gt; System.out.println(&quot;Hello &quot; + message); // 用括号 GreetingService greetService2 = (message) -&gt; System.out.println(salutation + message); greetService1.sayMessage(&quot;Runoob&quot;); greetService2.sayMessage(&quot;Google&quot;); &#125; interface MathOperation &#123; int operatation(int a, int b); &#125; interface GreetingService &#123; void sayMessage(String message); &#125; private int operate(int a, int b, MathOperation mathOperation) &#123; return mathOperation.operatation(a, b); &#125;&#125; Java8方法引用方法引用通过方法的名字来指向一个方法。方法引用可以使语言的构造更紧凑简洁，减少冗余代码。方法引用使用一对冒号 :: 。 方法引用实例以下是方法引用的使用实例：1234567891011121314151617/** * @Package: com.swz * @Description: 方法引用 * @author: swz * @date: 2018/11/29 13:45 */public class MethodQuoteTest &#123; public static void main(String[] args) &#123; List names = new ArrayList&lt;&gt;(); names.add(&quot;Google&quot;); names.add(&quot;SWZ&quot;); names.add(&quot;taobao&quot;); names.forEach(System.out::println); &#125;&#125; Java8函数式接口函数式接口(FunctionalInterface)是一个有且仅有一个抽象方法，但可以有多个非抽象方法的接口。函数式接口可以被隐式转换为Lambda表达式。函数式接口可以现有的函数友好地支持Lambda。 函数式接口实例Predicate 接口是一个函数式接口，它接受一个输入参数 T，返回一个布尔值结果。该接口包含多种默认方法来将Predicate组合成其他复杂的逻辑（比如：与，或，非）。该接口用于测试对象是 true 或 false。 以下是函数式接口的实例：1234567891011121314151617181920212223242526272829/** * @Package: com.swz * @Description: 函数式接口 * @author: swz * @date: 2018/11/29 14:30 */public class FunctionalInterfaceTest &#123; public static void main(String[] args) &#123; List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9); Predicate&lt;Integer&gt; predicate = n -&gt; n % 2 == 0; // 传递参数 n System.out.print(&quot;输出所有偶数: &quot;); eval(list, predicate); Predicate&lt;Integer&gt; predicate2 = n -&gt; n &gt; 3; System.out.print(&quot;\n输出大于3的所有数字: &quot;); eval(list, predicate2 ); &#125; public static void eval(List&lt;Integer&gt; list, Predicate&lt;Integer&gt; predicate) &#123; for (Integer i : list) &#123; if (predicate.test(i)) &#123; System.out.print(i + &quot; &quot;); &#125; &#125; &#125;&#125; Java8默认方法 简单说，默认方法就是接口可以有实现方法，而且不需要实现类去实现其方法; 我们只需在方法名前面加个default关键字即可实现默认方法。 默认方法是为了解决接口的修改与现有的实现不兼容的问题。 另一个特性是接口可以声明（并且可以提供实现）静态方法 默认方法实例以下是默认方法的使用实例：123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * @Package: com.swz * @Description: 默认方法 * @author: swz * @date: 2018/11/29 15:01 */public class DefaultMethodTest &#123; public static void main(String[] args) &#123; Vehicle vehicle = new Car(); vehicle.print(); &#125; interface Vehicle &#123; default void print() &#123; System.out.println(&quot;我是一辆车!&quot;); &#125; // 静态方法 static void blowHorn() &#123; System.out.println(&quot;按喇叭!!!&quot;); &#125; &#125; interface FourWheeler &#123; default void print() &#123; System.out.println(&quot;我是一辆四轮车!&quot;); &#125; &#125; static class Car implements Vehicle, FourWheeler &#123; //@Override //public void print() &#123; // System.out.println(&quot;我是一辆四轮汽车!&quot;); //&#125; public void print() &#123; Vehicle.super.print(); FourWheeler.super.print(); Vehicle.blowHorn(); System.out.println(&quot;我是一辆汽车!&quot;); &#125; &#125;&#125; Java8 流StreamStream使用一种类似用SQL语句从数据库查询数据的直观方式来提供一种对Java集合运算和表达的高阶抽象;Stream API可以极大提高Java程序员的生产力，让程序员写出高效率、干净、简洁的代码;这种风格将要处理的元素集合看作一种流，流在管道中传输，并且可以在管道的节点上进行处理，比如筛选，排序，聚合等;元素流在管道中经过中间操作（intermediate operation）的处理，最后由最终操作(terminal operation)得到前面处理的结果。 什么是StreamStream（流）是一个来自数据源的元素队列并支持聚合操作; 元素：是特定类型的对象，形成一个队列。Java中的Stream并不会存储元素，而是按需计算; 数据源 ：流的来源。可以是集合，数组，I/O channel，产生器generator等; 聚合操作： 类似SQL语句一样的操作，比如filter, map, reduce, find,match, sorted等。 Stream流特征 Pipelining:：中间操作都会返回流对象本身。这样多个操作可以串联成一个管道，如同流式风格（fluent style）。这样做可以对操作进行优化，比如延迟执行(laziness)和短路( short-circuiting)。 内部迭代：以前对集合遍历都是通过Iterator或者For-Each的方式,显式的在集合外部进行迭代，这叫做外部迭代。Stream提供了内部迭代的方式，通过访问者模式(Visitor)实现。 Stream流实例以下是Stream流的使用实例:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * @Package: com.swz * @Description: 流Stream * @author: swz * @date: 2018/11/29 15:17 */public class StreamTest &#123; public static void main(String[] args) &#123; // stream() −为集合创建串行流。 // parallelStream() − 为集合创建并行流。 List&lt;String&gt; strings = Arrays.asList(&quot;abc&quot;, &quot;&quot;, &quot;bc&quot;, &quot;efg&quot;, &quot;&quot;, &quot;jkl&quot;); List&lt;String&gt; filtered = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.toList()); System.out.println(filtered); // Stream 提供了新的方法 &apos;forEach&apos; 来迭代流中的每个数据。以下代码片段使用forEach 输出了10个随机数 // limit 方法用于获取指定数量的流。以下代码片段使用 limit 方法打印出 10 条数据 // sorted 方法用于对流进行排序。以下代码片段使用 sorted 方法对输出的 10 个随机数进行排序 Random random = new Random(); random.ints().limit(10).sorted().forEach(System.out::println); // map 方法用于映射每个元素到对应的结果，以下代码片段使用 map 输出了元素对应的平方数： List&lt;Integer&gt; numbers = Arrays.asList(3, 2, 3, 4, 3, 5); List&lt;Integer&gt; squaresList = numbers.stream().map(i -&gt;i*i).distinct().collect(Collectors.toList()); System.out.println(squaresList); // filter 方法用于通过设置条件过滤出元素。以下代码片段使用filter 方法过滤出空字符串： List&lt;String&gt; strings2 = Arrays.asList(&quot;abc&quot;, &quot;&quot;, &quot;bc&quot;, &quot;efg&quot;, &quot;abcd&quot;,&quot;&quot;, &quot;jkl&quot;); // 获取空字符串的数量 int count = (int) strings2.stream().filter(string -&gt; string.isEmpty()).count(); System.out.println(count); // Collectors 类实现了很多归约操作，例如将流转换成集合和聚合元素。Collectors可用于返回列表或字符串： List&lt;String&gt; strings3 = Arrays.asList(&quot;abc&quot;, &quot;&quot;, &quot;bc&quot;, &quot;efg&quot;, &quot;abcd&quot;, &quot;&quot;, &quot;jkl&quot;); List&lt;String&gt; filtered3 = strings3.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.toList()); System.out.println(&quot;筛选列表: &quot; + filtered3); String mergedString = strings3.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.joining(&quot;, &quot;)); System.out.println(&quot;合并字符串: &quot; + mergedString); // 一些产生统计结果的收集器也非常有用。它们主要用于int、double、long等基本类型上，它们可以用来产生类似如下的统计结果 List&lt;Integer&gt; numbers2 = Arrays.asList(3, 2, 2, 3, 7, 3, 5); IntSummaryStatistics stats = numbers2.stream().mapToInt((x) -&gt; x).summaryStatistics(); System.out.println(&quot;列表中最大的数 : &quot; + stats.getMax()); System.out.println(&quot;列表中最小的数 : &quot; + stats.getMin()); System.out.println(&quot;所有数之和 : &quot; + stats.getSum()); System.out.println(&quot;平均数 : &quot; + stats.getAverage()); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152/** * @Package: com.swz * @Description: 流Stream * @author: swz * @date: 2018/11/29 16:02 */public class Stream2Test &#123; public static void main(String args[]) &#123; System.out.println(&quot;使用 Java 7: &quot;); // 计算空字符串 List&lt;String&gt; strings = Arrays.asList(&quot;abc&quot;, &quot;&quot;, &quot;bc&quot;, &quot;efg&quot;, &quot;abcd&quot;, &quot;&quot;, &quot;jkl&quot;); System.out.println(&quot;列表: &quot; + strings); long count = getCountEmptyStringUsingJava7(strings); System.out.println(&quot;空字符数量为: &quot; + count); count = getCountLength3UsingJava7(strings); System.out.println(&quot;字符串长度为 3 的数量为: &quot; + count); // 删除空字符串 List&lt;String&gt; filtered = deleteEmptyStringsUsingJava7(strings); System.out.println(&quot;筛选后的列表: &quot; + filtered); // 删除空字符串，并使用逗号把它们合并起来 String mergedString = getMergedStringUsingJava7(strings, &quot;, &quot;); System.out.println(&quot;合并字符串: &quot; + mergedString); List&lt;Integer&gt; numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5); // 获取列表元素平方数 List&lt;Integer&gt; squaresList = getSquares(numbers); System.out.println(&quot;平方数列表: &quot; + squaresList); List&lt;Integer&gt; integers = Arrays.asList(1, 2, 13, 4, 15, 6, 17, 8, 19); System.out.println(&quot;列表: &quot; + integers); System.out.println(&quot;列表中最大的数 : &quot; + getMax(integers)); System.out.println(&quot;列表中最小的数 : &quot; + getMin(integers)); System.out.println(&quot;所有数之和 : &quot; + getSum(integers)); System.out.println(&quot;平均数 : &quot; + getAverage(integers)); System.out.println(&quot;随机数: &quot;); // 输出10个随机数 Random random = new Random(); for (int i = 0; i &lt; 10; i++) &#123; System.out.println(random.nextInt()); &#125; System.out.println(&quot;使用 Java 8: &quot;); System.out.println(&quot;列表: &quot; + strings); count = strings.stream().filter(string -&gt; string.isEmpty()).count(); System.out.println(&quot;空字符串数量为: &quot; + count); count = strings.stream().filter(string -&gt; string.length() == 3).count(); System.out.println(&quot;字符串长度为 3 的数量为: &quot; + count); filtered = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.toList()); System.out.println(&quot;筛选后的列表: &quot; + filtered); mergedString = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.joining(&quot;, &quot;)); System.out.println(&quot;合并字符串: &quot; + mergedString); squaresList = numbers.stream().map(i -&gt; i * i).distinct().collect(Collectors.toList()); System.out.println(&quot;Squares List: &quot; + squaresList); System.out.println(&quot;列表: &quot; + integers); IntSummaryStatistics stats = integers.stream().mapToInt((x) -&gt; x).summaryStatistics(); System.out.println(&quot;列表中最大的数 : &quot; + stats.getMax()); System.out.println(&quot;列表中最小的数 : &quot; + stats.getMin()); System.out.println(&quot;所有数之和 : &quot; + stats.getSum()); System.out.println(&quot;平均数 : &quot; + stats.getAverage()); System.out.println(&quot;随机数: &quot;); random.ints().limit(10).sorted().forEach(System.out::println); // 并行处理 count = strings.parallelStream().filter(string -&gt; string.isEmpty()).count(); System.out.println(&quot;空字符串的数量为: &quot; + count); &#125; private static int getCountEmptyStringUsingJava7(List&lt;String&gt; strings) &#123; int count = 0; for (String string : strings) &#123; if (string.isEmpty()) &#123; count++; &#125; &#125; return count; &#125; private static int getCountLength3UsingJava7(List&lt;String&gt; strings) &#123; int count = 0; for (String string : strings) &#123; if (string.length() == 3) &#123; count++; &#125; &#125; return count; &#125; private static List&lt;String&gt; deleteEmptyStringsUsingJava7(List&lt;String&gt; strings) &#123; List&lt;String&gt; filteredList = new ArrayList&lt;String&gt;(); for (String string : strings) &#123; if (!string.isEmpty()) &#123; filteredList.add(string); &#125; &#125; return filteredList; &#125; private static String getMergedStringUsingJava7(List&lt;String&gt; strings, String separator) &#123; StringBuilder stringBuilder = new StringBuilder(); for (String string : strings) &#123; if (!string.isEmpty()) &#123; stringBuilder.append(string); stringBuilder.append(separator); &#125; &#125; String mergedString = stringBuilder.toString(); return mergedString.substring(0, mergedString.length() - 2); &#125; private static List&lt;Integer&gt; getSquares(List&lt;Integer&gt; numbers) &#123; List&lt;Integer&gt; squaresList = new ArrayList&lt;Integer&gt;(); for (Integer number : numbers) &#123; Integer square = new Integer(number.intValue() * number.intValue()); if (!squaresList.contains(square)) &#123; squaresList.add(square); &#125; &#125; return squaresList; &#125; private static int getMax(List&lt;Integer&gt; numbers) &#123; int max = numbers.get(0); for (int i = 1; i &lt; numbers.size(); i++) &#123; Integer number = numbers.get(i); if (number.intValue() &gt; max) &#123; max = number.intValue(); &#125; &#125; return max; &#125; private static int getMin(List&lt;Integer&gt; numbers) &#123; int min = numbers.get(0); for (int i = 1; i &lt; numbers.size(); i++) &#123; Integer number = numbers.get(i); if (number.intValue() &lt; min) &#123; min = number.intValue(); &#125; &#125; return min; &#125; private static int getSum(List numbers) &#123; int sum = (int) (numbers.get(0)); for (int i = 1; i &lt; numbers.size(); i++) &#123; sum += (int) numbers.get(i); &#125; return sum; &#125; private static int getAverage(List&lt;Integer&gt; numbers) &#123; return getSum(numbers) / numbers.size(); &#125;&#125; Java 8 Optional 类Optional类是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象；Optional十个容器：它可以保存类型为T的值，或仅仅保存null；Optional类的引入很好的解决空指针异常。 类声明以下是一个 java.util.Optional 类的声明：publicfinalclassOptional&lt;T&gt; extendsObject Optional实例以下是Optional的使用实例：12345678910111213141516171819202122232425262728293031/** * @Package: com.swz * @Description: Optional类 * @author: swz * @date: 2018/11/30 11:25 */public class OptionalTest &#123; public static void main(String[] args) &#123; OptionalTest optionalTest = new OptionalTest(); Integer value1 = null; Integer value2 = new Integer(10); // 允许传递为 null 参数 Optional&lt;Integer&gt; a = Optional.ofNullable(value1); // 如果传递的参数是 null，抛出异常 NullPointerException Optional&lt;Integer&gt; b = Optional.of(value2); System.out.println(optionalTest.sum(a, b)); &#125; public Integer sum(Optional&lt;Integer&gt; a, Optional&lt;Integer&gt; b) &#123; // 判断值是否存在 System.out.println(&quot;第一个参数值存在： &quot; + a.isPresent()); System.out.println(&quot;第二个参数值存在： &quot; + b.isPresent()); // 如果值存在，返回它，否则返回默认值 Integer value1 = a.orElse(new Integer(0)); Integer value2 = b.get(); return value1 + value2; &#125;&#125; Java8 Nashorn JavaScript Nashorn 一个 javascript 引擎。从JDK1.8开始，Nashorn取代Rhino(JDK 1.6, JDK1.7)成为Java的嵌入式JavaScript引擎。Nashorn完全支持ECMAScript 5.1规范以及一些扩展。它使用基于JSR292的新语言特性，其中包含在JDK 7中引入的 invokedynamic，将JavaScript编译成Java字节码。与先前的Rhino实现相比，这带来了2到10倍的性能提升。 jjs是个基于Nashorn引擎的命令行工具。它接受一些JavaScript源代码为参数，并且执行这些源代码 使用ScriptEngineManager, JavaScript 代码可以在 Java 中执行 Nashorn实例以下是Nashorn的使用实例：123456789101112131415161718192021222324/** * @Package: com.swz * @Description: Nashorn, javascript 引擎。 * @author: swz * @date: 2018/11/30 14:11 */public class NashornTest &#123; public static void main(String[] args) &#123; ScriptEngineManager scriptEngineManager = new ScriptEngineManager(); ScriptEngine nashorn = scriptEngineManager.getEngineByName(&quot;nashorn&quot;); String name = &quot;Runoob&quot;; Integer result = null; try &#123; nashorn.eval(&quot;print(&apos;&quot; + name + &quot;&apos;)&quot;); result = (Integer) nashorn.eval(&quot;10 + 2&quot;); &#125; catch (ScriptException e) &#123; System.out.println(&quot;执行脚本错误: &quot; + e.getMessage()); &#125; System.out.println(result.toString()); &#125;&#125; Java8 日期时间API在旧版的Java 中，日期时间API 存在诸多问题: 非线程安全 − java.util.Date 是非线程安全的，所有的日期类都是可变的，这是Java日期类最大的问题之一; 设计很差 − Java的日期/时间类的定义并不一致，在java.util和java.sql的包中都有日期类; 时区处理麻烦 − 日期类并不提供国际化，没有时区支持; Java 8 在 java.time 包下提供了很多新的 API: Local(本地) − 简化了日期时间的处理，没有时区的问题; Zoned(时区) − 通过制定的时区处理日期时间; 新的java.time包涵盖了所有处理日期，时间，日期/时间，时区，时刻（instants），过程（during）与时钟（clock）的操作. 日期时间实例以下是日期时间的使用实例：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * @Package: com.swz * @Description: 日期时间API * @author: swz * @date: 2018/11/30 14:23 */public class DateTimeTest &#123; public static void main(String[] args) &#123; // LocalDate/LocalTime 和 LocalDateTime 类可以在处理时区不是必须的情况 DateTimeTest dateTimeTest = new DateTimeTest(); dateTimeTest.testLocalDateTime(); // 如果我们需要考虑到时区，就可以使用时区的日期时间API dateTimeTest.testZonedDateTime(); &#125; public void testLocalDateTime() &#123; // 获取当前的日期时间 LocalDateTime localDateTime = LocalDateTime.now(); System.out.println(&quot;当前时间：&quot; + localDateTime); LocalDate localDate = localDateTime.toLocalDate(); System.out.println(&quot;localDate:&quot; + localDate); Month month = localDateTime.getMonth(); int day = localDateTime.getDayOfMonth(); int hours = localDateTime.getHour(); int minutes = localDateTime.getMinute(); int seconds = localDateTime.getSecond(); System.out.println(&quot;月：&quot; + month + &quot;,日: &quot; + day + &quot;,时：&quot; + hours + &quot;,分：&quot; + minutes + &quot;,秒: &quot; + seconds); LocalDateTime localDateTime1 = localDateTime.withDayOfMonth(10).withYear(2018); System.out.println(&quot;localDateTime1:&quot; + localDateTime1); // 2018-11-28 LocalDate localDate1 = LocalDate.of(2018, Month.NOVEMBER, 28); System.out.println(&quot;localDate1:&quot; + localDate1); // 22:35 LocalTime localTime = LocalTime.of(22, 30); System.out.println(&quot;localTime:&quot; + localTime); // 解析字符串 LocalTime localTime1 = LocalTime.parse(&quot;22:35:24&quot;); System.out.println(&quot;localTime1&quot; + localTime1); &#125; public void testZonedDateTime() &#123; // 获取当前时间日期 ZonedDateTime date1 = ZonedDateTime.parse(&quot;2015-12-03T10:15:30+05:30[Asia/Shanghai]&quot;); System.out.println(&quot;date1: &quot; + date1); ZoneId id = ZoneId.of(&quot;Europe/Paris&quot;); System.out.println(&quot;ZoneId: &quot; + id); ZoneId currentZone = ZoneId.systemDefault(); System.out.println(&quot;当期时区: &quot; + currentZone); &#125;&#125; Java8 Base64Base64编码已经成为Java类库的标准；Java8 内置了 Base64 编码的编码器和解码器Base64工具类提供了一套静态方法获取下面三种BASE64编解码器： 基本：输出被映射到一组字符A-Za-z0-9+/，编码不添加任何行标，输出的解码仅支持A-Za-z0-9+/; URL：输出映射到一组字符A-Za-z0-9+_，输出是URL和文件; MIME：输出隐射到MIME友好格式。输出每行不超过76字符，并且使用’\r’并跟随’\n’作为分割。编码输出最后没有行分割 Base64实例以下是Base64的使用实例：12345678910111213141516171819202122232425262728293031323334/** * @Package: com.swz * @Description: Base64编码 * @author: swz * @date: 2018/11/30 14:56 */public class Base64Test &#123; public static void main(String[] args) &#123; try &#123; // 使用基本编码 String base64encodedString = Base64.getEncoder().encodeToString(&quot;runoob?java8&quot;.getBytes(&quot;utf-8&quot;)); System.out.println(&quot;Base64编码字符串(基本)：&quot; + base64encodedString); // 解码 byte[] base64decodedBytes = Base64.getDecoder().decode(base64encodedString); System.out.println(&quot;原始字符串: &quot; + new String(base64decodedBytes, &quot;utf-8&quot;)); // 使用URL编码 base64encodedString = Base64.getUrlEncoder().encodeToString(&quot;TutorialsPoint?java8&quot;.getBytes(&quot;utf-8&quot;)); System.out.println(&quot;Base64 编码字符串 (URL) :&quot; + base64encodedString); // 使用MIME编码 StringBuilder stringBuilder = new StringBuilder(); for (int i = 0; i &lt; 10; ++i) &#123; stringBuilder.append(UUID.randomUUID().toString()); &#125; byte[] mimeBytes = stringBuilder.toString().getBytes(&quot;utf-8&quot;); String mimeEncodedString = Base64.getMimeEncoder().encodeToString(mimeBytes); System.out.println(&quot;Base64 编码字符串 (MIME) :&quot; + mimeEncodedString); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 重复注解-RepeatingAnnotationTest以下是重复注解的使用实例：123456789101112131415161718192021222324252627282930313233/** * @Package: com.swz * @Description: 重复注解，拓宽注解的应用场景 * @author: swz * @date: 2018/11/30 15:18 */public class RepeatingAnnotationTest &#123; public static void main(String[] args) &#123; for( Filter filter: Filterable.class.getAnnotationsByType( Filter.class ) ) &#123; System.out.println( filter.value() ); &#125; &#125; @Target( ElementType.TYPE ) @Retention( RetentionPolicy.RUNTIME ) public @interface Filters &#123; Filter[] value(); &#125; @Target( ElementType.TYPE ) @Retention( RetentionPolicy.RUNTIME ) @Repeatable( Filters.class ) public @interface Filter &#123; String value(); &#125; @Filter( &quot;filter1&quot; ) @Filter( &quot;filter2&quot; ) public interface Filterable &#123; &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql常用函数]]></title>
    <url>%2F2019%2F01%2F04%2Fblog20181207%2F</url>
    <content type="text"><![CDATA[文章描述 MySQL数据库中提供了很丰富的函数。MySQL函数包括数学函数、字符串函数、日期和时间函数、条件判断函数、系统信息函数、加密函数、格式化函数等。通过这些函数，可以简化用户的操作。以下是对mysql中的常用函数进行了汇总介绍，需要的朋友可以过来参考下。 数字函数 函数 描述 ABS(x) 返回x的绝对值 BIN(x) 返回x的二进制（OCT-八进制，HEX-十六进制） CEILING(x) 返回大于x的最小整数值 EXP(x) 返回值e（自然对数的底）的x次方 FLOOR(x) 返回小于x的最大整数值 GREATEST(x1…,xn) 返回集合中最大的值 LEAST(x1…,xn) 返回集合中最小的值 LN(x) 返回x的自然对数 LOG(x,y) 返回x的以y为底的对数 MOD(x,y) 返回x的以y为底的对数 RAND() 随机数生成器生成一个指定的值 ROUND(x,y) 返回参数x的四舍五入的有y位小数的值 SIGN(x) 返回代表数字x的符号的值 SQRT(x) 返回一个数的平方根 TRUNCATE(x,y) 返回数字x截短为y位小数的结果 聚合函数 函数 描述 AVG(col) 返回指定列的平均值 COUNT(col) 返回指定列中非NULL值的个数 MIN(col) 返回指定列的最小值 MAX(col) 返回指定列的最大值 SUM(col) 返回指定列的所有值之和 GROUP_CONCAT(col) 返回由属于一组的列值连接组合而成的结果 字符串函数 函数 描述 ASCII(char) 返回字符的ASCII码值 BIT_LENGTH(str) 返回字符串的比特长度 CONCAT(s1,s2…,sn) 将s1,s2…,sn连接成字符串 CONCAT_WS(sep,s1,s2…,sn) 将s1,s2…,sn连接成字符串，并用sep字符间隔 LEFT(str,x) 返回字符串str中最左边的x个字符 LTRIM(str) 从字符串str中切掉开头的空格 POSITION(substr,str) substr在字符串str中第一次出现的位置 QUOTE(str) 用反斜杠转义str中的单引号 REPEAT(str,srchstr,rplcstr) 返回字符串str重复x次的结果 REVERSE(str) 返回颠倒字符串str的结果 RIGHT(str,x) 返回字符串str中最右边的x个字符 RTRIM(str) 返回字符串str尾部的空格 STRCMP(s1,s2) 比较字符串s1和s2 TRIM(str) 去除字符串首部和尾部的所有空格 UCASE(str)/UPPER(str) 返回字符串str中所有字符改变为大写后的结果 LCASE(str)/LOWER(str) 返回字符串str中所有字符改变为小写后的结果 日期和时间函数 函数 描述 CURDATE()/CURRENT_DATE() 返回当前的日期 CURTIME()/CURRENT_TIME() 返回当前的时间 DATE_FORMAT(date,fmt) 依照指定的fmt格式格式化日期date值 STR_TO_DATE(str,fmt) 字符串转日期,fmt格式必须和str的格式相同 DAYOFWEEK(date) 返回date所代表的一星期中的第几天(1~7) DAYOFMONTH(date) 返回date是一个月的第几天(1~31) DAYOFYEAR(date) 返回date是一年的第几天(1~366) FROM_UNIXTIME(ts,fmt) 根据指定的fmt格式，格式化UNIX时间戳ts UNIX_TIMESTAMP(date) 把字符串日期转成时间戳 NOW() 返回当前的日期和时间 WEEK(date) 返回日期date为一年中第几周(0~53) YEAR(date) 返回日期date的年份(1000~9999) 1234SELECT FROM_UNIXTIME(UNIX_TIMESTAMP());SELECT EXTRACT(YEAR_MONTH FROM CURRENT_DATE);SELECT EXTRACT(DAY_SECOND FROM CURRENT_DATE);SELECT EXTRACT(HOUR_MINUTE FROM CURRENT_DATE); 系统信息函数 函数 描述 DATABASE() 返回当前数据库名 BENCHMARK(count,expr) 返回当前的时间 CONNECTION_ID() 返回当前客户的连接ID FOUND_ROWS() 返回最后一个SELECT查询进行检索的总行数 USER()/SYSTEM_USER() 返回当前登陆用户名 VERSION() 返回MySQL服务器的版本 123456789SELECT id , `customer_name` , sex , LEFT(telephone,3) ,USER(),RAND(),WEEK(now()) ,SQRT(4) ,CONCAT(telephone,&apos;-&apos;,id),LOWER(&apos;abc&apos;), CURRENT_TIME(),UNIX_TIMESTAMP(now()),CASEWHEN sex = 1 THEN &apos;男&apos;WHEN sex = 2 THEN &apos;女&apos;else &apos;保密&apos;END AS sexFROM customer_demandORDER BY id DESCLIMIT 10 总结有些函数真的非常有用，真的希望我的总结对你有帮助。谢谢各位的阅读，也希望你能和我分享你的学习心得。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Oracle常用函数]]></title>
    <url>%2F2019%2F01%2F04%2Fblog20181206%2F</url>
    <content type="text"><![CDATA[前言在平时写PL/SQL的时候，经常要用到很多系统自带的函数，而这些函数用起来非常好用，但是每次用完以后，就又忘到脑后了，为了加深自己的印象，以及对这些函数做一个全面的总结，下面就对Oracle常见函数做个整理，方便以后查询。 常用字符函数在编写PL/SQL程序时，或多或少的需要进行字符串操作，进行字符串操作又离不开以下的这些函数。 函数 描述 LOWER(char) 将字符串表达式char中的所有大写字母转换为小写字母 UPPER(char) 将字符串表达式char中的所有小写字母转换为大写字母 INITCAP(char) 首字母转换成大写 SUBSTR(char, start, length) 返回字符串表达式char中从第start开始的length个字符 LENGTH(char) 返回字符串表达式char的长度 ASCII(char) 取char的ASCII值 CHR(number) 取number的ASCII值 REPLACE(char,search_str[,replacement_str]) 将字符串char中的子串search_str替换成replacement_str；如果search_str=null，返回char；如果replacement_str=null，则会去掉char中的search_str INSTR(char1,char2[,n[,m]]) 获取子串char2在字符串char1中的位置。n为其实搜索位置，m为子串出现的次数；n为负，则从尾部开始搜索；n\m默认为1 LPAD(char1,n,char2) 在字符串char1的左端填充字符串char2直到长度达到n;char2默认为空格，如果char1.length&gt;n，则返回char1左端的n个字符 RPAD(char1,n,char2) 在字符串char1的右端填充字符串char2直到长度达到n;char2默认为空格，如果char1.length&gt;n，则返回char1左端的n个字符 LTRIM(char1[,set]) 去掉字符串char1左端包含的set中的任意字符 RTRIM(char1[,set]) 去掉字符串char1右端包含的set中的任意字符 TRIM(char &#124; char From string) 从字符串的头尾或者两端截断特定字符 CONCAT(str1,str2) 连接字符串，同 &#124;&#124; 的作用一样 123456789101112131415161718192021222324252627282930313233343536373839404142-- LOWER测试select LOWER(&apos;HTTP://WWW.JELLYTHINK.COM&apos;) from dual; -- http://www.jellythink.com-- UPPER测试select UPPER(&apos;http://www.jellythink.com&apos;) from dual; -- HTTP://WWW.JELLYTHINK.COM-- INITCAP测试select INITCAP(&apos;jelly think&apos;) from dual; -- Jelly Think-- SUBSTR测试select SUBSTR(&apos;http://www.jellythink.com&apos;, 12, 10) from dual; -- jellythink(注：下标从1开始)-- LENGTH测试select LENGTH(&apos;JellyThink&apos;) from dual; -- 10-- ASCII测试select ASCII(&apos;A&apos;) from dual; -- 65-- CHR测试select CHR(65) from dual; -- A-- REPLACE测试select REPLACE(&apos;jellythink&apos;, &apos;think&apos;, &apos; is good&apos;) from dual; -- jelly is good-- INSTR测试select INSTR(&apos;JellyThink&apos;, &apos;Jelly&apos;, 1) from dual; -- 1-- LPAD测试select LPAD(&apos;JellyThink&apos;, 12, &apos;*&apos;) from dual; -- **JellyThink-- RPAD测试select RPAD(&apos;JellyThink&apos;, 12, &apos;*&apos;) from dual; -- JellyThink**-- LTRIM测试select LTRIM(&apos;**JellyThink&apos;, &apos;*&apos;) from dual; -- JellyThink-- RTRIM测试select RTRIM(&apos;JellyThink**&apos;, &apos;*&apos;) from dual; -- JellyThink-- TRIM测试select TRIM(&apos;*&apos; from &apos;**JellyThink**&apos;) from dual; -- JellyThinkselect TRIM(&apos; JellyThink &apos;) from dual; -- JellyThink(注：默认去掉空格) 常用日期函数每天都在和各种日期打交道，一个会得到这个月的最后一天，一会又要得到当前日期，看看以下的函数吧，是否似曾相识。 函数 描述 SYSDATE 返回系统当前日期和时间 NEXT_DAY(day,char) 返回指定日期day后的第一个工作日char所对应的日期 LAST_DAY(day) 返回day日期所指定月份中最后一天所对应的日期 ADD_MONTHS(day,n) 返回day日期在n个月后(n为正数)或前(n为负数)的日期 MONTHS_BETWEEN(day1,day2) 返回day1日期和day2日期之间相差得月份 ROUND(day[,fmt]) 返回日期的四舍五入结果。如果fmt指定年度，则7月1日为分界线；如果fmt指定月，则16日为分界线；如果指定天，则中午12:00为分界线，默认舍入到日 TRUNC(day,[,fmt]) 日期截断函数。如果fmt指定年度，则结果为本年度的1月1日；如果为月，则将结果为本月1日，默认截断到日 CURRENT_DATE 返回当前会话时区所对应日期时间 EXTRACT 从日期中获取所需要的特定数据 12345678910111213141516171819202122232425262728-- SYSDATE测试select TO_CHAR(SYSDATE,&apos;yyyy-MM-dd hh24:mi:ss&apos;) from dual; -- 2015-09-29 15:14:44-- NEXT_DAY测试select NEXT_DAY(SYSDATE, &apos;星期一&apos;) from dual; -- 2015/10/5 15:16:46-- LAST_DAY测试select LAST_DAY(SYSDATE) from dual; -- 2015/9/30 15:17:23-- ADD_MONTHS测试select ADD_MONTHS(SYSDATE, 2) from dual; -- 2015/11/29 15:18:39-- MONTHS_BETWEEN测试select MONTHS_BETWEEN(SYSDATE, SYSDATE) from dual; -- 0select MONTHS_BETWEEN(ADD_MONTHS(SYSDATE, -2), ADD_MONTHS(SYSDATE, 2)) from dual; -- -4-- ROUND测试select ROUND(SYSDATE) from dual; -- 2015/9/30select ROUND(SYSDATE, &apos;YEAR&apos;) from dual; -- 2016/1/1select ROUND(SYSDATE, &apos;MONTH&apos;) from dual; -- 2015/10/1-- TRUNC测试select TRUNC(SYSDATE) from dual; -- 2015/9/29select TRUNC(SYSDATE, &apos;YEAR&apos;) from dual; -- 2015/1/1select TRUNC(SYSDATE, &apos;MONTH&apos;) from dual; -- 2015/9/1-- CURRENT_DATE测试select CURRENT_DATE from dual; -- 2015/9/29 15:22:44 常用类型转换函数类型转换函数是太常见了，什么to_char啊，to_date啊，但是你有没有好好的使用过呢？ 函数 描述 TO_CHAR 将一个数字或日期转换成字符串 TO_NUMBER 将字符型数据转换成数字型数据 TO_DATE 将字符型数据转换为日期型数据 CAST 将一种built-in类型转换成另一种built-in类型 1234567891011121314-- TO_CHAR测试select TO_CHAR(100) from dual; -- 100select TO_CHAR(SYSDATE, &apos;YYYY-MM-DD HH24:MI:SS&apos;) from dual; -- 2015-09-29 15:36:24-- TO_NUMBER测试select TO_NUMBER(&apos;10&apos;) from dual; -- 10select TO_NUMBER(&apos;JellyThink&apos;) from dual; -- 无效数字-- TO_DATE测试select TO_DATE(&apos;2015-9-29&apos;, &apos;YYYY-MM-DD&apos;) from dual; -- 2015/9/29-- CAST测试select CAST(&apos;100&apos; as NUMBER) from dual; -- 100select CAST(2 as char) from dual; -- 2 集合函数有了GROUP BY，怎么可以少了这些用来统计的集合函数呢。 函数 描述 AVG 计算一列值的平均值 COUNT 统计一列中值的个数 MAX 求一列值中的最大值 MIN 求一列值中的最小值 SUM 计算一列值的总和 其它常用函数还有一些经常使用的函数不属于上述的任何一种分类，只能作为其它常用函数来分类了，具体你看喽。 函数 描述 decode(expression , search , result [, search , result]… [, default]) IF语句的另一形式。将输入数值与参数列表比较，返回对应值。应用于将表的行转换成列以及IF语句无法应用的场合 SIGN(number) 如果number大于0，SIGN则返回1；如果number小于0，SIGN则返回-1；如果number等于0，SIGN则返回0 TRUNC(number, [ decimal_places ]) number是要截取的数字，decimal_places是要保留的小数位。这个参数必须是个整数。 如果此参数缺省，默认保留0位小数 GREATEST(expr1[,expr2]…) 返回表达式中值最大的一个 LEAST(expr1[,expr2]…) 返回表达式中值最小的一个 NULLIF(expr1,expr2) 如果expr1=expr2；则返回null，否则返回expr1 NVL(expr1,expr2) 如果expr1=null；则返回expr2，否则返回expr1 NVL2(expr1,expr2,expr3) 如果expr1!=null；则返回expr2；如果expr1=null；则返回expr3 1234567891011121314151617181920212223242526272829-- DECODE测试select DECODE(20, 10, 5, 200, 10, 20, 30) from dual; -- 30-- SIGN测试select SIGN(20) from dual; -- 1select SIGN(-30) from dual; -- -1select SIGN(0) from dual; -- 0-- TRUNC测试select TRUNC(20.2183, 2) from dual; -- 20.21select TRUNC(20.1, 4) from dual; -- 20.1-- GREATEST测试select GREATEST(20, 100, 30, 20, 40, 400) from dual; -- 400-- LEAST测试select LEAST(20, 100, 30, 20, 40, 400) from dual; -- 20-- NULLIF测试select NULLIF(20, 20) from dual; -- NULLselect NULLIF(20, 10) from dual; -- 20-- NVL测试select NVL(20, 30) from dual; -- 20select NVL(NULL, 30) from dual; -- 30-- NVL2测试select NVL2(NULL, 20, 30) from dual; -- 30select NVL2(&apos;JellyThink&apos;, 20, 30) from dual; -- 20 总结哦，总结完了，感觉还算有点效果，至少又把这些函数重新复习了一遍，不是吗？有些函数真的非常有用，真的希望我的总结对你有帮助。谢谢各位的阅读，也希望你能和我分享你的学习心得。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
</search>
